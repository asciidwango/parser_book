<!-- Chapter 6: 第4章:文脈自由文法の世界 -->

# 第4章 文脈自由文法の世界

第3章では、JSONの構文解析器を記述することを通して、構文解析のやり方を学びました。構文解析器についても、PEG型の構文解析器および字句解析器を使った2通りを作ってみることで、構文解析器といっても色々な書き方があるのがわかってもらえたのではないかと思います。

この第4章では、現代の構文解析を語る上で必須である、文脈自由文法という概念について学ぶことにします。「文脈自由文法」というと、一見、堅くて難しそうな印象を持つ方も多いかもしれません。

しかし、実は皆さんは既に文脈自由文法を使っているのです。Javaの`if`文やメソッド定義、JSONの入れ子構造など、プログラミングで日常的に扱っている「構造」はすべて文脈自由文法で表現されています。この章では、そんな身近な例から始めて、徐々に理論的な概念を理解していきましょう。

## 身近な例から始める文脈自由文法

まず、皆さんが普段書いているJavaコードを見てみましょう。以下はシンプルなif文です。

```java
if (x > 0) {
    System.out.println("正の数です");
}
```

このif文の構造を言葉で説明すると「`if`の後に条件式を括弧で囲み、その後に文のブロックが来る」となります。さらに、if文の中にif文を書くこともできます。

```java
if (x > 0) {
    if (x > 100) {
        System.out.println("100より大きい");
    }
}
```

この「入れ子にできる構造」こそが、文脈自由文法の本質なのです。

### 括弧の対応という根本問題

プログラミングで最も基本的で重要な構造の一つが「括弧の対応」です。JavaでもJSONでも、開き括弧と閉じ括弧は必ず対応していなければなりません。

たとえば、以下は正しい括弧の対応です：

```
()          // 1組の括弧
(())        // 入れ子になった括弧
(()())      // 入れ子と並列の組み合わせ
()()()      // 並列に並んだ括弧
```

一方、以下は正しくない例です：

```
)(          // 順序が逆
(()         // 閉じ括弧が不足
())         // 開き括弧が不足
```

このような「括弧の釣り合いが取れた文字列」を表す言語をDyck言語（ディック言語）と呼びます。実は、この単純に見える問題が、構文解析の理論において極めて重要な位置を占めているのです。

### BNFで括弧の構造を表現する

さて、この括弧の対応をどのように文法として表現すればよいでしょうか？まずは皆さんに馴染みのあるBNFを使って考えてみましょう。

括弧の構造には以下の2つのパターンがあります：
1. 空文字列（括弧なし）
2. `(` + 内側の括弧構造 + `)` + 続きの括弧構造

これをBNFで書くと：

```text
D = P;
P = "(" P ")" P | "";
```

ここで`P`は「括弧のパターン」を表し、`D`は文法全体の開始地点（開始記号）です。この定義は再帰的になっていることに注目してください。`P`の定義の中に`P`自身が現れています。これこそが、入れ子構造を表現する鍵なのです。

### BNFから文脈自由文法へ

実は、上記のBNFは既に文脈自由文法の一種です。ただし、理論的な議論をする際には、より標準的な記法を使います。段階的に変換してみましょう。

**ステップ1: 選択を分離**

まず、`|`で区切られた選択肢を別々の規則に分けます：

```text
D = P;
P = "(" P ")" P;
P = "";
```

同じ`P`が2つの規則で定義されていますが、これは「Pは2つのパターンのどちらかになる」という意味です。

**ステップ2: 記号の変更**

次に、記法を数学的な標準形に近づけます：
- `=` を `→`（生成規則を表す矢印）に変更
- `""` を `ε`（イプシロン：空文字列を表す記号）に変更
- 文字を囲む引用符を削除

```text
D → P
P → ( P ) P
P → ε
```

これで文脈自由文法の標準的な記法になりました！

### 用語の整理

ここで重要な用語を整理しておきましょう：

- **生成規則**：`D → P` のような矢印で結ばれた規則
- **非終端記号**：`D`や`P`のような、さらに展開される記号（変数のようなもの）
- **終端記号**：`(`や`)`のような、これ以上展開されない記号（実際の文字）
- **開始記号**：文法の起点となる非終端記号（この例では`D`）

つまり、文脈自由文法とは：
- 生成規則の集まり
- 各生成規則は「非終端記号 → 記号の並び」の形
- 記号の並びは終端記号と非終端記号の組み合わせ（空文字列εも可）

実は、これだけのシンプルなルールで、プログラミング言語の複雑な構文を表現できるのです。

## 実例で理解する「言語」の概念

前の節で定義したDyck言語の文法をもう一度見てみましょう。

```
D → P
P → ( P ) P
P → ε
```

### プログラマーにとっての「言語」とは

これまで「言語」という用語を使ってきましたが、プログラマーにとって「言語」とは何でしょうか？

日常会話では「言語」といえば日本語や英語などの自然言語を思い浮かべますが、プログラミングの世界では少し違います。プログラミング言語には**曖昧さがありません**。同じコードは必ず同じ意味を持ちます。

では、「Java言語」や「JavaScript言語」という時、それは何を指しているのでしょうか？

### 言語を「文字列の集合」として考える

形式的には、プログラミング言語を**その言語で書ける正しいプログラムすべての集合**として定義します。

具体例で考えてみましょう。以下はすべて正しいJavaScriptプログラムです：

```javascript
console.log("Hello, World!");
```

```javascript
console.log(3);
```

```javascript
console.log(3 + 5);
```

これらを集めていくと、JavaScriptという言語は次のような文字列の集合として表現できます：

```text
JavaScript = {
  "console.log(\"Hello, World!\");",
  "console.log(3);",
  "console.log(3 + 5);",
  "const x = 10;",
  "function add(a, b) { return a + b; }",
  ...（無限に続く）
}
```

JavaScriptで書ける正しいプログラムは無限にあるので、この集合は**無限集合**になります。

### Dyck言語も集合として理解する

同様に、Dyck言語（括弧の対応が取れた文字列）も集合として表現できます：

```text
Dyck = {
  "()",
  "(())",
  "((()))",
  "(()())",
  "()()",
  "()()()",
  ...（無限に続く）
}
```

### 集合論の威力

言語を集合として扱うと、数学の集合論の記法が使えるようになります。これは単なる理論的な話ではなく、実用的な利点があります。

**例1：ある文字列が言語に含まれるかの判定**

```text
"()" ∈ Dyck         // "()"はDyck言語に含まれる
")(" ∉ Dyck         // ")("はDyck言語に含まれない
```

**例2：言語の後方互換性**

Java 8がJava 5の後方互換であることを、集合の包含関係で表現できます：

```text
Java5 ⊂ Java8      // Java 5で書けるプログラムはすべてJava 8でも書ける
```

**例3：言語の共通部分**

たとえば、「JavaScriptでもTypeScriptでも有効なプログラム」は：

```text
JavaScript ∩ TypeScript = {
  "console.log(123);",
  "const x = 5;",
  "function f() { return 1; }",
  ...
}
```

このように、言語を集合として扱うことで、言語間の関係を数学的に厳密に議論できるようになるのです。

## 正規表現の限界と文脈自由言語

### 身近な正規表現から考える

皆さんは日常的に正規表現を使っているでしょう。ファイル検索、テキスト処理、入力値の検証など、様々な場面で活躍しています。

たとえば、Javaで電話番号の形式をチェックする時：

```java
String phoneRegex = "\\d{3}-\\d{4}-\\d{4}";  // 例：090-1234-5678
if (phone.matches(phoneRegex)) {
    // 有効な電話番号
}
```

メールアドレスの簡易チェック：

```java
String emailRegex = "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}";
```

### 正規表現でできないこと

しかし、正規表現には決定的な限界があります。それは**括弧の対応が取れているかチェックできない**ということです。

試しに、以下のような文字列を正規表現で判定することを考えてみましょう：

```
OK:  (), (()), (()(()))
NG:  )(, ((), ())
```

どんなに工夫しても、任意の深さの括弧の対応を正規表現で表現することはできません。なぜでしょうか？

### 正規表現の仕組みと限界

正規表現の基本的な構成要素は以下の通りです：

```
a        文字そのもの
ab       連続（aの後にb）
a|b      選択（aまたはb）
a*       繰り返し（0回以上のa）
```

これらを組み合わせて、たとえば：
- 自然数： `0|[1-9][0-9]*`
- 郵便番号： `[0-9]{3}-[0-9]{4}`

などが表現できます。

しかし、正規表現は本質的に「有限の状態」しか記憶できません。括弧が何重にネストしているかを覚えておくには、理論的に無限の状態が必要になるため、正規表現では表現できないのです。

### 正規表現とオートマトンの深い関係

正規表現の限界を理解するには、その背後にある「オートマトン」という仕組みを知ることが重要です。実は、すべての正規表現は「有限オートマトン」という計算モデルに変換できます。

#### 有限オートマトンとは

有限オートマトンは、文字列を1文字ずつ読みながら状態を遷移していく抽象機械です。自動販売機をイメージすると分かりやすいでしょう：

- 初期状態：お金が入っていない
- 100円投入 → 100円状態へ遷移
- さらに100円投入 → 200円状態へ遷移
- 商品ボタンを押す → 商品を出して初期状態へ

#### 簡単な例：ab*の認識

正規表現 `ab*`（aの後に0個以上のb）を認識するオートマトンを考えてみましょう：

```
状態0 --a--> 状態1 --b--> 状態1
(開始)      (受理)   ↑___b___|
```

- 状態0（開始状態）：最初の状態
- 状態1（受理状態）：この状態で入力が終わればマッチ成功
- 矢印：文字を読んだときの状態遷移

このオートマトンは以下のように動作します：
- 入力"a"：状態0→状態1（受理）✓
- 入力"ab"：状態0→状態1→状態1（受理）✓
- 入力"abb"：状態0→状態1→状態1→状態1（受理）✓
- 入力"b"：状態0で'b'を読めない ✗

#### NFAとDFA：2つのオートマトン

有限オートマトンには2種類あります：

**NFA（非決定性有限オートマトン）**
- 同じ文字で複数の遷移先がある場合がある
- ε遷移（文字を読まずに移動）が可能
- 正規表現から直接的に構築しやすい

**DFA（決定性有限オートマトン）**
- 各状態で、各文字に対して遷移先は1つだけ
- ε遷移なし
- 実装が簡単で高速

#### 正規表現 (a|b)*abb のNFA

```
     ε
   ↗   ↘
  状態1  状態2
   ↓a    ↓b
  状態3  状態4
   ↘ε   ε↗
    状態5 --a--> 状態6 --b--> 状態7 --b--> 状態8
     ↑                                      (受理)
     |______________ε____________________|
```

このNFAは「aまたはbを任意回繰り返した後、abbで終わる」文字列を認識します。

#### 同じ正規表現のDFA

NFAをDFAに変換すると（部分集合構成法という手法を使います）：

```
状態{0} --a--> 状態{0,6} --b--> 状態{0,7} --b--> 状態{0,8}
  ↓b             ↓a              ↓a           (受理)
状態{0}        状態{0,6}       状態{0,6}
                 ↓b              ↓b
               状態{0,7}       状態{0}
```

#### なぜ括弧の対応は無理なのか

オートマトンは「有限」の状態しか持てません。しかし括弧の対応を確認するには：
- "(" を読むたび「開き括弧の数」を記憶
- ")" を読むたび「対応する開き括弧があるか」確認

括弧の深さは無限に深くなりうるため、無限の状態が必要になります。これが有限オートマトン（つまり正規表現）の限界です。

#### 実用上の意味

多くのプログラミング言語の正規表現エンジンは、実際にはNFAやDFAとして実装されています：

- **DFA型**：高速だが機能が限定的（POSIXの正規表現など）
- **NFA型**：後方参照などの高度な機能が使える（Perl、Java、Pythonなど）

ただし、現代の「正規表現」は理論的な正規言語を超えた機能（後方参照など）を持つため、純粋なオートマトンでは実装できません。

### 言語の階層：正規表現 < 文脈自由文法 < ...

実は、表現できる言語の能力には階層があります。

**正規言語（RL: Regular Language）**
- 正規表現で表現できる言語の集合
- 例：電話番号、メールアドレス、識別子

**文脈自由言語（CFL: Context-Free Language）**  
- 文脈自由文法で表現できる言語の集合
- 例：プログラミング言語の構文、JSON、XML
- 正規言語をすべて含む（RL ⊂ CFL）

つまり、文脈自由文法は正規表現の上位互換です。正規表現でできることはすべて文脈自由文法でもでき、さらに括弧の対応のような複雑な構造も扱えます。

### 実用上の意味

この違いは実用上極めて重要です：

**正規表現で十分な例：**
- URLの検証
- 電話番号のフォーマットチェック  
- 単純なトークンの切り出し

**文脈自由文法が必要な例：**
- プログラミング言語の構文解析
- JSONやXMLのパース
- 数式の評価（括弧を含む）

だからこそ、構文解析器を作る時には正規表現だけでなく、文脈自由文法の理解が必要になるのです。

### さらに上の階層

実は言語の階層はさらに続きます：

**文脈依存言語（CSL: Context-Sensitive Language）**
- 例：`a^n b^n c^n`（aがn個、bがn個、cがn個）
- 自然言語の一部の現象

**帰納的可算言語（Recursively Enumerable Language）**
- チューリング完全な言語（Java、Python等）が生成できるすべての文字列

階層を図にすると：

```{=latex}
\begin{center}
\begin{tikzpicture}
  % 最外側の楕円 (CSL)
  \draw[fill=blue!10,draw=blue!60,thick] (0,0) ellipse (4.5cm and 3cm);
  \node at (3.5,0) {\textcolor{blue!60}{\large CSL}};
  
  % 中間の楕円 (CFL)
  \draw[fill=green!10,draw=green!60,thick] (0,0) ellipse (3.25cm and 2.125cm);
  \node at (2.5,-0.5) {\textcolor{green!60}{\large CFL}};
  
  % 最内側の楕円 (RL)
  \draw[fill=orange!10,draw=orange!60,thick] (0,0) ellipse (2cm and 1.25cm);
  \node at (0,0) {\textcolor{orange!60}{\large RL}};
\end{tikzpicture}
\end{center}
```

プログラミング言語の**構文**は文脈自由文法で記述できますが、プログラミング言語自体の**計算能力**はチューリング完全（最上位）です。この違いを理解することが重要です。

## 文法から文字列を作る：導出の仕組み

### 生成規則の意味

文脈自由文法は「生成規則」の集まりでした。では、この「生成」とは何でしょうか？

Dyck言語の文法をもう一度見てみましょう：

```
D → P
P → ( P ) P
P → ε
```

これらの規則は「置き換えルール」として読むことができます：
- `D → P`：「Dを見たらPに置き換えてよい」
- `P → ( P ) P`：「Pを見たら( P ) Pに置き換えてよい」
- `P → ε`：「Pを見たら空文字列に置き換えてよい」

### 実際に文字列を生成してみる

`()`という文字列を生成する過程を追ってみましょう：

```
D               // 開始記号から始める
→ P             // D → P を適用
→ ( P ) P       // P → ( P ) P を適用
→ ( ε ) P       // 最初のPに P → ε を適用
→ ( ) P         // εは空文字列なので消える
→ ( ) ε         // 2番目のPに P → ε を適用  
→ ( )           // εは空文字列なので消える
```

このように、規則を順番に適用して文字列を作ることを**導出**と呼びます。

### 複数の導出方法

実は、同じ文字列を生成する方法は複数あります。たとえば、簡単な文法で考えてみましょう：

```
S → AB
A → a
B → b
```

この文法から`ab`を導出する時、どちらから先に展開するかで2通りの方法があります：

**方法1（左から展開）：**
```
S → AB → aB → ab
```

**方法2（右から展開）：**
```
S → AB → Ab → ab
```

### 最左導出と最右導出

導出方法を統一するため、2つの標準的な方法が定義されています：

**最左導出**：常に一番左の非終端記号を展開
**最右導出**：常に一番右の非終端記号を展開

より複雑な例で見てみましょう。以下の文法は「1個以上のa」の後に「1個以上のb」が続く文字列を表します：

```
S → AB
A → aA | a
B → bB | b
```

`aabb`を導出する場合：

**最左導出：**
```
S  
→ AB      (S → AB)
→ aAB     (A → aA)  
→ aaB     (A → a)
→ aabB    (B → bB)
→ aabb    (B → b)
```

**最右導出：**
```
S
→ AB      (S → AB)
→ AbB     (B → bB)
→ Abb     (B → b)  
→ aAbb    (A → aA)
→ aabb    (A → a)
```

### 構文木との関係

どちらの導出方法でも、最終的に同じ**構文木**が得られます：

```
      S
     / \
    A   B
   / \ / \
  a  A b  B
     |    |
     a    b
```

最左導出は木を左から右へ構築し、最右導出は右から左へ構築するイメージです。

### なぜ2つの導出方法が重要か

実は、これらは構文解析の2大手法に対応しています：

- **最左導出** → **下向き構文解析**（トップダウン）
- **最右導出の逆** → **上向き構文解析**（ボトムアップ）

第3章で作ったJSONパーサーは下向き構文解析の一種でした。次章では、これらの手法についてより詳しく学んでいきます。

## まとめ

この章では、文脈自由文法について学びました。最初は難しく感じたかもしれませんが、実は私たちが普段書いているプログラムと深く関わっている概念です。

### 学んだこと

1. **文脈自由文法の基礎**
   - Javaのif文やJSONの構造など、プログラミングの「入れ子構造」は文脈自由文法で表現される
   - BNFから文脈自由文法への変換は記法の違いに過ぎない
   - 生成規則、非終端記号、終端記号という基本要素で構成される

2. **言語を集合として理解する**
   - プログラミング言語は「正しいプログラムの集合」として定義できる
   - 集合論の記法を使って言語間の関係を厳密に議論できる
   - 後方互換性なども集合の包含関係として表現可能

3. **言語の階層**
   - 正規表現（正規言語）< 文脈自由文法（文脈自由言語）< ...
   - 正規表現では括弧の対応をチェックできない
   - プログラミング言語の構文解析には文脈自由文法が必要

4. **導出の仕組み**
   - 生成規則を適用して文字列を生成する過程が導出
   - 最左導出と最右導出という2つの標準的な方法がある
   - これらは下向き/上向き構文解析に対応する

### なぜこれが重要か

文脈自由文法の理解は、以下の場面で役立ちます：

- **構文解析器の実装**：第5章以降で学ぶ様々な構文解析アルゴリズムの基礎
- **言語設計**：新しいDSLやプログラミング言語を設計する際の指針
- **エラーメッセージの理解**：コンパイラのエラーメッセージがなぜそう言っているかの理解
- **ツールの選択**：正規表現で十分か、パーサーが必要かの判断

次章では、この文脈自由文法を基に、実際の構文解析アルゴリズムについて詳しく見ていきます。
