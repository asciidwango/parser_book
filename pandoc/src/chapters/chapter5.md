<!-- Chapter 3: 第5章:構文解析アルゴリズム古今東西 -->

# 第5章 構文解析アルゴリズム古今東西

第4章で学んだ文脈自由文法は、構文解析の理論的な基礎です。特にDyck言語を例に、括弧の対応という根本的な問題を通して、再帰的な構造を文法でどう表現するかを学びました。この章では、いよいよその文法を実際に解析するための「アルゴリズム」について深く掘り下げていきます。

## 本章で学ぶこと

「構文解析アルゴリズム」と聞くと難しそうに感じるかもしれません。しかし、実は皆さんはすでに2つの構文解析アルゴリズムを実装しています。

第3章を思い出してください。最初に実装した`PegJsonParser`は、**PEG（Parsing Expression Grammar）**という手法の素朴な実装でした。次に実装した`SimpleJsonParser`は、実は**LL(1)**と呼ばれる手法に近い**再帰下降構文解析器**だったのです。

この章では、これらのアルゴリズムがどのような仕組みで動いているのか、そして他にどのようなアルゴリズムが存在するのかを体系的に学びます。具体的には：

1. **下向き構文解析（Top-down）**：文法の開始記号から始めて、入力文字列に向かって解析を進める方法
   - LL(1)、LL(k)、再帰下降構文解析
   
2. **上向き構文解析（Bottom-up）**：入力文字列から始めて、文法の開始記号に向かって解析を進める方法
   - LR(0)、SLR(1)、LR(1)、LALR(1)
   
3. **PEGとPackrat Parsing**：バックトラックを許す新しいアプローチ

それぞれのアルゴリズムには得意・不得意があり、実際のプログラミング言語の構文解析器では、言語の特性に応じて最適なアルゴリズムが選ばれています。

## 構文解析器生成系との関係

各アルゴリズムには、対応する**構文解析器生成系**（パーサジェネレータ）が存在します：

- **yacc/bison**：LALR(1)を採用（C言語向け）
- **JavaCC**：LL(1)を採用（Java向け）  
- **ANTLR**：ALL(*)という拡張されたLL系を採用（多言語対応）
- **各種PEGパーサジェネレータ**：PEGを採用

これらのツールについては第6章で詳しく説明しますが、本章でアルゴリズムを理解することで、各ツールがなぜそのアルゴリズムを選んだのかが見えてくるはずです。

さあ、構文解析アルゴリズムの世界へ飛び込みましょう！

## 5.1 下向き構文解析と上向き構文解析 - 2つの世界観

構文解析アルゴリズムの世界には、大きく分けて2つの「世界観」があります。それが**下向き（Top-down）**と**上向き（Bottom-up）**です。この2つは、同じ構文解析という仕事を、まったく逆のアプローチで実現します。

### なぜ2つのアプローチが必要なのか？

第4章で学んだDyck言語を例に考えてみましょう。文法は以下でした：

```
D → P
P → ( P ) P
P → ε
```

入力文字列 `(())` を解析する際、2つの考え方ができます：

1. **下向き（予測的）**：「Dから始まって、どうすれば`(())`が導出できるか？」
2. **上向き（還元的）**：「`(())`から始めて、どうすればDに辿り着けるか？」

これは、迷路を解くときに「入口から出口を探す」か「出口から入口を探す」かの違いに似ています。どちらも正解に辿り着きますが、効率や適用できる問題が異なるのです。

## 5.2 下向き構文解析の概要

下向き構文解析は、文法の開始記号から出発し、入力文字列に向かって「上から下へ」解析を進めます。これには2つの主要な方式があります：

### 下向き構文解析の2つの方式

1. **予測型（Predictive）**：先読み文字を見て、次に適用すべき規則を「予測」する
   - 例：LL(1)、LL(k)など
   - 高速だが、文法に制約がある

2. **バックトラック型（Backtracking）**：試行錯誤を許し、失敗したら別の選択肢を試す
   - 例：PEG、再帰下降構文解析の一部
   - 柔軟だが、最悪の場合遅い

ここでは、まず予測型の下向き構文解析を詳しく見ていきましょう。

### Dyck言語で学ぶ予測型下向き構文解析

第4章で学んだDyck言語を例に、具体的に動作を追ってみましょう。説明のために、文法に入力の開始・終了を表す`$`を追加します：

```
D -> $ P $
P -> ( P ) P
P -> ε
```

入力文字列 `(())` に対して、この文法が受理するかどうかを判定してみましょう。

### スタックを使った解析の追跡

下向き構文解析では、**スタック**を使って解析の進行状況を管理します。スタックには、「今どの規則のどの位置を解析しているか」という情報を記録します。

ドット記号「・」を使って、規則内の現在位置を表します。例えば：
- `D -> ・$ P $` ：まだ何も解析していない状態
- `D -> $・P $` ：`$`を解析済み、次は`P`を解析する
- `D -> $ P $・` ：すべて解析完了

では、実際に解析を開始しましょう：

```
入力: $ ( ( ) ) $
スタック: [ D -> ・$ P $ ]
```

**ステップ2**：最初の記号 `$` を入力から読み込みます。スタックトップの規則が期待する記号と一致するので、ドットを進めます：

```
入力: ( ( ) ) $
スタック: [ D -> $・P $ ]
```

**ステップ3**：非終端記号 `P` を解析する必要があります。ここで「予測」が必要になります。

次の入力文字は `(` です。`P`の規則は2つあります：
- `P -> ( P ) P` ：`(`で始まる
- `P -> ε` ：空文字列

先読み文字が`(`なので、`P -> ( P ) P`を選択します。この規則をスタックに追加します：

```
入力: ( ( ) ) $
スタック: [ D -> $・P $, P -> ・( P ) P ]
```

**ステップ4**：入力の`(`とスタックトップの規則が期待する`(`が一致しました。入力を消費し、ドットを進めます：

```
入力: ( ) ) $
スタック: [ D -> $・P $, P -> (・P ) P ]
```

**ステップ5**：再び`P`を解析します。先読み文字はまた`(`なので、`P -> ( P ) P`を選択します：

```
入力: ( ) ) $
スタック: [ D -> $・P $, P -> (・P ) P, P -> ・( P ) P ]
```

**ステップ6**：`(`を消費してドットを進めます：

```
入力: ) ) $
スタック: [ D -> $・P $, P -> (・P ) P, P -> (・P ) P ]
```

**ステップ7**：次は`P`を解析しますが、先読み文字は`)`です。

ここが重要なポイントです：
- `P -> ( P ) P` は`(`で始まるので選択できない
- `P -> ε` は空文字列なので、どんな先読み文字でも選択可能

したがって`P -> ε`を選択します。空文字列なので入力は消費せず、ドットだけ進めます：

```
入力: ) ) $
スタック: [ D -> $・P $, P -> (・P ) P, P -> ( P・) P ]
```

次の入力 `)` とスタックトップの規則の期待する記号 `)` がマッチするので、入力を消費し、ドットを進めます。

```
入力: ) $
スタック: [ D -> $・P $, P -> (・P ) P, P -> ( P )・P ]
```

再び非終端記号 `P` を解析します。次の入力は `)` なので、規則 `P -> ε` を適用します。

```
入力: ) $
スタック: [ D -> $・P $, P -> (・P ) P, P -> ( P ) P・]
```

スタックトップの規則 `P -> ( P ) P` の解析が完了したので、スタックからこの規則を取り除きます。解析が完了した `P` が一つ上の規則 `P -> (・P ) P` の `P` に対応します。

```
入力: ) $
スタック: [ D -> $・P $, P -> ( P・) P ]
```

次の入力 `)` とスタックトップの規則の期待する記号 `)` がマッチするので、入力を消費し、ドットを進めます。

```
入力: $
スタック: [ D -> $・P $, P -> ( P )・P ]
```

再び非終端記号 `P` を解析します。次の入力は `$` なので、規則 `P -> ε` を適用します。

```
入力: $
スタック: [ D -> $・P $, P -> ( P ) P・]
```

スタックトップの規則 `P -> ( P ) P` の解析が完了したので、スタックから取り除きます。解析が完了した `P` が一番下の規則 `D -> $・P $` の `P` に対応します。

```
入力: $
スタック: [ D -> $ P・$ ]
```

次の入力 `$` とスタックトップの規則の期待する記号 `$` がマッチするので、入力を消費し、ドットを進めます。

```
入力: (空)
スタック: [ D -> $ P $・]
```

スタックトップの規則 `D -> $ P $` の解析が完了し、入力も終端に達したので、スタックから規則を取り除きます。

```
入力: (空)
スタック: [ ]
```

入力文字列の終端に到達し、スタックが空になったので、入力文字列 `(())` はDyck言語の文法に従っていることがわかりました。

### 解析過程の詳細表

上記の解析過程を表にまとめると、以下のようになります。この表は、各ステップでどのような決定が行われているかを示しています：

| ステップ | 入力ポインタ        | 残り入力     | スタック                                     | アクション                                     |
| -------- | ------------------- | ------------ | -------------------------------------------- | ---------------------------------------------- |
| 1        | **`$`** ` ( ( ) ) $` | ` ( ( ) ) $` | `[ D -> ・$ P $ ]`                           | `$` を消費、`D -> $・P $`                      |
| 2        | `$ `**`(`**` ( ) ) $` | ` ( ) ) $`   | `[ D -> $・P $ ]`                           | `P` を展開、規則 `P -> ・( P ) P` をスタックに追加 |
| 3        | `$ `**`(`**` ( ) ) $` | ` ( ) ) $`   | `[ D -> $・P $, P -> ・( P ) P ]`             | `(` を消費、`P -> (・P ) P`                    |
| 4        | `$ ( `**`(`**` ) ) $` | ` ) ) $`     | `[ D -> $・P $, P -> (・P ) P ]`             | `P` を展開、規則 `P -> ・( P ) P` をスタックに追加 |
| 5        | `$ ( `**`(`**` ) ) $` | ` ) ) $`     | `[ D -> $・P $, P -> (・P ) P, P -> ・( P ) P ]` | `(` を消費、`P -> (・P ) P`                    |
| 6        | `$ ( ( `**`)`**` ) $` | ` ) $`       | `[ D -> $・P $, P -> (・P ) P, P -> (・P ) P ]` | `P` を展開、規則 `P -> ・ε` を選択             |
| 7        | `$ ( ( `**`)`**` ) $` | ` ) $`       | `[ D -> $・P $, P -> (・P ) P, P -> ( P・) P ]` | `ε` を消費（位置変わらず）、`P -> ( P・) P`      |
| 8        | `$ ( ( ) `**`)`**` $` | ` $`         | `[ D -> $・P $, P -> (・P ) P, P -> ( P )・P ]` | `)` を消費、`P -> ( P )・P`                    |
| 9        | `$ ( ( ) `**`)`**` $` | ` $`         | `[ D -> $・P $, P -> (・P ) P, P -> ( P ) P・]` | `P` を展開、規則 `P -> ・ε` を選択             |
| 10       | `$ ( ( ) `**`)`**` $` | ` $`         | `[ D -> $・P $, P -> (・P ) P, P -> ( P ) P・]` | スタックから `P -> ( P ) P・` を除去           |
| 11       | `$ ( ( ) `**`)`**` $` | ` $`         | `[ D -> $・P $, P -> ( P・) P ]`             | `)` を消費、`P -> ( P )・P`                    |
| 12       | `$ ( ( ) ) `**`$`**  |              | `[ D -> $・P $, P -> ( P )・P ]`             | `P` を展開、規則 `P -> ・ε` を選択             |
| 13       | `$ ( ( ) ) `**`$`**  |              | `[ D -> $・P $, P -> ( P ) P・]`             | スタックから `P -> ( P ) P・` を除去           |
| 14       | `$ ( ( ) ) `**`$`**  |              | `[ D -> $ P・$ ]`                           | `$` を消費、`D -> $ P $・`                      |
| 15       | `$ ( ( ) ) $`       | (空)         | `[ D -> $ P $・]`                           | スタックから `D -> $ P $・` を除去             |
| 16       | `$ ( ( ) ) $`       | (空)         | `[ ]`                                        | 受理                                           |

### 予測型下向き構文解析のアルゴリズム

上記の例を通して、予測型下向き構文解析の動作パターンが見えてきたと思います。アルゴリズムをまとめると：

1. **先読み文字の取得**：現在の入力位置から1文字先を見る

2. **非終端記号の展開**：
   - スタックトップが非終端記号の場合、先読み文字に基づいて適用する規則を「予測」
   - 選択した規則をスタックに追加
   - 適切な規則がない場合はエラー

3. **終端記号のマッチング**：
   - スタックトップが終端記号の場合、入力文字と比較
   - 一致すれば入力を消費してドットを進める
   - 一致しなければエラー

4. **規則の完了**：
   - 規則の最後まで進んだら、スタックからその規則を除去
   - 一つ上の規則の解析を続行

5. **受理判定**：
   - 入力がすべて消費され、スタックが空になれば受理
   - それ以外は拒否

## 5.3 下向き構文解析法のJavaによる実装

スタックを使った下向き構文解析の動作を理解したところで、これをJavaで実装してみましょう。実は、多くの場合、スタックを明示的に使わずに**再帰呼び出し**を使って実装できます。これが「再帰下降構文觢析」と呼ばれる理由です。

### 再帰下降構文解析の実装

```java
// D -> P
// P -> ( P ) P
// P -> ε
public class Dyck {
    private final String input;
    private int position;

    public Dyck(String input) { // コンストラクタ名を修正
        this.input = input;
        this.position = 0;
    }

    public boolean parse() {
        boolean result = D();
        return result && position == input.length();
    }

    private boolean D() {
        return P();
    }

    private boolean P() {
        // P -> ( P ) P
        if (position < input.length() && input.charAt(position) == '(') {
            position++; // '(' を読み進める
            if (!P()) return false;
            if (position < input.length() && input.charAt(position) == ')') {
                position++; // ')' を読み進める
                return P();
            } else {
                return false;
            }
        // P -> ε
        } else {
            // 空文字列にマッチ
            return true;
        }
    }
}
```

### コードの解説

この実装では、各非終端記号に対応するメソッドを作成しています：

1. **`D()`メソッド**：文法の開始記号`D`に対応
   - 規則 `D -> P` をそのまま実装：`P()`を呼び出すだけ

2. **`P()`メソッド**：非終端記号`P`に対応
   - 最初に `P -> ( P ) P` を試す：先読み文字が`(`か確認
   - 適用できない場合は `P -> ε` を適用：常に`true`を返す

3. **文字の消費**：`position`をインクリメントすることで実現

4. **バックトラックのない予測型**：一度選択した規則で失敗したら、即座に`false`を返す

### 文法規則とコードの対応関係

BNF規則とJavaコードの対応を見てみましょう：

```
文法規則： D -> P
Javaコード： private boolean D() { return P(); }

文法規則： P -> ( P ) P | ε  
Javaコード： private boolean P() {
    if (先読み文字 == '(') {
        // P -> ( P ) P を適用
    } else {
        // P -> ε を適用
    }
}
```

このように：
- 各非終端記号にメソッドが対応
- 非終端記号の参照はメソッド呼び出しに変換
- 選択はif文で実現
- 連接は順次実行で実現

### 「再帰下降」という名前の由来

この実装方法が「再帰下降」と呼ばれる理由は：

1. **再帰**：メソッドが自分自身または他のメソッドを呼び出す
2. **下降**：文法の開始記号から「下」の規則へと解析が進む

実際に`parse("(())")`を実行すると、以下のような呼び出しの連鎖が発生します：

```
parse() -> D() -> P() -> P() -> P() -> ...
```

この呼び出しスタックが、先ほどスタックで説明した解析状態と対応しているのです。

### 下向き構文解析のバリエーション

下向き構文解析には、再帰下降以外にも実装方法があります：

- **表駆動型**：LL(1)などでは、構文解析表を作成し、明示的なスタックで解析
- **バックトラック型**：PEGのように、失敗時に別の選択肢を試す

しかし、基本的な考え方は同じで、「文法の開始記号から入力文字列に向かって解析を進める」という点で一致しています。

## 5.4 上向き構文解析の概要

さて、下向き構文解析を理解したところで、次は**上向き構文解析**を見ていきましょう。こちらは下向きとは全く逆のアプローチを取ります。

### シフト還元構文解析の基本アイデア

上向き構文解析は、**シフト還元構文觢析**とも呼ばれます。この名前は、2つの基本操作から来ています：

1. **シフト（Shift）**：入力から1文字読み込んでスタックに積む
2. **還元（Reduce）**：スタック上の記号列が某規則の右辺と一致したら、左辺に置き換える

下向き構文解析が「文法から入力へ」と進むのに対し、上向き構文解析は「入力から文法へ」と進みます。つまり、入力文字列を徰々に「縮めて」いって、最終的に開始記号に辿り着けるかを確認するのです。

### 例で学ぶシフト還元構文解析

同じDyck言語を例にしますが、上向き構文解析では空文字列規則（ε規則）が扱いづらいので、等価な別の文法を使います：

```
D -> $ P $
D -> $ ε $
P -> P X
P -> X
X -> ( X )
X -> ()
```

この文法の特徴は：
- `X`は内側の括弧ペアを表す
- `P`は括弧ペアの列を表す
- `D`は全体を表す

では、入力文字列 `(())` に対してシフト還元構文解析を行ってみましょう。

**ステップ1**：開始記号`$`をシフト

```
スタック: [ $, ( ]
```

**ステップ2**：最初の`(`をシフト

この時点では、どの規則の右辺とも一致しません。続けてシフトします。

```
スタック: [ $, (, ( ]
```

**ステップ3、4**：さらに`(`と`)`をシフト

```
スタック: [ $, (, (, ) ]
```

ここで重要な瞬間です！スタックの末尾`(, )`が規則`X -> ()`の右辺と一致しました。この2つの記号を`X`に「還元」します：

```
スタック: [ $, (, X ]
```

**ステップ5**：次の`)`をシフト

```
スタック: [ $, (, X, ) ]
```

再び重要な瞬間です。スタックの末尾`(, X, )`が規則`X -> ( X )`の右辺と一致しました。還元します：

```
スタック: [ $, X ]
```

**ステップ6**：`P -> X`で還元

スタックの末尾`X`が規則`P -> X`の右辺と一致します。還元します：

```
スタック: [ $, P ]
```

**ステップ7**：終端記号`$`をシフト

```
スタック: [ $, P, $ ]
```

**ステップ8**：最後の還元

スタック全体`$, P, $`が規則`D -> $ P $`の右辺と一致します。還元します：

```
スタック: [ D ]
```

スタックが開始記号`D`だけになりました。これで入力文字列`(())`が文法に従っていることが確認できました。

### シフト還元構文解析の詳細表

上記の過程を表にまとめると以下のようになります：

| ステップ | 入力ポインタ        | 残り入力     | スタック          | アクション                               |
| -------- | ------------------- | ------------ | ----------------- | ---------------------------------------- |
| 1        | **`$`** ` ( ( ) ) $` | ` ( ( ) ) $` | `[ ]`             | shift `$`                                |
| 2        | `$ `**`(`**` ( ) ) $` | ` ( ) ) $`   | `[ $ ]`           | shift `(`                                |
| 3        | `$ ( `**`(`**` ) ) $` | ` ) ) $`     | `[ $, ( ]`        | shift `(`                                |
| 4        | `$ ( ( `**`)`**` ) $` | ` ) $`       | `[ $, (, ( ]`    | shift `)`                                |
| 5        | `$ ( ( ) `**`)`**` $` | ` $`         | `[ $, (, (, ) ]` | reduce by `X -> ()` (スタックは `[ $, (, X ]`) |
| 6        | `$ ( ( ) `**`)`**` $` | ` $`         | `[ $, (, X ]`    | shift `)`                                |
| 7        | `$ ( ( ) ) `**`$`**  |              | `[ $, (, X, ) ]` | reduce by `X -> ( X )` (スタックは `[ $, X ]`) |
| 8        | `$ ( ( ) ) `**`$`**  |              | `[ $, X ]`        | reduce by `P -> X` (スタックは `[ $, P ]`)   |
| 9        | `$ ( ( ) ) `**`$`**  |              | `[ $, P ]`        | shift `$`                                |
| 10       | `$ ( ( ) ) $`       | (空)         | `[ $, P, $ ]`     | reduce by `D -> $ P $` (スタックは `[ D ]`)  |
| 11       | `$ ( ( ) ) $`       | (空)         | `[ D ]`           | 受理                                     |

### シフト還元構文解析のアルゴリズム

上記の例から、シフト還元構文解析の動作パターンが見えてきました。アルゴリズムをまとめると：

1. **シフト操作**：
   - 入力から1文字読み込んでスタックに積む
   - 常に左から右へ順番に読む

2. **還元操作**：
   - スタック上端の記号列が、ある規則の右辺と一致したら
   - その記号列を取り除いて、規則の左辺の非終端記号を積む

3. **アクションの選択**：
   - シフトと還元のどちらを行うかを決定する必要がある
   - この決定方法がLR(0)、SLR(1)、LR(1)などの違いになる

4. **受理判定**：
   - 入力をすべて読み、スタックが開始記号だけになれば受理
   - それ以外は拒否

### 下向きと上向きの違い

ここまでの例からわかるように：

- **下向き**：`D`から始めて`(())`を「生成」しようとする
- **上向き**：`(())`から始めて`D`に「還元」しようとする

上向き構文解析の還元操作は、第4章で学んだ「最右導出」の逆操作に相当します。つまり、導出の過程を逆再生しているのです。

## 5.5 上向き構文解析のJavaによる実装

シフト還元構文解析をJavaで実装してみましょう。下向き構文解析とは異なり、明示的にスタックを使い、規則をデータ構造として扱います。

### 必要なデータ構造

まず、記号（終端記号・非終端記号）を表すクラスと、文法規則を表すクラスが必要です：

```java
// 記号を表すインターフェース
interface Element {
    char value();
}

// 終端記号
record Terminal(char value) implements Element {}

// 非終端記号
record NonTerminal(char value) implements Element {}
```

次に、文法規則を表す`Rule`クラスを定義します：

```java
import java.util.List;
import java.util.ArrayList;

public record Rule(char lhs, List<Element> rhs) {
    // 可変長引数コンストラクタ（便利のため）
    public Rule(char lhs, Element... rhs) {
        this(lhs, List.of(rhs));
    }
    
    // スタックの上端がこの規則の右辺と一致するか判定
    public boolean matches(List<Element> stack) {
        if (stack.size() < rhs.size()) return false;
        
        // スタックの上からrhs.size()個の要素を比較
        for (int i = 0; i < rhs.size(); i++) {
            Element elementInRule = rhs.get(i);
            Element elementInStack = stack.get(stack.size() - rhs.size() + i);
            if (!elementInRule.equals(elementInStack)) {
                return false;
            }
        }
        return true;
    }
}
```

### シフト還元構文解析器の実装

上記のデータ構造を使って、実際のシフト還元構文解析器を実装します：

```java
import java.util.List;
import java.util.ArrayList;

public class DyckShiftReduce {
    private final String input;
    private int position;
    private final List<Rule> rules;
    private final List<Element> stack = new ArrayList<>();

    public DyckShiftReduce(String input) {
        this.input = input;
        this.position = 0;
        
        // 文法規則の定義
        this.rules = List.of(
            // D -> $ P $
            new Rule('D', 
                new Terminal('$'), 
                new NonTerminal('P'), 
                new Terminal('$')
            ),
            // D -> $ $ (空文字列の場合)
            new Rule('D', 
                new Terminal('$'), 
                new Terminal('$')
            ),
            // P -> P X
            new Rule('P', 
                new NonTerminal('P'), 
                new NonTerminal('X')
            ),
            // P -> X
            new Rule('P', 
                new NonTerminal('X')
            ),
            // X -> ( X )
            new Rule('X', 
                new Terminal('('), 
                new NonTerminal('X'), 
                new Terminal(')')
            ),
            // X -> ()
            new Rule('X', 
                new Terminal('('), 
                new Terminal(')')
            )
        );
    }

    public boolean parse() {
        // 開始記号$をスタックに積む
        stack.add(new Terminal('$'));
        
        // メインループ：シフトと還元を繰り返す
        while (true) {
            // まず還元を試みる
            if (!tryReduce()) {
                // 還元できない場合、シフトを試みる
                if (position < input.length()) {
                    char c = input.charAt(position);
                    stack.add(new Terminal(c));
                    position++;
                } else {
                    // シフトもできないので終了
                    break;
                }
            }
        }
        
        // 終端記号$をスタックに積む
        stack.add(new Terminal('$'));
        
        // 最後に可能な限り還元を繰り返す
        while (tryReduce()) {
            // 還元ができなくなるまで続ける
        }
        
        // スタックが[D]のみになったら受理
        return stack.size() == 1 && 
               stack.get(0).equals(new NonTerminal('D'));
    }

    private boolean tryReduce() {
        for (Rule rule : rules) {
            if (rule.matches(stack)) {
                // マッチしたら右辺の長さ分スタックから削除
                for (int i = 0; i < rule.rhs().size(); i++) {
                    stack.remove(stack.size() - 1);
                }
                // 左辺の非終端記号をスタックに追加
                stack.add(new Element.NonTerminal(rule.lhs()));
                return true; // 還元成功
            }
        }
        return false; // 還元できる規則がなかった
    }
}
```

### 実装のポイント

この実装の重要な点は：

1. **シフトより還元を優先**：まず`tryReduce()`で還元を試み、できない場合のみシフト
2. **単純な還元ルール**：すべての規則を順番にチェックし、最初にマッチしたものを使う
3. **明示的なスタック操作**：`List<Element>`をスタックとして使い、要素の追加・削除を明示的に行う

この実装は最も単純なシフト還元構文解析で、実用的なパーサではさらに洗練されたアルゴリズム（LR(0)、SLR(1)、LR(1)、LALR(1)）が使われます。

## 5.6 下向き構文解析と上向き構文解析の比較

ここまで下向き構文解析と上向き構文解析の具体例を見てきました。両者にはそれぞれ得意不得意があります。

### 下向き構文解析の利点

1. **直感的な実装**
   - 文法規則とメソッドが1対1に対応
   - 手書きの構文解析器が書きやすい
   - 実際、多くのプログラミング言語のコンパイラが手書き再帰下降を採用

2. **文脈依存の扱いやすさ**
   - メソッドの引数で情報を渡せる
   - 解析中に状態を管理しやすい
   - エラー回復やエラーメッセージの生成が容易

3. **デバッグのしやすさ**
   - 通常の関数呼び出しなのでデバッガで追える
   - 構文解析の過程が理解しやすい

### 下向き構文解析の欠点

1. **左再帰の問題**

たとえば、以下のBNFは上向き型だと普通に解析できますが、工夫なしに下向き型で実装すると無限再帰に陥ってスタックオーバーフローします。

```
A -> A "a" | ε // 左再帰を含む文法の例 (εは空文字列)
```

このような問題を下向き型で解決する方法も存在します。
例えば、直接左再帰 `A -> A α | β` （ここで `β` は `A` で始まらない）は、以下のように等価な右再帰の文法に書き換えることで除去できます。

```
A  -> β A'
A' -> α A' | ε
```
この変換により、下向き構文解析で問題となる無限再帰を避けることができます。ただし、文法の書き換えは常に簡単とは限りません。

さて、上向き型は左再帰を問題なく処理できるので、このような文法をそのまま解析できるわけです、では上向き型はすべての文法に対して有利なのでしょうか？ことはそう単純ではありません。

たとえば、それまでの文脈に応じて構文解析のルールを切り替えたくなることがあります。最近の言語によく搭載されている文字列補間などはその最たる例です。

`"`の中は文字列リテラルとして特別扱いされますが、その中で`#{`が出てきたら（Rubyの場合）、通常の式を構文解析するときのルールに戻る必要があります。

このように、文脈に応じて適用するルールを切り替えるのは下向き型が得意です。もちろん、上向き型でも実現できないわけではありません。実際、Rubyの構文解析機はYaccの定義ファイルから生成されるようになっていますが、Yaccが採用しているのは代表的な上向き構文解析法である`LALR(1)`です。

ともあれ、下向きと上向きには異なる利点と欠点があります。

次からは具体的なアルゴリズムの説明に移ります。

## 5.7 LL(1) - 代表的な下向き構文解析アルゴリズム

ここからは、具体的な構文解析アルゴリズムについて詳しく見ていきましょう。まずは下向き構文解析の代表格である**LL(1)**から始めます。

### LL(1)とは？

**LL(1)**という名前は以下の意味を持ちます：

- **最初のL**：**L**eft-to-right（左から右へ入力を読む）
- **2番目のL**：**L**eftmost derivation（最左導出を行う）
- **(1)**：1トークン先読み

つまり、「1トークン先を見て、次に適用すべき規則を一意に決定できる」という制約を持つ下向き構文解析法です。

### LL(1)の直感的な理解

身近な例で考えてみましょう。Javaのif文の解析を例にします：

```java
if(age < 18) {
    System.out.println("18歳未満です");
} else {
    System.out.println("18歳以上です");
}
```

プログラマがこのコードを見たとき、「`if`というキーワードがあるからif文だ」と即座に判断します。LL(1)は、まさにこの「最初の1トークンで判断」というアイデアをアルゴリズム化したものです。

しかし、実際にLL(1)を実現するには、いくつかの課題を解決する必要があります。

### 課題1：複数のトークンで始まる構文

if文の例はシンプルでした。`if`というキーワードで必ず始まるからです。しかし、すべての構文がこのように単純ではありません。

算術式を考えてみましょう。以下の文法を持つとします：

```
Expr -> Term (('+' | '-') Term)*
Term -> Factor (('*' | '/') Factor)*
Factor -> '(' Expr ')' | Number | '-' Factor | '+' Factor
Number -> [0-9]+
```

算術式は以下のいずれかで始まります。

- `(`
- `-`
- `+`
- 整数リテラル（`<int_literal>`）

つまり、算術式の始まりは複数のトークンで表されます。このような場合、最初のトークンとの一致比較だけでは「これは算術式だ」と確定できません。

この場合、`Expr`（算術式全体）が始まる可能性のあるトークンを考えると：

- `(`：括弧付き式 `(Expr)` から
- `-`：負数 `-Factor` から
- `+`：正数 `+Factor` から  
- 数字：`Number` から

### FIRST集合の導入

このように、ある非終端記号から導出される文字列の「最初に現れうるトークンの集合」を**FIRST集合**と呼びます。

正式には、非終端記号`A`に対して：
```
FIRST(A) = { a | A ⇒* aβ であるような終端記号 a }
```

上記の算術式の例では：
```
FIRST(Expr) = { '(', '-', '+', 数字 }
FIRST(Factor) = { '(', '-', '+', 数字 }
FIRST(Number) = { 数字 }
```

### FIRST集合とLL(1)の条件

ある非終端記号`A`に複数の規則がある場合：

```
A -> B
A -> C
```

`FIRST(B)`と`FIRST(C)`が重ならなければ（交差が空集合）、1トークン先読みでどちらの規則を選ぶか決定できます。

```
FIRST(B) ∩ FIRST(C) = ∅  ← LL(1)の条件
```

これがLL(1)文法の基本条件です。バックトラックしない予測型構文解析では、「間違ったからやり直し」ができないので、最初から正しい選択をする必要があるのです。

### LL(1)の実装例

具体的なJavaの実装を見てみましょう：

```java
// 算術式の再帰下降構文解析器
private Expression parseExpression() {
    Expression left = parseTerm();
    
    while (true) {
        Token next = peekToken();  // 1トークン先読み
        
        if (next.type == TokenType.PLUS) {
            consumeToken();
            Expression right = parseTerm();
            left = new BinaryExpression(left, "+", right);
        } else if (next.type == TokenType.MINUS) {
            consumeToken();
            Expression right = parseTerm();
            left = new BinaryExpression(left, "-", right);
        } else {
            break;  // +や-以外なら終了
        }
    }
    
    return left;
}
```

このコードでは、`peekToken()`で1トークン先読みし、その結果に応じて処理を分岐しています。

### 課題2：空文字列規則の扱い

さらに複雑な問題を考えてみましょう。Javaのif文には2種類あります：

1. **単純なif文**：else節がない

```java
if (age < 18) {
    System.out.println("18歳未満です");
}
```

2. **if-else文**：else節がある

```java
if (age < 18) {
    System.out.println("18歳未満です");
} else {
    System.out.println("18歳以上です");
}
```

文法で表すと：

```
IfStatement -> 'if' '(' Expression ')' Statement ElsePart
ElsePart -> 'else' Statement | ε
```

ここで`ElsePart`は「あるかもしれないし、ないかもしれない」要素です。`}`の後に`else`が来るかどうかで判断しますが、この判断にはFIRST集合だけでは不十分です。

### nullableとFOLLOW集合

空文字列規則を扱うために、2つの概念が必要になります：

1. **nullable**：非終端記号が空文字列を生成できるか
2. **FOLLOW集合**：非終端記号の後に現れうるトークンの集合

例えば：

```
A -> a
A -> b
A -> ε
```

`A`は空文字列`ε`を生成可能なので、`nullable(A) = true`です。

上記のif文の例では：
- `nullable(ElsePart) = true`（else節は省略可能）
- `FOLLOW(ElsePart)`には、if文の後に来うるものが含まれる

`ElsePart`が`ε`を選ぶべきかどうかは、次のトークンが`else`か、それとも`FOLLOW(ElsePart)`に含まれるトークンかで判断します。

### FIRST集合とFOLLOW集合の計算

LL(1)構文解析を実装するには、FIRST集合とFOLLOW集合を実際に計算するアルゴリズムが必要です。

#### FIRST集合の計算アルゴリズム

非終端記号`A`に対するFIRST集合を計算する手順：

```
A -> α1
A -> α2
...
A -> αn
```

各規則 `A -> α_i` について：

1. `α_i = X_1 X_2 ... X_n` とする
2. `X_1`が終端記号なら、`FIRST(A)`に`X_1`を追加
3. `X_1`が非終端記号なら：
   - `FIRST(X_1) - {ε}`を`FIRST(A)`に追加
   - `X_1`がnullableなら`X_2`も確認（以下同様）
4. すべての`X_i`がnullableなら、`ε`を`FIRST(A)`に追加

**具体例**：
```
E -> T E'
E' -> + T E' | ε
T -> F T'
T' -> * F T' | ε
F -> ( E ) | id
```

この場合：
- `FIRST(F) = { '(', id }`
- `FIRST(T) = FIRST(F) = { '(', id }`
- `FIRST(E) = FIRST(T) = { '(', id }`
- `FIRST(E') = { '+', ε }`
- `FIRST(T') = { '*', ε }`

#### nullableの計算

`nullable`は非終端記号が空文字列を生成できるかを示すブール値です。

**計算手順**：
1. すべての非終端記号について`nullable = false`に初期化
2. `A -> ε`の形の規則があれば`nullable(A) = true`
3. `A -> X_1 X_2 ... X_k`について、すべての`X_i`がnullableなら`nullable(A) = true`
4. 変化がなくなるまで繰り返す

上記の例では：
- `nullable(E') = true`（`E' -> ε`があるため）
- `nullable(T') = true`（`T' -> ε`があるため）
- `nullable(E) = false`、`nullable(T) = false`、`nullable(F) = false`

#### FOLLOW集合の計算アルゴリズム  

FOLLOW集合は、非終端記号の後に現れうる終端記号の集合です。

**計算手順**：
1. すべての非終端記号の`FOLLOW`を空集合に初期化
2. 開始記号`S`に対して`FOLLOW(S) = {$}`（入力終端）
3. 規則`B -> αAβ`に対して：
   - `FIRST(β) - {ε}`を`FOLLOW(A)`に追加
   - `β`がnullableなら`FOLLOW(B)`を`FOLLOW(A)`に追加
4. 規則`B -> αA`（末尾に`A`）に対して：
   - `FOLLOW(B)`を`FOLLOW(A)`に追加
5. 変化がなくなるまで繰り返す

上記の例では：
- `FOLLOW(E) = { ')', $ }`
- `FOLLOW(E') = { ')', $ }`（`E -> T E'`から）
- `FOLLOW(T) = { '+', ')', $ }`
- `FOLLOW(T') = { '+', ')', $ }`
- `FOLLOW(F) = { '*', '+', ')', $ }`

これらのFIRST集合とFOLLOW集合を使って、LL(1)構文解析表を作成します。

### LL(1)構文解析表の作成

LL(1)構文解析表は、「非終端記号」と「先読みトークン」の組み合わせから、適用すべき規則を決定する表です。

**作成手順**：

各規則`A -> α`について：

1. `FIRST(α)`に含まれる各終端記号`a`（`ε`を除く）に対して：
   - `Table[A, a] = A -> α`

2. `ε ∈ FIRST(α)`の場合（`α`がnullable）：
   - `FOLLOW(A)`の各終端記号`b`に対して
   - `Table[A, b] = A -> α`

**例：上記の文法の解析表**

|        | id  | +   | *   | (   | )   | $   |
|--------|-----|-----|-----|-----|-----|-----|
| E      | E->TE' |     |     | E->TE' |     |     |
| E'     |     | E'->+TE' |     |     | E'->ε | E'->ε |
| T      | T->FT' |     |     | T->FT' |     |     |
| T'     |     | T'->ε | T'->*FT' |     | T'->ε | T'->ε |
| F      | F->id |     |     | F->(E) |     |     |

もし同じセルに複数の規則が入る場合、その文法はLL(1)ではありません。

### LL(1)の問題点と限界

LL(1)はシンプルで実用的ですが、いくつかの限界があります。

### 問題点1：共通前置辞問題

例えば、以下の文法を考えてみましょう。

```
S -> a B
S -> a C
B -> b
C -> c
```

この文法では、`S`の両方の規則が`a`で始まります。つまり：
- `FIRST(a B) = {a}`
- `FIRST(a C) = {a}`
- `FIRST(a B) ∩ FIRST(a C) = {a} ≠ ∅`

これはLL(1)の条件に反します。この問題は**左因子化**（left factoring）で解決できます：

```
S  -> a S'
S' -> B
S' -> C
B  -> b
C  -> c
```

この変換により、`a`を読んだ後、`b`か`c`かを見て判断できるようになります。

### 問題点2：左再帰の問題

LL(1)の最大の欠点は、**左再帰**を扱えないことです。

```
E -> E + T
E -> T
```

これは算術式の自然な表現ですが、`E`の定義の最初に`E`自身が出現しています（**直接左再帰**）。

再帰下降で実装すると：
```java
private Expression parseE() {
    return parseE() + parseT();  // 無限再帰！
}
```

この問題は**左再帰の除去**で解決できます：

```
E  -> T E'
E' -> + T E'
E' -> ε
```

しかし、この変換により文法の直感性が失われ、ASTの構築も複雑になります。これがLR系の構文解析が好まれる理由の一つです。

## 5.8 LL(k) - LL(1)の拡張

LL(1)の限界を克服する方法の一つが、先読みトークン数を増やすことです。**LL(k)**は`k`トークン先読みする下向き構文解析法です。

例えば、以下の文法はLL(1)ではないが、LL(2)です：

```
S -> a a B
S -> a a C
B -> b
C -> c
```

2トークン先読みすれば、`aa`の後に`b`が来るか`c`が来るかで判断できます。

しかし、LL(k)にも限界があります：
- 解析表のサイズが`O(n × t^k)`になる（n:非終端記号数、t:終端記号数）
- 左再帰の問題は解決しない
- すべての文脈自由言語を扱えない

## 5.9 LR(0) - 最も単純な上向き構文解析

ここからは上向き構文解析のLR系のアルゴリズムを見ていきます。LRの名前は：
- **L**：Left-to-right（左から右へ入力を読む）
- **R**：Rightmost derivation（最右導出の逆をたどる）

### LR系の発展

LR系のアルゴリズムは、以下のように発展してきました：

1. **LR(0)**：最も基本的だが、多くの文法でコンフリクトが発生
2. **SLR(1)**：FOLLOW集合を使ってコンフリクトを減らす
3. **LR(1)**：先読み情報を項目に含めて精度を上げる
4. **LALR(1)**：LR(1)の状態をマージして実用的に

まずは最も基本的なLR(0)から始めましょう。

### LR(0)の基本アイデア

LR(0)はシフト還元構文解析を**オートマトン**で実現したものです。各状態で「シフトするか」「還元するか」を決定します。

### LR(0)項目と項目集合（状態）

**LR(0)項目**とは、文法規則の右辺の任意の位置にドット（・）を挿入したものです。ドットは、その規則の右辺のどこまでを認識したかを示すマーカーの役割を果たします。

例えば、`E -> E + T` という規則からは、以下の4つのLR(0)項目が生成されます。

- `E -> ・E + T` : まだ何も認識していない状態
- `E -> E・+ T` : `E` を認識し、次に `+` を期待する状態
- `E -> E +・T` : `E +` を認識し、次に `T` を期待する状態
- `E -> E + T・` : `E + T` をすべて認識し、還元可能な状態

LR(0)構文解析では、これらのLR(0)項目の**集合**を**状態**として扱います。構文解析器は、入力を読み進めながら、これらの状態間を遷移していきます。

### 閉包（Closure）とGOTO関数

状態（LR(0)項目集合）を構築するためには、**閉包（Closure）**と**GOTO関数**という二つの操作が必要です。

#### 閉包（Closure）

ある状態（項目集合）`I` の閉包 `closure(I)` は、その状態から遷移せずに認識できる可能性のあるすべての項目を含む集合です。具体的には、以下の手順で計算します。

1.  `closure(I)` を `I` で初期化する。
2.  `closure(I)` 内の項目 `[A -> α・Bβ]` （`B`は非終端記号）について、`B` から始まるすべての規則 `B -> γ` に対して、項目 `[B -> ・γ]` を `closure(I)` に追加する。
3.  新しい項目が追加されなくなるまで、ステップ2を繰り返す。

閉包操作により、ある状態において次に非終端記号 `B` が期待される場合、`B` を導出するために必要なすべての規則の初期状態（ドットが左端にある項目）がその状態に含まれることになります。

#### GOTO関数

GOTO関数 `goto(I, X)` は、状態 `I` において記号 `X` （終端記号または非終端記号）を読み込んだときに遷移する先の状態を計算します。

1.  状態 `I` 内のすべての項目 `[A -> α・Xβ]` について、ドットを一つ右に移動させた項目 `[A -> αX・β]` を集める。
2.  これらの新しい項目の集合に対して閉包操作を行い、結果を `goto(I, X)` とする。

### LR(0)状態機械の構築

文法からLR(0)構文解析器の状態機械（オートマトン）を構築する手順は以下の通りです。

1.  **文法の拡張**: 元の文法の開始記号を `S` とすると、新しい開始記号 `S'` と規則 `S' -> S` を追加します。これは、解析の終了（受理）を明確にするためです。
2.  **初期状態の作成**: 拡張された文法の初期項目 `[S' -> ・S]` を含む閉包 `closure({[S' -> ・S]})` を計算し、これを初期状態 `I0` とします。
3.  **状態の構築**:
    *   既に構築された状態 `I` と、文法中の各記号 `X` について `goto(I, X)` を計算します。
    *   `goto(I, X)` が空でなく、まだ状態として登録されていない新しい項目集合であれば、それを新しい状態として登録します。
    *   すべての状態からすべての記号に対するGOTO関数を計算し尽くすまで、このプロセスを繰り返します。

これにより、LR(0)項目の集合をノードとし、GOTO関数をエッジとする状態遷移図（LR(0)オートマトン）が構築されます。

### LR(0)構文解析表の作成

構築した状態機械（各状態 `Ii` と GOTO関数）から、構文解析表（ACTION表とGOTO表）を作成します。

1.  **ACTION表**:
    *   **シフト**: `goto(Ii, a) = Ij` （`a` は終端記号）の場合、`ACTION[i, a] = "shift j"` とします。これは、状態 `i` で終端記号 `a` を読み込んだら、スタックに `a` と状態 `j` をプッシュ（シフト）することを示します。
    *   **還元**: 状態 `Ii` に項目 `[A -> α・]` （`A ≠ S'`）が含まれる場合、**すべての**終端記号 `a` に対して `ACTION[i, a] = "reduce A -> α"` とします。これは、状態 `i` に到達し、規則 `A -> α` の右辺をすべて認識したので、スタックから `α` に対応する要素を取り除き、`A` をプッシュ（還元）することを示します。
    *   **受理**: 状態 `Ii` に項目 `[S' -> S・]` が含まれる場合、`ACTION[i, $]` （`$` は入力終了記号）に `"accept"` を設定します。
2.  **GOTO表**:
    *   `goto(Ii, A) = Ij` （`A` は非終端記号）の場合、`GOTO[i, A] = j` とします。これは、還元によって非終端記号 `A` がスタックにプッシュされた後、次に遷移すべき状態が `j` であることを示します。

### LR(0)の限界：コンフリクト

LR(0)構文解析表を作成する際、ACTION表の同じマスに複数のアクションが書き込まれることがあります。これを**コンフリクト**と呼び、LR(0)法では解析できない文法であることを示します。

-   **シフト/還元コンフリクト (Shift/Reduce Conflict)**: 同じマスに `shift` アクションと `reduce` アクションが入る場合。入力記号をシフトして解析を続けるべきか、規則を還元すべきか決定できません。
-   **還元/還元コンフリクト (Reduce/Reduce Conflict)**: 同じマスに複数の `reduce` アクションが入る場合。どの規則で還元すべきか決定できません。

LR(0)法は、還元を決定する際に次に入力される記号（先読み記号）を全く考慮しないため、多くの実用的な文法でコンフリクトが発生します。

### 具体例：LR(0)状態機械と解析表の構築

簡単な文法を使って、LR(0)の状態機械と解析表を構築してみましょう。

**文法 G1:**

```
(0) S' -> E
(1) E -> E + T
(2) E -> T
(3) T -> id
```

**LR(0)項目集合（状態）:**

-   **I0**: `closure({[S' -> ・E]})` = `{ [S' -> ・E], [E -> ・E + T], [E -> ・T], [T -> ・id] }`
-   **I1**: `goto(I0, E)` = `closure({[S' -> E・], [E -> E・+ T]})` = `{ [S' -> E・], [E -> E・+ T] }`
-   **I2**: `goto(I0, T)` = `closure({[E -> T・]})` = `{ [E -> T・] }`
-   **I3**: `goto(I0, id)` = `closure({[T -> id・]})` = `{ [T -> id・] }`
-   **I4**: `goto(I1, +)` = `closure({[E -> E + ・T]})` = `{ [E -> E + ・T], [T -> ・id] }`
-   **I5**: `goto(I4, T)` = `closure({[E -> E + T・]})` = `{ [E -> E + T・] }`
-   **I6**: `goto(I4, id)` = `closure({[T -> id・]})` = `{ [T -> id・] }` ( = I3 )

**構文解析表:**

| 状態 | ACTION        |       |      | GOTO |   |
| :--- | :------------ | :---- | :--- | :--- | :- |
|      | **id**        | **+** | **$** | **E** | **T** |
| **0** | s3            |       |      | 1    | 2  |
| **1** |               | s4    | acc  |      |    |
| **2** | r2            | r2    | r2   |      |    |  <-- 状態2 (`[E -> T・]`) で `+` が来ると `shift 4` (I1から+) と `reduce E->T` でS/Rコンフリクト
| **3** | r3            | r3    | r3   |      |    |  <-- 状態3 (`[T -> id・]`) は還元のみ
| **4** | s6            |       |      |      | 5  |
| **5** | r1            | r1    | r1   |      |    |  <-- 状態5 (`[E -> E + T・]`) は還元のみ
| **6** | r3            | r3    | r3   |      |    |  <-- 状態6 (`[T -> id・]`) は還元のみ (I3と同じ)

（`si` は shift i, `rj` は reduce j (規則jを使用), `acc` は accept）

この表を見ると、状態2において、項目 `[E -> T・]` が存在するため、LR(0)の規則では終端記号 `id`, `+`, `$` のいずれに対しても `reduce E -> T` (r2) を行います。しかし、もし状態1から `+` を読み込んで状態4 (`I4: E -> E + ・T ...`) に遷移するパスがある場合、状態2で `+` が入力されたときに `shift` すべきか `reduce` すべきか判断できません（シフト/還元コンフリクト）。この例では、`I1` から `+` で `I4` に遷移するため、状態2で `+` が来た場合に `reduce E->T` を行うか、あるいは別の解釈（例えば `E+T` の一部として `T` の後に `+` が続くケースを先読みしてシフトを優先するなど）をするかでコンフリクトが生じます。LR(0)では先読みを行わないため、この種のコンフリクトを解決できません。

このように、LR(0)は非常に単純ですが、扱える文法のクラスは限定的です。このコンフリクトを解消するために、次に説明するSLR(1)法では**FOLLOW集合**という先読み情報を利用します。

## 5.10 SLR(1) - FOLLOW集合でコンフリクト解消を試みる

**SLR(1)**（Simple LR(1)）法は、LR(0)法のコンフリクトを解消するために、**FOLLOW集合**という先読み情報を導入する手法です。LR(0)では、還元アクション `reduce A -> α` を決定する際、次の入力記号に関わらず、項目 `[A -> α・]` を含む状態では常に還元を試みていました。これがコンフリクトの主な原因でした。

SLR(1)では、還元 `reduce A -> α` を行う条件をより限定します。具体的には、状態 `Ii` に項目 `[A -> α・]` が含まれていても、次の入力記号 `a` が **`FOLLOW(A)`** （非終端記号 `A` の後に現れうる終端記号の集合）に含まれている場合にのみ、還元アクション `ACTION[i, a] = "reduce A -> α"` を設定します。

### FOLLOW集合の計算

FOLLOW集合の計算方法は、5.7節のLL(1)で説明したものと同じです。簡単に復習しましょう。

1.  すべての非終端記号 `A` について `FOLLOW(A)` を空集合で初期化する。
2.  開始記号 `S'` の `FOLLOW(S')` に入力終了記号 `$` を追加する。
3.  文法中の各規則 `B -> αAβ` について、
    *   `FIRST(β)` に含まれる `ε` 以外のすべての終端記号を `FOLLOW(A)` に追加する。
    *   もし `β` が `ε` を導出可能（`nullable(β)` が真）ならば、`FOLLOW(B)` のすべての記号を `FOLLOW(A)` に追加する。
4.  新しい記号が追加されなくなるまで、ステップ3を繰り返す。

### SLR(1)構文解析表の作成

SLR(1)の構文解析表の作成手順は、LR(0)とほとんど同じですが、**還元アクションの決定方法**だけが異なります。

1.  **文法の拡張**: LR(0)と同様。
2.  **LR(0)項目集合（状態）の構築**: LR(0)と同様に、閉包とGOTO関数を用いて状態機械を構築します。
3.  **FOLLOW集合の計算**: 上記の手順で、すべての非終端記号のFOLLOW集合を計算します。
4.  **構文解析表の作成**:
    *   **ACTION表**:
        *   **シフト**: `goto(Ii, a) = Ij` （`a` は終端記号）の場合、`ACTION[i, a] = "shift j"`。 (LR(0)と同じ)
        *   **還元**: 状態 `Ii` に項目 `[A -> α・]` （`A ≠ S'`）が含まれる場合、**`FOLLOW(A)` に含まれる各終端記号 `a` に対してのみ**、`ACTION[i, a] = "reduce A -> α"` を設定します。 (ここがLR(0)と異なる！)
        *   **受理**: 状態 `Ii` に項目 `[S' -> S・]` が含まれる場合、`ACTION[i, $]` に `"accept"` を設定します。 (LR(0)と同じ)
    *   **GOTO表**: `goto(Ii, A) = Ij` （`A` は非終端記号）の場合、`GOTO[i, A] = j`。 (LR(0)と同じ)

### SLR(1)によるコンフリクト解消の例

先ほどの文法 G1 でSLR(1)構文解析表を作成してみましょう。

**文法 G1:**

```
(0) S' -> E
(1) E -> E + T
(2) E -> T
(3) T -> id
```

**FOLLOW集合:**

-   `FOLLOW(S')` = `{ $ }`
-   `FOLLOW(E)` = `{ +, $ }` （規則1より `+`、規則0とS'のFOLLOW集合より `$`）
-   `FOLLOW(T)` = `{ +, $ }` （規則1より `FOLLOW(E)` を継承、規則2より `FOLLOW(E)` を継承）

**SLR(1)構文解析表:**

| 状態 | ACTION        |       |      | GOTO |   |
| :--- | :------------ | :---- | :--- | :--- | :- |
|      | **id**        | **+** | **$** | **E** | **T** |
| **0** | s3            |       |      | 1    | 2  |
| **1** |               | s4    | acc  |      |    |
| **2** |               | **r2** | **r2** |      |    |  <-- `FOLLOW(E)` = {+, $} のみ還元
| **3** |               | **r3** | **r3** |      |    |  <-- `FOLLOW(T)` = {+, $} のみ還元
| **4** | s6            |       |      |      | 5  |
| **5** |               | **r1** | **r1** |      |    |  <-- `FOLLOW(E)` = {+, $} のみ還元
| **6** |               | **r3** | **r3** |      |    |  <-- `FOLLOW(T)` = {+, $} のみ還元 (I3と同じ)

LR(0)ではコンフリクトが発生していた状態2, 3, 5, 6を見てみましょう。

-   **状態2**: 項目 `[E -> T・]` を含む。`FOLLOW(E) = {+, $}` なので、`+` と `$` の列にのみ `r2` を設定します。`id` の列にはアクションが設定されず、コンフリクトは解消されました。
-   **状態3**: 項目 `[T -> id・]` を含む。`FOLLOW(T) = {+, $}` なので、`+` と `$` の列にのみ `r3` を設定します。同様にコンフリクトは解消されました。
-   **状態5**: 項目 `[E -> E + T・]` を含む。`FOLLOW(E) = {+, $}` なので、`+` と `$` の列にのみ `r1` を設定します。コンフリクトは解消されました。
-   **状態6**: 項目 `[T -> id・]` を含む。状態3と同じ理由でコンフリクトは解消されました。

このように、SLR(1)はFOLLOW集合を用いることで、LR(0)よりも多くの文法（SLR(1)文法）を解析できるようになります。

### SLR(1)の限界

しかし、SLR(1)でもコンフリクトを解消できない場合があります。FOLLOW集合は、文法全体から見てその非終端記号の後に何が来るかを示すものであり、特定の状態における文脈を十分に考慮できていないためです。

**例：SLR(1)でコンフリクトが発生する文法 G2**

```
(0) S' -> S
(1) S -> L = R
(2) S -> R
(3) L -> * R
(4) L -> id
(5) R -> L
```

この文法は、代入文のような構造を表します。この文法でLR(0)項目集合を作成し、SLR(1)解析表を構築しようとすると、以下のような状況でコンフリクトが発生します。

まず、LR(0)項目集合（状態）を構築していくと、ある状態 `Ii` が `{[S -> L・= R], [R -> L・]}` のような項目を含むことがあります（簡単のため、閉包の一部のみを示しています）。
ここで、`FOLLOW(R)` を計算すると、規則 `S -> L = R` からは FOLLOW(R) に `$` (S'のFOLLOW) が入り、規則 `S -> R` からも FOLLOW(R) に `$` が入ります。また、もし `R` が他の規則の右辺の末尾以外にも出現し、その後に `=` が続くような文脈があれば、`FOLLOW(R)` に `=` が含まれる可能性があります（このG2文法では、`S -> L = R` で `R` は末尾なので、直接的には `=` は `FOLLOW(R)` には入りにくいですが、より複雑な文法では起こりえます。ここでは仮に `FOLLOW(R) = {=, $}` となったとします）。

この状態でSLR(1)解析表の `ACTION[i, =]` を決定しようとすると、
- 項目 `[S -> L・= R]` から: `shift` アクション (仮に `shift j` とする)
- 項目 `[R -> L・]` と `FOLLOW(R)` に `=` が含まれることから: `reduce by R -> L` (規則5)
となり、シフト/還元コンフリクトが発生します。

このコンフリクトは、状態 `Ii` において `R -> L` で還元した後、次が `=` であることは文法的にありえない（例えば、`R` が文全体の右辺に来る場合など）にも関わらず、`FOLLOW(R)` という文法全体から導かれる大域的な情報だけでは、その状態における局所的な文脈（`L` の後に `=` が続くべきか、それとも文末か）を区別できないために発生します。

この問題を解決するには、各状態におけるより詳細な文脈情報、すなわち「その項目に到達した際に、次に何が来ることを期待しているか」という情報が必要になります。これが次に説明するLR(1)法のアイデアです。

## 5.11 LR(1) - より強力な先読み情報を持つ項目

**LR(1)**法は、SLR(1)法の限界を克服するために、各項目に**先読み記号（lookahead symbol）**という、より強力な文脈情報を付加する手法です。これにより、SLR(1)では区別できなかった状態を区別し、コンフリクトを解消することが可能になります。LR(1)法は、理論上、LR(k)文法（k≧1）の中で最も強力な解析能力を持ちます。

### LR(1)項目

LR(1)項目は、LR(0)項目に先読み記号（終端記号）を追加したもので、以下の形式で表されます。

```text
[A -> α・β, a]
```

-   `A -> α・β`: LR(0)項目部分。`α` を認識し、次に `β` を期待する状態。
-   `a`: 先読み記号。この項目が最終的に還元 `A -> αβ` に成功した場合、その直後に入力されることが期待される終端記号。

例えば、`[E -> E・+ T, $]` というLR(1)項目は、「`E` を認識し、次に `+` を期待しており、もしこの `E` が最終的に開始記号 `S'` まで還元された場合、入力の終わり `$` が来るはずだ」という文脈情報を含んでいます。

### LR(1)閉包（Closure）とGOTO関数

LR(1)項目集合（状態）を構築するための閉包とGOTO関数も、先読み記号を考慮するように拡張されます。

#### LR(1)閉包

状態 `I` のLR(1)閉包 `closure(I)` は、以下の手順で計算します。

1.  `closure(I)` を `I` で初期化する。
2.  `closure(I)` 内の各項目 `[A -> α・Bβ, a]` （`B`は非終端記号）について、`B` から始まるすべての規則 `B -> γ` に対して、**`FIRST(βa)` に含まれる各終端記号 `b`** について、項目 `[B -> ・γ, b]` を `closure(I)` に追加する。
    *   `FIRST(βa)` は、`β` の後に `a` が続く記号列から導かれうる最初の終端記号の集合です。`β` が `ε` を含めば `a` も含まれます。
3.  新しい項目が追加されなくなるまで、ステップ2を繰り返す。

LR(0)閉包との違いは、新しい項目 `[B -> ・γ, b]` を追加する際に、元の項目の `β` と先読み記号 `a` から計算される `FIRST(βa)` を使って、新しい項目の先読み記号 `b` を決定する点です。これにより、より正確な文脈情報が伝播します。

#### LR(1) GOTO関数

GOTO関数 `goto(I, X)` の計算方法はLR(0)と似ていますが、LR(1)項目を扱います。

1.  状態 `I` 内のすべての項目 `[A -> α・Xβ, a]` について、ドットを一つ右に移動させた項目 `[A -> αX・β, a]` を集める。
2.  これらの新しい項目の集合に対して **LR(1)閉包** 操作を行い、結果を `goto(I, X)` とする。

### LR(1)構文解析表の作成

LR(1)構文解析表の作成手順もSLR(1)と似ていますが、還元アクションの決定にFOLLOW集合ではなく、**LR(1)項目の先読み記号**を使用します。

1.  **文法の拡張**: LR(0)と同様。
2.  **LR(1)項目集合（状態）の構築**:
    *   初期状態 `I0` は `closure({[S' -> ・S, $]})` とする。
    *   GOTO関数を用いて、到達可能なすべてのLR(1)状態を構築する。
3.  **構文解析表の作成**:
    *   **ACTION表**:
        *   **シフト**: 状態 `Ii` に項目 `[A -> α・aβ, b]` が含まれ、`goto(Ii, a) = Ij` （`a` は終端記号）の場合、`ACTION[i, a] = "shift j"`。
        *   **還元**: 状態 `Ii` に項目 `[A -> α・, a]` （`A ≠ S'`）が含まれる場合、**その項目の先読み記号 `a` に対してのみ**、`ACTION[i, a] = "reduce A -> α"` を設定します。 (ここがSLR(1)と異なる！)
        *   **受理**: 状態 `Ii` に項目 `[S' -> S・, $]` が含まれる場合、`ACTION[i, $]` に `"accept"` を設定します。
    *   **GOTO表**: `goto(Ii, A) = Ij` （`A` は非終端記号）の場合、`GOTO[i, A] = j`。 (LR(0)/SLR(1)と同じ)

### LR(1)によるコンフリクト解消の例

先ほどSLR(1)でコンフリクトが発生した文法 G2 をLR(1)で解析してみましょう。

**文法 G2:**

```
(0) S' -> S
(1) S -> L = R
(2) S -> R
(3) L -> * R
(4) L -> id
(5) R -> L
```

SLR(1)でコンフリクトが発生したのは、ある状態（仮に `Ik` とする）に `[R -> L・]` という項目があり、次の入力が `=` の場合でした。SLR(1)では、`FOLLOW(R)` に基づいて還元を決定します。文法G2において、`FOLLOW(R)` には（`S -> R` という規則と `S' -> S` により）`$` が含まれます。また、`S -> L = R` という規則があるため、もし `L` が `R` を導出するような別の経路があれば、`FOLLOW(R)` に `=` が含まれる可能性も出てきます。

LR(1)では、項目自体に先読み記号が付与されるため、より精密な判断が可能です。
例えば、状態 `Ik` に対応するLR(1)状態を考えると、
- `S -> L・= R` という文脈から `R -> L` の還元に至る場合、`L` の直後に期待されるのは `=` です。このため、項目は `[R -> L・, =]` のようになります。
- `S -> R` という文脈から `R -> L` の還元に至る場合、`L` (つまり`R`) の直後に期待されるのは `$` です。このため、項目は `[R -> L・, $]` のようになります。

このように、同じLR(0)コア `R -> L・` を持っていても、先読み記号が異なるため、LR(1)では異なる状態（または同じ状態内の異なる項目）として扱われます。
その結果、LR(1)構文解析表では、
- `[R -> L・, =]` を含む状態 `Ij` では、`ACTION[j, =]` に `reduce by R -> L` が設定されます。
- `[R -> L・, $]` を含む状態 `Ik` では、`ACTION[k, $]` に `reduce by R -> L` が設定されます。

もし、状態 `Ij` に `[S -> L・= R, $]` (先読みは `$`）のようなシフトアクションにつながる項目が含まれていても、`reduce by R -> L` は入力 `=` の場合にのみ適用されるため、`=` におけるシフト/還元コンフリクトは発生しません。同様に、`$` におけるコンフリクトも、先読み記号が一致する場合にのみアクションが定義されるため、解消される可能性が高まります。

このように、LR(1)は項目ごとに正確な先読み記号を持つことで、SLR(1)よりも精密な判断が可能になり、より多くの文法（LR(1)文法）を解析できます。

### LR(1)の欠点：解析表のサイズ

LR(1)法の最大の欠点は、状態数が非常に多くなることです。LR(0)項目が同じでも、先読み記号が異なれば別のLR(1)状態となるため、状態数はSLR(1)（LR(0)状態数と同じ）に比べて大幅に増加する傾向があります。これは、構文解析表のサイズが巨大になることを意味し、メモリ使用量や生成時間の観点から実用的でない場合があります。

この問題を解決するために、次に説明するLALR(1)法が考案されました。

## 5.12 LALR(1) - 実用性と解析能力のバランス

**LALR(1)**（Look-Ahead LR）法は、LR(1)法の強力な解析能力を維持しつつ、構文解析表のサイズをSLR(1)法と同程度に抑えることを目的とした、実用的な上向き構文解析アルゴリズムです。多くの構文解析器生成系（YaccやBisonなど）で採用されている標準的な手法です。

### LALR(1)のアイデア：状態のマージ

LALR(1)法の基本的なアイデアは、LR(1)状態の中で、**LR(0)項目部分（コア）が全く同じ状態を一つにマージ（統合）する**ことです。

LR(1)状態は `[A -> α・β, a]` の形式でした。このうち `A -> α・β` の部分を**コア (core)** と呼びます。LALR(1)では、コアが同じである複数のLR(1)状態を一つのLALR(1)状態にまとめます。

例えば、LR(1)で以下のような二つの状態があったとします。

-   状態 `I`: `{ [A -> α・, a], [B -> γ・, c] }`
-   状態 `J`: `{ [A -> α・, b], [B -> γ・, d] }`

これらの状態は、コア `A -> α・` と `B -> γ・` が共通です。LALR(1)では、これらを一つの状態 `K` にマージします。マージ後の状態 `K` に含まれる項目の先読み記号は、マージ元のすべての先読み記号を合わせたものになります。

-   状態 `K`: `{ [A -> α・, a/b], [B -> γ・, c/d] }`
    （ここで `a/b` は先読み記号が `a` または `b` であることを示す）

このように状態をマージすることで、LALR(1)の状態数はLR(0)の状態数と同じになります。

### LALR(1)構文解析表の作成

LALR(1)構文解析表は、マージされたLALR(1)状態に基づいて作成されます。

1.  **LR(1)状態の構築**: まず、LR(1)法のアルゴリズムに従って、すべてのLR(1)状態（項目集合）を構築します。
2.  **状態のマージ**: コア（LR(0)項目部分）が同じLR(1)状態を特定し、それらを一つのLALR(1)状態にマージします。マージ後の項目の先読み記号は、マージ元の項目の先読み記号の和集合となります。
3.  **構文解析表の作成**: マージ後のLALR(1)状態を用いて、LR(1)と同様の手順でACTION表とGOTO表を作成します。
    *   **シフト**: LR(1)と同様。
    *   **還元**: 状態 `Ii` に項目 `[A -> α・, a]` が含まれる場合、先読み記号 `a` に対して `ACTION[i, a] = "reduce A -> α"` を設定します。マージによって一つの項目に複数の先読み記号が含まれる場合（例：`[A -> α・, a/b]`）、`a` と `b` の両方の列に還元アクションを設定します。
    *   **受理**: LR(1)と同様。
    *   **GOTO**: LR(1)と同様（マージされた状態への遷移となります）。

### LALR(1)の利点と欠点

#### 利点

-   **解析表サイズ**: LALR(1)の解析表のサイズ（状態数）は、LR(0)やSLR(1)と同程度であり、LR(1)に比べて大幅に小さくなります。これにより、メモリ使用量や生成時間の点で実用的です。
-   **解析能力**: ほとんどの実用的なプログラミング言語の文法はLALR(1)で解析可能です。SLR(1)よりも強力であり、LR(1)で解析可能な文法の大部分をカバーします。

#### 欠点

-   **還元/還元コンフリクトの可能性**: LR(1)状態をマージする際に、異なる先読み記号を持つ還元項目が同じLALR(1)状態にまとめられることがあります。もし、マージ元のLR(1)状態では異なるアクション（例えば、異なる規則での還元）が割り当てられていた場合、マージ後のLALR(1)状態では同じ入力記号に対して複数の還元アクションが設定され、**還元/還元コンフリクト**が発生する可能性があります。これはLR(1)では発生しなかったコンフリクトです。
    *   ただし、このようなコンフリクトが発生する文法は稀であり、実用上問題になることは少ないとされています。
-   **シフト/還元コンフリクト**: LALR(1)では、LR(1)で解決されていたシフト/還元コンフリクトが解消されるとは限りません（ただし、新たに発生することもありません）。

### LALR(1)の位置づけ

LALR(1)は、LR(1)の強力な解析能力と、SLR(1)のコンパクトな解析表サイズという、両者の利点を高いレベルで両立させた、非常にバランスの取れた実用的なアルゴリズムです。そのため、Yacc、Bison、PLY（Python Lex-Yacc）など、多くの構文解析器生成系で標準的に採用されています。

もしLALR(1)でコンフリクトが発生した場合、文法を修正するか、より強力な（しかし一般的には効率が劣るか、実装が複雑な）GLR（Generalized LR）などのアルゴリズムを検討することになります。

---

ここまでで、代表的な上向き構文解析アルゴリズムであるLR(0), SLR(1), LR(1), LALR(1)について、その基本的な考え方、構築手順、利点、限界を順に見てきました。次は、近年注目を集めている別のアプローチ、Parsing Expression Grammar (PEG) について見ていきましょう。

## 5.13 Parsing Expression Grammar(PEG) - 新しいアプローチ

これまでLL系、LR系の構文解析アルゴリズムを見てきました。どちらも「曖昧性のない文法」を前提としていました。しか、2004年にBryan Fordが提案した**Parsing Expression Grammar（PEG）**は、全く違うアプローチを取ります。

### PEGの基本アイデア

PEGの最大の特徴は：

1. **順序付き選択**：`A / B`は「まずAを試し、失敗したらBを試す」
2. **無制限なバックトラック**：失敗したら元の位置に戻る
3. **字句解析が不要**：文字列レベルで直接解析

これにより、CFGよりも表現力が高く、より直感的な文法記述が可能になりました。

### 第3章で実装したPEG

思い出してください。第3章で最初に実装した`PegJsonParser`がまさにPEGの実装でした。ポイントは：

1. 現在位置を保存（`int backup = cursor;`）
2. 最初の選択肢を試す
3. 失敗したら位置を戻して（`cursor = backup;`）次を試す

この「バックトラック」がPEGの核心です。

### PEGの利点

PEGには多くの利点があります：

1. **表現力の高さ**：文脈自由言語に加え、一部の文脈依存言語も扱える
2. **直感的な記述**：「まずこれを試し、ダメなら次」という自然な思考
3. **字句解析不要**：トークン化のフェーズが不要
4. **Packrat Parsing**：メモ化により線形時間を保証

これらの特性により、Python 3.9のパーサや多くのプログラミング言語のパーサでPEGが採用されています。

### 配列の解析例

第3章で実装した配列の解析を例に、PEGの動作を追ってみましょう：

```text
array <- LBRACKET (value (COMMA value)*)? RBRACKET
// 上記は以下と同等とも解釈できる (PEGでは / が順序付き選択)
// array <- LBRACKET RBRACKET / LBRACKET value (COMMA value)* RBRACKET
// ここでは第3章のコード実装に合わせた以下の定義で考えます。
// array = LBRACKET RBRACKET | LBRACKET value {COMMA value} RBRACKET ;
```

　このPEGの考え方（特に `|` による選択と、失敗時のバックトラック）に対応するJavaの構文解析器（メソッド）は以下のようになるのでした。

```java
    public Ast.JsonArray parseArray() {
        int backup = cursor;
        try {
            // LBRACKET RBRACKET
            parseLBracket();
            parseRBracket();
            return new Ast.JsonArray(new ArrayList<>());
        } catch (ParseException e) {
            cursor = backup;
        }

        // LBRACKET
        parseLBracket();
        List<Ast.JsonValue> values = new ArrayList<>();
        // value
        var value = parseValue();
        values.add(value);
        try {
            // {value {COMMA value}}
            while (true) {
                parseComma();
                value = parseValue();
                values.add(value);
            }
        } catch (ParseException e) {
            // RBRACKET
            parseRBracket();
            return new Ast.JsonArray(values);
        }
    }
```

PEGの特色は、

```java
        int backup = cursor;
```

という行によって、解析を始める時点でのソースコード上の位置を保存しておき、もし解析に失敗したら以下のように「巻き戻す」ところにあります。「巻き戻した」位置から次の分岐を試そうとするのです。

```java
        } catch (ParseException e) {
            cursor = backup;
        }
        // LBRACKET
        parseLBracket();
        // ...
```

なお、PEGの挙動を簡単に説明するために3章および本章では例外をスロー/キャッチするという実装にしていますが、現実にはこのような実装にするとオーバーヘッドが大きすぎるため、実用的なPEGパーザでは例外を使わないことが多いです。

### PEGの形式的定義

PEGは以下の8つの構成要素から成り立ちます：

1. 空文字列： ε
2. 終端記号： t
3. 非終端記号： N
4. 連接： e1 e2
5. 選択： e1 / e2
6. 0回以上の繰り返し： e*
7. 肯定述語： &e
8. 否定述語： !e
  
  次節以降では、この8つの要素がそれぞれどのような意味を持つかを説明していきます。説明のために

```java
match(e, v) == Success(consumed, rest) 
```

や

```java
match(e, v) == Failure
```

というJava言語ライクな記法を使います。

たとえば、

```java
match("x", "xy") == Success("x", "y")`
```

は式`x`が文字列`"xy"`にマッチして残りの文字列が`"y"`であることを示します。また、

```java
match("xy", "x") == Failure
```

は式`"xy"`が文字列`"x"`にマッチしないことを表現します。

### 空文字列

空文字列εは0文字**以上**の文字列にマッチします。たとえば、

```java
match(ε, "") == Success("", "")
```

が成り立つだけでなく、

```java
match(ε, "x") ==  Success("", "x")
```

や

```java
match(ε, "xyz") == Success("", "xyz")
```

も成り立ちます。εは**あらゆる文字列**にマッチすると言い換えることができます。

### 終端記号

終端記号`t`は1文字以上の長さで特定のアルファベットで**始まる**文字列にマッチします。たとえば、

```java
match(x, "x") == Success("x", "")
```

や

```java
match(x, "xy") == Success("x", "y")
```

が成り立ちます。一方、

```java
match(x, "y") == Failure
```

ですし、

```java
match(x, "") == Failure
```

です。εの場合と同じく「残りの文字列」があってもマッチする点に注意してください。

### 選択

`e1`と`e2`は共に式であるものとします。このとき、


```text
e1 / e2
```

に対する`match(e1 / e2, s)`は以下のような動作を行います。

1. `match(e1, s)`を実行する
2. 1.が成功していれば、sのサフィックスを返し、成功する
3. 1.が失敗した場合、`match(e2, s)`を実行し、結果を返す

### 連接

`e1`と`e2`は共に式であるものとします。このとき、

```text
e1 e2
```

に対する`match(e1 e2, s)`は以下のような動作を行います。

1. `match(e1, s)`を実行する
2. 1.が成功したとき、結果を`Success(s1,s2)`とする。この時、`match(e2,s2)`を実行し、結果を返す
3. 1.が失敗した場合、その結果を返す

### 非終端記号

あるPEGの規則Nがあったとします。

```text
N <- e
```

`match(N, s)`は以下のような動作を行います。

1. `N`に対応する規則を探索する（`N <- e`が該当）
2. `N`の呼び出しから戻って来たときのために、スタックに現在位置`p`を退避
3. `match(e, s)`を実行する。結果を`M`とする。
4. スタックに退避した`p`を戻す
5. `M`を全体の結果とする

### 0回以上の繰り返し

`e`は式であるものとします。

```text
e*
```

このとき、eと文字列sの照合を行うために以下のような動作を行います。

1. `match(e,s)`を実行する
2. 1.が成功したとき（`n`回目）、結果を`Success(s_n,s_(n+1))`とする。`s`を`s_(n+1)`に置き換えて、1.に戻る
3. 1.が失敗した場合（`n`回目）、結果を`Success(s_1...s_n, s[n...])`とする

`e*`は「0回以上の繰り返し」を表現するため、一回も成功しない場合でも全体が成功するのがポイントです。なお、`e*`は規則

```
H <- e H / ε
```

に対して`H`を呼び出すことの構文糖衣であり、全く同じ意味になります。

### 肯定述語

`e`は式であるものとします。このとき、

```text
&e
```

は`match(&e,s)`を実行するために、以下のような動作を行います。

1. `match(e,s)`を実行する
2-1. 1.が成功したとき：結果を`Success("", s)`とする
2-2. 1.が失敗した場合：結果は`Failure()`とする

肯定述語は成功したときにも「残り文字列」が変化しません。肯定述語`&e`は後述する否定述語`!!`を二重に重ねたものに等しいことが知られています。


### 否定述語

`e`は式であるものとします。このとき、

```text
!e
```

は`match(!e,s)`を実行するために以下のような動作を行います。

1. `match(e,s)`を実行する
2-1. 1.が成功したとき：結果を`Failure()`とする
2-2. 1.が失敗した場合：結果は`Success("", s)`とする

否定述語も肯定述語同様、成功しても「残り文字列」が変化しません。

前述した`&e = !!e`は論理における二重否定の除去に類似するものということができます。

### PEGとCFGの違い

PEGとCFGの重要な違いをまとめると：

| 特徴 | CFG | PEG |
|------|-----|-----|
| 選択演算子 | `｜`（非決定的） | `/`（順序付き） |
| 曖昧性 | あり得る | 常に一意 |
| 字句解析 | 必須 | 不要 |
| 左再帰 | 問題なし（LR系） | 無限ループ |
| 表現力 | 文脈自由言語 | それ以上 |

### PEGの実用例

PEGは以下のような場面で使われています：

- **Python 3.9+**：新しいPEGベースのパーサ
- **Ruby**：TreetopなどのPEGパーサジェネレータ
- **JavaScript**：PEG.jsなど
- **各種DSL**：簡単に書けるため重宝される

```
1. 空文字列: 
  (ε, x) ⇒ (0, x)  (消費文字数0、残りx)
2. 終端記号(成功した場合): 
  (a, ax) ⇒ (length(a), x) (a ∈ VT, x ∈ V*T)
3. 終端記号(失敗した場合):
  (a, bx) ⇒ (0, f)  iff a ≠ b (a, b ∈ VT)
  (a, ε) ⇒ (0, f)   (入力が空の場合)
4. 非終端記号:
  (A, x) ⇒ (k, y)  iff (e, x) ⇒ (k, y)  (ここで A ← e ∈ R)
5. 連接(成功した場合): 
  (e1, x) ⇒ (k1, x') かつ (e2, x') ⇒ (k2, x'') のとき、
  (e1 e2, x) ⇒ (k1 + k2, x'')
6. 連接(失敗した場合１): 
  (e1, x) ⇒ (k1, f) ならば (e1 e2, x) ⇒ (k1, f)
7. 連接(失敗した場合２): 
  (e1, x) ⇒ (k1, x') かつ (e2, x') ⇒ (k2, f) ならば (e1 e2, x) ⇒ (k1 + k2, f)
8. 選択(場合１): 
  (e1, x) ⇒ (k1, y) (y ≠ f) ならば (e1 / e2, x) ⇒ (k1, y)
9. 選択(場合２): 
  (e1, x) ⇒ (k1, f) かつ (e2, x) ⇒ (k2, y) ならば (e1 / e2, x) ⇒ (k1 + k2, y)
10. 0回以上の繰り返し (繰り返しの場合): 
  (e, x) ⇒ (k1, x') (x' ≠ f) かつ (e*, x') ⇒ (k2, x'') ならば
  (e*, x) ⇒ (k1 + k2, x'')
11. 0回以上の繰り返し (停止の場合): 
  (e, x) ⇒ (k, f) ならば (e*, x) ⇒ (0, x) (消費0で成功)
12. 否定述語（場合１、eが成功）: 
  (e, x) ⇒ (k, y) (y ≠ f) ならば (!e, x) ⇒ (k, f)
13. 否定述語（場合２、eが失敗）: 
  (e, x) ⇒ (k, f) ならば (!e, x) ⇒ (k, x) (消費0で成功)
```
(注意: 上記はFordの論文の操作的意味論を簡略化・解釈したものであり、ステップ数カウンタ `n` の扱いや消費文字数の表現は元論文と完全に同一ではありません。正確な定義は元論文を参照してください。)

## 5.14 Packrat Parsing - PEGの線形時間化

PEGの最大の弱点は、バックトラックにより最悪の場合に指数関数時間がかかることです。**Packrat Parsing**は、メモ化（memoization）を使ってこの問題を解決します。

### メモ化とは？

メモ化は、「同じ引数で関数を呼んだら、同じ結果が返る」ことを利用して、一度計算した結果をキャッシュする技法です。

### フィボナッチ数で学ぶメモ化

メモ化の効果をフィボナッチ数の計算で見てみましょう。フィボナッチ数の定義は：

```
F(0) = 1
F(1) = 1
F(n) = F(n - 1) + F(n - 2)
```

この定義を素朴にJavaで実装すると：

```java
public class Main {
    public static long fib(long n) {
        if(n == 0) return 0L; // F(0)=0
        if(n == 1) return 1L; // F(1)=1
        else return fib(n - 1) + fib(n - 2); 
    }
    public static void main(String[] args) {
        // F(0)=0, F(1)=1, F(2)=1, F(3)=2, F(4)=3, F(5)=5
        System.out.println(fib(5)); // 5
    }
}
```

この実装の問題点は、同じ値を何度も計算してしまうことです。たとえば`fib(5)`を計算するとき：
- `fib(3)`が2回計算される
- `fib(2)`が3回計算される
- `fib(1)`が5回計算される

`n`が大きくなるとこの重複が指数関数的に増え、`fib(50)`では数分かかります。

### メモ化による改善

メモ化を適用して、一度計算した結果をキャッシュします：

```java
import java.util.*;
public class Main {
    private static Map<Long, Long> cache = new HashMap<>();
    public static long fib(long n) {
        Long value = cache.get(n);
        if(value != null) return value;

        long result;
        if(n == 0) {
            result = 0L;
        } else if (n == 1) {
            result = 1L;
        } else {
            result = fib(n - 1) + fib(n - 2);
        }
        cache.put(n, result);
        return result;
    }
    public static void main(String[] args) {
        // F(50) = 12586269025 (F(0)=0, F(1)=1 の場合)
        System.out.println(fib(50)); 
    }
}
```

メモ化の効果：
- 各`n`に対して計算は1回のみ
- 時間計算量：`O(2^n)` → `O(n)`
- 空間計算量：`O(1)` → `O(n)`

メモ化のポイントは、**空間を犠牲にして時間を大幅に節約**することです。

### PEGパーサのメモ化

次に、PEGパーサにメモ化を適用してみましょう。以下の簡単な文法を例にします：

```
S ← A*
A ← "a" A "b" / "a"
```

この文法は、バックトラックが多発するため、メモ化の効果が顕著に現れます。まずはメモ化なしの実装：

```java
public class SimplePEGParser {
    private String input;
    private int pos;
    private int callCount = 0;  // パース関数の呼び出し回数をカウント
    
    public boolean parse(String s) {
        this.input = s;
        this.pos = 0;
        this.callCount = 0;
        boolean result = parseS() && pos == input.length();
        System.out.println("Total calls: " + callCount);
        return result;
    }
    
    // S = A A A ... A
    private boolean parseS() {
        callCount++;
        int savedPos = pos;
        
        // まずA*のパースを試みる
        while (parseA()) {
            // Aが成功する限り続ける
        }
        
        // 最後に1つのAをパース
        if (parseA()) {
            return true;
        }
        
        pos = savedPos;
        return false;
    }
    
    // A = "a" A "b" / "a"
    private boolean parseA() {
        callCount++;
        int savedPos = pos;
        
        // まず "a" A "b" を試す
        if (consume('a')) {
            if (parseA()) {
                if (consume('b')) {
                    return true;
                }
            }
        }
        
        // 失敗したら位置を戻す
        pos = savedPos;
        
        // 次に "a" を試す
        if (consume('a')) {
            return true;
        }
        
        pos = savedPos;
        return false;
    }
    
    private boolean consume(char c) {
        if (pos < input.length() && input.charAt(pos) == c) {
            pos++;
            return true;
        }
        return false;
    }
}
```

入力 `"aaabbb"` に対して実行すると、`parseA` が何度も呼ばれることがわかります。同じ位置で同じ非終端記号を何度もパースしているのです。

### メモ化による最適化

これをメモ化で最適化してみましょう：

```java
public class PackratParser {
    private String input;
    private int pos;
    private int callCount = 0;
    
    // メモ化テーブル：Map<位置, Map<ルール名, 結果>>
    private Map<Integer, Map<String, MemoEntry>> memo;
    
    // メモ化エントリ
    static class MemoEntry {
        boolean success;
        int endPos;
        
        MemoEntry(boolean success, int endPos) {
            this.success = success;
            this.endPos = endPos;
        }
    }
    
    public boolean parse(String s) {
        this.input = s;
        this.pos = 0;
        this.callCount = 0;
        this.memo = new HashMap<>();
        
        boolean result = parseS() && pos == input.length();
        System.out.println("Total calls: " + callCount);
        System.out.println("Memo entries: " + countMemoEntries());
        return result;
    }
    
    private boolean parseS() {
        return memoized("S", this::parseSImpl);
    }
    
    private boolean parseSImpl() {
        int savedPos = pos;
        
        // A*のパース
        while (parseA()) {
            // 成功する限り続ける
        }
        
        // 最後に1つのA
        if (parseA()) {
            return true;
        }
        
        pos = savedPos;
        return false;
    }
    
    private boolean parseA() {
        return memoized("A", this::parseAImpl);
    }
    
    private boolean parseAImpl() {
        int savedPos = pos;
        
        // "a" A "b" を試す
        if (consume('a')) {
            if (parseA()) {
                if (consume('b')) {
                    return true;
                }
            }
        }
        
        pos = savedPos;
        
        // "a" を試す
        if (consume('a')) {
            return true;
        }
        
        pos = savedPos;
        return false;
    }
    
    // メモ化のヘルパーメソッド
    private boolean memoized(String ruleName, Supplier<Boolean> parser) {
        callCount++;
        
        // メモ化テーブルをチェック
        Map<String, MemoEntry> posCache = memo.get(pos);
        if (posCache != null) {
            MemoEntry entry = posCache.get(ruleName);
            if (entry != null) {
                // キャッシュヒット！
                pos = entry.endPos;
                return entry.success;
            }
        }
        
        // キャッシュミス：実際にパース
        int startPos = pos;
        boolean success = parser.get();
        int endPos = pos;
        
        // 結果をキャッシュに保存
        if (posCache == null) {
            posCache = new HashMap<>();
            memo.put(startPos, posCache);
        }
        posCache.put(ruleName, new MemoEntry(success, endPos));
        
        return success;
    }
    
    private boolean consume(char c) {
        if (pos < input.length() && input.charAt(pos) == c) {
            pos++;
            return true;
        }
        return false;
    }
    
    private int countMemoEntries() {
        return memo.values().stream()
                   .mapToInt(Map::size)
                   .sum();
    }
}
```

### 効果の比較

同じ入力に対して両方のパーサーを実行すると：

```java
// メモ化なし
SimplePEGParser simple = new SimplePEGParser();
simple.parse("aaabbb");  // Total calls: 28

// メモ化あり（Packrat）
PackratParser packrat = new PackratParser();
packrat.parse("aaabbb");  // Total calls: 10, Memo entries: 7
```

メモ化により、関数呼び出し回数が大幅に削減されています。より長い入力では、この差はさらに顕著になります：

```java
String longInput = "a".repeat(10) + "b".repeat(10);

// メモ化なし：指数的に増加
simple.parse(longInput);   // Total calls: 数千回

// メモ化あり：線形的
packrat.parse(longInput);  // Total calls: 数十回
```

### Packrat Parsingの特徴

**利点：**
- 線形時間保証：`O(n)`（`n`は入力長）
- 左再帰対応：工夫により可能
- 実装が比較的単純

**欠点：**
- メモリ使用量：`O(n×m)`（`m`は文法規則数）
- キャッシュミスのオーバーヘッド
- 並列化が困難

### 実用的な工夫

実際のPackratパーサーでは、メモリ使用量を削減するための工夫が行われます：

1. **部分的メモ化**：頻繁にバックトラックが発生する箇所のみメモ化
2. **カットオペレータ**：バックトラック不要な箇所を明示（`/`ではなく`//`など）
3. **左再帰の検出と処理**：特殊なアルゴリズムで対応

Packrat Parsingは、PEGの表現力とLL(1)パーサーの効率性を両立させる優れた手法です。メモリ使用量は増えますが、現代のコンピュータでは多くの場合問題になりません。
## 5.15 - 構文解析アルゴリズムの計算量と表現力の限界 

　LL parsing、LR parsing、PEG、Packrat parsingについてこれまで書いてきましたが、計算量的な性質についてまとめておきましょう。なお、`n`は入力文字列長を表します。

| アルゴリズム        | 時間計算量     | 空間計算量 (解析表またはメモ化テーブル) | 備考                                   |
| ------------------- | ------------- | --------------------------------------- | -------------------------------------- |
| LL(1)               | O(n)          | O(\|N\| * \|T\|)                        | \|N\|:非終端記号数, \|T\|:終端記号数     |
| LL(k)               | O(n)          | O(\|N\| * \|T\|^k)                      | kが大きくなると表サイズが指数的に増大   |
| SLR(1)              | O(n)          | O(状態数_LR0 * (\|T\|+\|N\|))           | 状態数_LR0: LR(0)オートマトンの状態数  |
| LR(1)               | O(n)          | O(状態数_LR1 * (\|T\|+\|N\|))           | 状態数_LR1: LR(1)オートマトンの状態数  |
| LALR(1)             | O(n)          | O(状態数_LR0 * (\|T\|+\|N\|))           | 状態数はLR(0)と同程度 (LR(1)より小さい)|
| PEG                 | O(2^n) (最悪) | O(n) (バックトラック用スタック)         | Packrat Parsingで線形時間に改善可能    |
| Packrat Parsing     | O(n)          | O(n * \|P\|)                            | \|P\|: PEGの規則数（または解析関数種類数）|

**表中の記号の説明:**
- `n`: 入力文字列の長さ
- `|N|`: 非終端記号の数
- `|T|`: 終端記号の数
- `|P|`: CFGの生成規則の総数、またはPEGの規則（解析関数）の数
- `状態数_LR0`: LR(0)オートマトンの状態数
- `状態数_LR1`: LR(1)オートマトンの状態数

PEGを除いて、これまで紹介した全ての手法において線形時間で解析を終えられます。といっても、Packrat Parsing自体がPEGの最適化手法なので、PEGも線形時間で解析を終えられることになります。さらに、PEGは最悪指数関数時間がかかるといっても、多くのケースでは経験的には線形時間＋多少のメモ化で解析を終えられるため、実用上は問題ないことが多いです。

一方、空間計算量については、LL系およびLR系のアルゴリズムでは、解析表のサイズは入力長 `n` に依存しません（文法のサイズに依存します）。これに対し、Packrat Parsingではメモ化テーブルのために `O(n * |P|)` の空間が必要となり、入力長に比例した空間計算量となります。実用的な文法については不要なメモ化をしない（選択的メモ化）という発展的な手法もありますが、ナイーブなPackrat Parsingではこの点に注意が必要です。LLやLR系の手法では空間計算量は入力長に依存しないため、構文解析表のサイズが極端に大きくならないケースではメモリの心配は不要です。

## 5.16 - まとめ

この章では、第4章で学んだ文脈自由文法を基礎として、実際の構文解析アルゴリズムについて詳しく見てきました。特に、Javaプログラマーの皆さんが「きちんと理解」できるよう、段階的に説明を積み上げてきました。

### 学んだアルゴリズムの整理

**下向き構文解析（トップダウン）**
- **予測的構文解析**：Dyck言語を例に、スタックを使った実装を学びました
- **再帰下降構文解析**：スタックを暗黙的に使うメソッド呼び出しによる実装
- **LL(1)構文解析**：FIRST集合とFOLLOW集合を使った1文字先読みによる効率的な実装

**上向き構文解析（ボトムアップ）**
- **シフト還元構文解析**：葉から根に向かって構文木を構築する基本的な考え方
- **LR(0)構文解析**：項目集合と状態機械による自動化、ただしコンフリクトが発生しやすい
- **SLR(1)構文解析**：FOLLOW集合を使ってLR(0)のコンフリクトを部分的に解消
- **LR(1)、LALR(1)**：より強力な文脈情報を持つ（詳細は構文解析の専門書を参照）

**その他の手法**
- **PEG（Parsing Expression Grammar）**：順序付き選択による決定的な構文解析
- **Packrat Parsing**：メモ化によるPEGの線形時間化

### なぜこれらの知識が重要か

1. **パーサジェネレータの選択**
   - ANTLR（LL(*)）、Yacc/Bison（LALR(1)）、PEG.jsなど、各ツールの特性を理解して選択できます
   - 文法の特性に応じて適切な手法を選べるようになります

2. **エラーメッセージの理解**
   - 「shift/reduce conflict」「FIRST/FOLLOW conflict」などのメッセージの意味がわかります
   - 文法の修正方法が理解できるようになります

3. **DSLの設計**
   - 自分でDSL（Domain Specific Language）を設計する際の指針が得られます
   - LL(1)制約やPEGの特性を考慮した、パースしやすい文法設計ができます

4. **パフォーマンスの理解**
   - 各手法の計算量を理解し、適切な最適化を選択できます
   - Packrat Parsingのようなトレードオフ（時間と空間）を理解できます

### 実践への橋渡し

構文解析の理論を学んだ今、次のステップとしては：

1. **第6章で学ぶパーサジェネレータ**を使って、実際に文法を書いてみる
2. **簡単な言語の実装**から始めて、徐々に複雑な文法に挑戦する
3. **既存のプログラミング言語の文法**を読んで、実践的な文法設計を学ぶ

構文解析は一見難しく感じるかもしれませんが、基本的なアイデアは「文字列を構造化する」というシンプルなものです。この章で学んだ各手法の特徴を理解しておけば、実際の開発で構文解析が必要になった時に、適切な選択ができるはずです。
