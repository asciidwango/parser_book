
# 第8章 おわりに

ここまでで構文解析の世界を概観してみましたがいかがでしたか？構文解析、特に非自然言語の構文解析というのは地味なもので、パーサージェネレータの発展などもあり、20世紀末には「構文解析はもう終わった問題だ」という人もいました。ただ、その一方で2000年代以降になってもPEGの発明（再発見）があり、Pythonの構文解析器に採用されるまでにつながりましたし、`LL(*)`や`ALL(*)`のような革新的なアルゴリズムが生み出されています。それも、どちらかといえば主流であった上向き型の構文解析でなく下向き型の構文解析で、です。

とはいえやはり地味なものは地味であり、プログラミング言語処理系を構成するコンポーネントという観点から言っても「脇役」という印象は否めません。ただ、わたしたちはプログラミング言語を書いているときは、コンパイラの内部表現や抽象構文木と対話しているわけではありません。プログラマーが直接対話する相手はプログラミング言語の具象構文であり、具象構文はプログラミング言語の「UI」を担当する部分といえるでしょう。通常のアプリケーションでUIが軽視されるべきでないのと同様にやはり具象構文も軽視されるべきでないと私は思いますし、よりよい具象構文の設計には構文解析の知識が助けになると信じています。

ところで、ここまで、構文解析の基盤を支える「形式言語」の世界についてはあえてはしょった説明に留めました。何故なら構文解析を学ぶという点からすると本筋から外れ過ぎてしまいますし、何より形式言語理論を学ぶのは骨が折れる作業でもあるからです。

とはいえ、せっかくなので、この章では形式言語理論のほんの導入だけでも紹介したいと思います。形式言語理論は、言語の構造を数学的に研究する分野であり、構文解析の理論的基盤となっています。「数学的」というと難しそうに聞こえますが、要は「プログラミング言語の文法を厳密に扱うための理論」と考えてください。

例えば、第4章で触れた「正規言語」や「文脈自由言語」といった言語クラスは、それぞれ異なる計算モデル（機械）によって認識できることが知られています。

- **正規言語:** 有限オートマトンという、有限個の状態しか持たない単純な機械で認識できます。正規表現は正規言語を記述するための便利な記法です。しかし、括弧の対応のように無限のネスト構造を持つものは扱えません。
- **文脈自由言語:** プッシュダウンオートマトンという、有限オートマトンにスタック（無限の深さを持つメモリ）を追加した機械で認識できます。これにより、括弧の対応のような再帰的な構造を扱えるようになります。本書で紹介した多くの構文解析アルゴリズムは、この文脈自由言語を対象としています。
- **文脈依存言語:** 文脈自由言語よりも強力なクラスで、例えば `a^n b^n c^n`（n個のa、n個のb、n個のcがこの順で並ぶ文字列の集合）のような言語を記述できます。これはプッシュダウンオートマトンでは認識が困難です。
- **帰納的可算言語（チューリングマシンが認識する言語）:** 最も強力な言語クラスで、私たちが普段使うJavaやPythonなどのプログラミング言語で書けるアルゴリズム（計算可能な問題）が認識できる言語の範囲に対応します。

\begin{figure}[h]
\centering
\begin{tikzpicture}[scale=1.5]
  % 最外側: チューリングマシン（帰納的可算言語）
  \draw[thick, fill=blue!10] (0,0) ellipse (4.5cm and 3.5cm);
  \node[align=center] at (0,3) {\textbf{チューリングマシン}\\（帰納的可算言語）};
  
  % 2番目: 線形拘束オートマトン（文脈依存言語）
  \draw[thick, fill=green!10] (0,-0.3) ellipse (3.5cm and 2.5cm);
  \node[align=center] at (0,1.7) {\textbf{線形拘束オートマトン}\\（文脈依存言語）};
  
  % 3番目: プッシュダウンオートマトン（文脈自由言語）
  \draw[thick, fill=yellow!10] (0,-0.5) ellipse (2.5cm and 1.7cm);
  \node[align=center] at (0,0.7) {\textbf{プッシュダウン}\\オートマトン\\（文脈自由言語）};
  
  % 最内側: 有限オートマトン（正規言語）
  \draw[thick, fill=red!10] (0,-0.6) ellipse (1.5cm and 0.9cm);
  \node[align=center] at (0,-0.6) {\textbf{有限オートマトン}\\（正規言語）};
\end{tikzpicture}
\caption{オートマトンの階層と言語クラスの対応（各内側の集合は外側の集合に含まれる）}
\label{fig:automaton-hierarchy}
\end{figure}

形式言語理論を学ぶと、「なぜある種のパターンは正規表現で書けるのに、別のパターンは書けないのか？」や「なぜ `a^n b^n` は文脈自由言語なのに `a^n b^n c^n` はそうではないのか？」といった疑問に、より深いレベルで答えることができるようになります。これらの問いは、計算モデルの能力の限界と深く関わっています。

幸い、形式言語理論を学ぶための良質な教科書はいくつもあります。もしこの本を読み終えて、言語の理論的な側面にさらに興味を持った方は、ぜひ専門書を手に取ってみてください。

## さらに学ぶために：参考文献と資料

本書で扱った内容は構文解析の入門的な側面に過ぎません。より深く学びたい読者のために、いくつかの参考文献や資料を紹介します。

### 古典的名著・専門書

*   **Alfred V. Aho, Monica S. Lam, Ravi Sethi, Jeffrey D. Ullman. *Compilers: Principles, Techniques, & Tools (2nd Edition)*** (通称「ドラゴンブック」)
    *   コメント: コンパイラ構築に関する標準的な教科書。字句解析、構文解析（LL、LR）、意味解析、コード生成など、コンパイラの全般的なトピックを網羅。理論的背景もしっかり解説されています。中級者以上向け。
*   **Dick Grune, Ceriel J.H. Jacobs. *Parsing Techniques: A Practical Guide (2nd Edition)***
    *   コメント: 書名通り、様々な構文解析技術に特化した書籍。LL、LRだけでなく、アーリー法、GLR、CYK法など、より高度なアルゴリズムや曖昧性のある文法の扱いについても詳しい。構文解析を専門的に深めたい方向け。
*   **John E. Hopcroft, Rajeev Motwani, Jeffrey D. Ullman. *Introduction to Automata Theory, Languages, and Computation (3rd Edition)***
    *   コメント: 形式言語とオートマトンの理論に関する標準的な教科書。正規言語、文脈自由言語、チューリングマシン、計算可能性と計算の複雑さの理論などを網羅。数学的な厳密さを求める方向け。

### 特定の技術に関する論文・資料

*   **Bryan Ford. "Parsing Expression Grammars: A Recognition-Based Syntactic Foundation" (2004)**
    *   コメント: PEGを提案したオリジナルの論文。PEGの形式的な定義、操作的意味論、Packrat Parsingについて解説。理論的な背景を深く理解したい方向け。 (オンラインで検索すれば見つかるはずです)
*   **Terence Parr. *The Definitive ANTLR 4 Reference***
    *   コメント: ANTLR v4の作者自身による解説書。ANTLRの文法定義、使い方、ALL(*)アルゴリズムの概要、実践的なパーサー構築のテクニックが豊富。ANTLRを使いこなしたいなら必読。
*   **ANTLR公式サイト (antlr.org)**
    *   コメント: ANTLRのドキュメント、チュートリアル、文法リポジトリなど。最新情報やコミュニティのサポートも得られます。
*   **JavaCC公式サイト (javacc.github.io/javacc/)**
    *   コメント: JavaCCのドキュメント、チュートリアル、FAQなど。
*   **GNU Bisonマニュアル (www.gnu.org/software/bison/manual/)**
    *   コメント: Bison (Yacc互換) の詳細なマニュアル。LALR(1)やGLRパーサーの生成方法、文法定義の書き方などが学べます。

### オンラインリソース・コミュニティ

*   各種プログラミング言語のパーサーコンビネータライブラリのドキュメント (例: Scalaの`scala-parser-combinators`, Haskellの`Parsec`, Pythonの`pyparsing`など)
    *   コメント: 各言語でパーサーコンビネータを使って手軽にパーサーを構築する方法を学べます。
*   Stack OverflowなどのQ&Aサイト
    *   コメント: 特定の構文解析の問題やツールの使い方について、具体的な質問と回答が見つかることがあります。

これらの資料を通じて、構文解析の世界への探求をさらに深めていただければ幸いです。

## 最後に

本書を通じて、構文解析の基本的な考え方や、様々なアルゴリズム、そして現実のプログラミング言語が抱える課題の一端に触れていただきました。
「よりよい具象構文の設計には構文解析の知識が助けになる」と冒頭で述べましたが、これは例えば、あなたが新しいドメイン固有言語（DSL）を設計する際に、利用者が直感的に理解しやすく、かつパーサーが効率的に解析できるような構文（例: 演算子の優先順位、予約語の選択、ブロック構造の表現方法など）を選ぶ上で、本書で学んだLL/LRの特性やPEGの柔軟性といった知識が役立つでしょう。

たとえば、JSONのようなシンプルな設定ファイル形式を拡張したいとき、コメント機能を追加するにしても「行コメント」にするか「ブロックコメント」にするか、あるいはPythonのような文字列リテラル内のドキュメント方式にするかで、構文解析の難易度は変わってきます。こうした選択を適切に行えるようになることが、本書で得られる実践的な知識の一つです。

また、「構文解析は終わった問題ではない」という点も強調しておきたいと思います。プログラミング言語は進化を続けており、async/awaitのような非同期処理の構文、パターンマッチングの高度化、型システムの進化に伴う構文の複雑化など、新しい言語機能は依然として構文解析技術に新たな課題を提示し続けています。これらの課題に取り組む上で、本書で得た知識が何らかの形で皆さんの力になることを願っています。

構文解析の世界は奥深く、そして面白いものです。この本が、その面白さを少しでも伝えることができたなら、著者としてこれ以上の喜びはありません。

2025年6月、自室にて。水島宏太
