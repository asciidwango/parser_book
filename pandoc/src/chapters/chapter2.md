<!-- Chapter 7: 第2章:構文解析の基本 -->

# 第2章 構文解析の基本

この章からいよいよ構文解析についての説明を始めたいと思います。とはいっても本書を手に取った皆様は構文解析についてまだ馴染みがないかと思います。そこで、まずは簡単な算術式の構文解析を例にして、構文解析の基本について学ぶことにしましょう。

## 算術式の文法

ただ「算術式」といっただけだと人によってかなりイメージするものが異なります。本書では以下の条件を満たすものを算術式とします。

- 四則演算ができる
  - 足し算は`x+y`
  - 引き算は`x-y`
  - 掛け算は`x*y`
  - 割り算は`x/y`
- 優先順位は掛け算・割り算が高く、足し算・引き算が低い
  - 例：`1+2*3`は`1+(2*3)`と解釈される
- 同じ優先順位の演算子は左から右に結びつく
  - 例：`1+2-3`は`(1+2)-3`と解釈される
- 値は整数のみ
  - 例：`1+2.0`のような式はエラーになる
- 式の優先順位を変えるために括弧を使うことができる
  - 例：`1+2*3`は`1+(2*3)`の意味になるが、`(1+2)*3`と書くことで意味が変わる
- スペースは使えない
  - 例：`1+2`はOKだが、`1 + 2`はエラーになる

最後の「スペースは使えない」という制限は、字句解析（文字列を意味のある単位、トークンに分割する処理）を単純化し、構文解析の核となる考え方に集中するために設けています。実際の算術式ではスペースも使えてかつ無視されるのが一般的ですが、その処理は後の章で触れることにします。

この定義に従う算術式には以下のようなものが含まれます。

```text
100
1+2*3
(1+2)*3
3*(1+2)
12/3
1+3*4/2
```

普段、皆さんは何かしらのプログラミング言語を使ってプログラムを書いているはずですから、上のような算術式は馴染みが深いはずです。

しかし、上のような日本語を使った定義だけでは算術式の文法を表現するのには不十分です。たとえば「式の優先順位を変えるために括弧を使うことができる」といっても、なんとなくはわかるものの、定義としては曖昧です。もちろん、日本語で詳しく記述して曖昧さを少なくしていくこともできますが、いたずらに長くなるだけです。

曖昧さなく文法を表現するための文法である**形式文法**を使って、算術式の文法を表現することが一般的です。形式文法というと何かしらとても難しいもののように感じられますが、実際には簡単なものです。次節では形式文法の一つであり、もっともメジャーな表記法であるBNF（Backus-Naur Form、バッカス・ナウア記法）を使って、算術式の文法を表現してみましょう。

## 算術式のBNF

プログラミング言語の文法自体を表現する文法（メタ文法といいます）の一つに、BNFがあります。BNFは、プログラミング言語の文法をはじめ、インターネット上でのメッセージ交換フォーマットなど、様々な文法を表現するのに使われています。本書の読者の方にはBNFに馴染みのない方も多いと思うので、算術式のBNFの前にBNFについて説明します。本書では、記述を簡潔にするため、ISO/IEC 14977で仕様が策定されたEBNF[^1]で用いられる繰り返し（`{}`）、オプション（`[]`）、グループ化（`()`）といった拡張記法を一部取り入れ、これを広義のBNFとして扱います。BNFには歴史的に多くの方言が存在するため、本書で用いる記法について事前に説明しておきます。

### BNFの概要

BNFはFortranの開発者でもある、John Backus（ジョン・バッカス）らが開発した記法です。BNFは「プログラミング言語」そのものの文法を記述するために開発されました。基本情報技術者試験でも出題されるので、そこで知った方もおられるかもしれません。

本書で用いる広義のBNF（EBNFの要素を取り入れたもの）の主要な記法は以下の通りです。

*   `=` : 左辺の規則名と右辺の定義を区切ります。
*   `|` : 選択を表します。例えば `A | B` は「AまたはB」を意味します。
*   `{}` : 0回以上の繰り返しを表します。例えば `A {B}` は「Aの後にBが0回以上続く」ことを意味します。これは純粋なBNFでは `X = A Y` と `Y = B Y | ε` のように再帰を使って表現されます。
*   `[]` : 0回または1回の出現（オプション）を表します。例えば `[A] B` は「Aがあるかもしれないし、ないかもしれないが、その後にBが続く」ことを意味します。これは純粋なBNFでは `X = A B | B` のように表現されます。
*   `()` : グループ化を表します。例えば `(A | B) C` は「AまたはBの後にCが続く」ことを意味します。
*   `'...'` または `"`...`"` : 終端記号（リテラル文字列）を表します。
*   規則名（例: `expression`, `term`）: 非終端記号を表します。

では早速、BNFの具体例を見て行きましょう。以下の例は2.1で出てきた算術式を元に、

- 扱える数値は一桁だけ

のように単純化したBNFです。

```text
expression = term { ('+' | '-') term };
term = factor { ('*' | '/') factor };
factor = NUMBER | '(' expression ')';
NUMBER = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
```

たくさんの記号が出てきましたが、順番に見ていきましょう。

### expression

BNFでは、以下のような**生成規則**の集まりによって、文法を表現します。

 ```
expression = term { ('+' | '-') term };
 ```

`=`の左側である`expression`が**規則名**で、右側が**本体**になります。

ここでは 

```
term { ('+' | '-' ) term }
```

が本体になります。

本体の中に出てくる、他の規則を参照する部分（ここでは`term`)を**非終端記号**と呼び、これは同じBNF内で定義されている規則名と一致する必要があります。

また、`'+'`や`'-'`のように`'`で囲まれた記号や文字を**終端記号**と呼びます。これはそのままの文字（あるいは文字列）である必要があり、その文字自身を表します。

BNFにおいて`{}`で囲まれたものは、その中の要素が0回以上繰り返して出現することを示しています。したがって、`term { ('+' | '-') term }`という記述は、まず`term`が出現し、その後に「`+`または`-`とそれに続く`term`」が0回以上繰り返して出現することを示しています。0回以上という言い方がとくに重要です。というのは、`term`が1回だけ出現してその後は何も出現しない場合もあるからです。たとえば、`1`という式はこの規則にマッチしますが、`{}`で囲まれた部分は出現していません。
  
この規則を日本語で表現すると「`expression`という名前の規則は、右辺の定義 `term { ('+' | '-') term }` に従って構成される」と読むことができます。

なお、本来の（ISO/IEC）BNFでは

```
expression = term, { ('+' | '-'), term };
```

のように要素間をカンマで区切りますが、本書では可読性を考慮してスペースで区切るようにしています。

### term

`term` は算術式の中で、掛け算や割り算を含んだ式を表す規則です。`factor`という規則を参照しています。

```text
term = factor { ('*' | '/') factor };
```

この規則によって`term`は、`factor`が`*`または`/`を挟んで0回以上繰り返して出現することを示しています。

### factor

`factor`は算術式の中で、数値や括弧で囲まれた式を表す規則です。

```text
factor = NUMBER | '(' expression ')';
```

この規則によって`factor`は、

- `NUMBER`
- `(`と`)`に挟まれた`expression`

のどちらかであることを示しています。

### NUMBER

`NUMBER`は数値を表す規則です。

```text
// 数値は1桁の整数に限定
NUMBER = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
```

`NUMBER`は`0`から`9`のどれか1文字であることを示しています。

## BNFを使った解析プロセス

算術式の文法を規則`expression`を含むBNFによって表現することができました。この記述には**曖昧さがなく**、スペースを許さなことや演算子の優先順位などの概念も含まれています。

さて、この規則`expression`を使うと、式`1+2`はどのように解析できるのでしょうか？ここでは、その概要について簡単に説明します。

このBNFを使って解析を行う方法は一意ではなく、様々なやり方（手続き）があります。その個々の手続きがまさに構文解析アルゴリズムとなります。個々の構文解析アルゴリズムについては第5章で詳しく説明しますが、ここでは、BNFを使って**素直に**算術式を解析する方法の概要を説明します。

まず最初にBNFの規則を関数とみなします。たとえば、規則`expression`は関数`expression`に対応し、規則`term`は関数`term`に対応します。これらの規則に対応する関数は、解析したい文字列と文字列の添え字を引数に取り、解析の結果を返します。

この関数の宣言をJavaライクな擬似コードで表すと、以下のようになります。

```java
ParseResult expression(String input, int index);
```

次に関数の呼び出しを構文解析とみなします。引数として解析したい文字列と、解析を開始する位置を渡すと、構文解析結果が返ってくるものとします。

たとえば、`expression("1+2", 0)`という関数呼び出しは、文字列`"1+2"`の先頭から解析を開始することを示します。まだ`expression`の本体がありませんが、結果としては、解析が成功した旨の情報がかえってきて欲しいでしょう。一方、`expression("1+", 0)`という関数呼び出しは、解析が失敗した旨の情報がかえってきて欲しいはずです。

関数の呼び出し結果は、

- 解析に成功した場合：成功したことを表す情報と、どこまで読み進んだかを示す位置（例えば、次の解析を開始すべき入力文字列中のインデックス）。これを`(SUCCESS, new_index)`と表す
- 失敗した場合：失敗を表す定数`FAIL`を返す

のどちらかであるものとします。

この前提を元に実際に`expression("1+2")`を解析してみましょう。

1. 規則`expression`を呼び出す

まず、最上位の規則`expression`を呼び出します。これは`expression("1+2")`となります。

```text
expression = term { ('+' | '-') term }
```

規則の本体では`term`が最初に出現するので、規則`term`を適用します。つまり、`term("1+2")`となります。ここで、`term`の呼び出しから戻った場合に備えて「続き」を次のように記憶しておきます。

```text
Stack: [ 
  expression = term ↑ { ('+' | '-') term }
]
```

この記法では規則とその現在位置を表す記号である`↑`がスタックに積まれていることを示しています。
この解析プロセスをより視覚的に追ってみましょう。

**入力: "1+2"**

1.  **`expression("1+2", 0)` を呼び出し**
    *   現在位置: `^1+2` ( `^` は現在の注目位置)
    *   適用規則: `expression = term { ('+' | '-') term }`
    *   アクション: `term` を解析するために `term("1+2", 0)` を呼び出す。
    *   スタック: `[ expression = .term { ('+' | '-') term } ]` (ドット `.` は現在解析中の位置)

2.  **`term("1+2", 0)` を呼び出し**
    *   現在位置: `^1+2`
    *   適用規則: `term = factor { ('*' | '/') factor }`
    *   アクション: `factor` を解析するために `factor("1+2", 0)` を呼び出す。
    *   スタック: `[ expression = .term ..., term = .factor { ('*' | '/') factor } ]`

3.  **`factor("1+2", 0)` を呼び出し**
    *   現在位置: `^1+2`
    *   適用規則: `factor = NUMBER | '(' expression ')'`
    *   アクション: 入力 "1" は `NUMBER` にマッチするので、`NUMBER("1+2", 0)` を呼び出す (または直接解釈)。
    *   スタック: `[ expression = .term ..., term = .factor ..., factor = .NUMBER ]`

4.  **`NUMBER("1+2", 0)` (または `factor` 内での `NUMBER` の解釈)**
    *   現在位置: `^1+2`
    *   適用規則: `NUMBER = '0' | ... | '9'`
    *   アクション: "1" が `NUMBER` の `'1'` にマッチ。消費し、位置を1進める。
    *   結果: `(SUCCESS, 1)` (消費した文字 "1", 次の位置はインデックス1)
    *   `factor` に戻る。`factor` の解析も成功。

5.  **`term` の解析を続行 (位置1から)**
    *   現在位置: `1^+2`
    *   適用規則: `term = factor . { ('*' | '/') factor }` (factorの解析は終わった)
    *   アクション: 次の入力 `+` は `*` でも `/` でもないため、`{...}` の繰り返しは0回として成功。
    *   結果: `(SUCCESS, 1)` (位置は変わらず)
    *   `expression` に戻る。`expression` の `term` の解析が成功。

6.  **`expression` の解析を続行 (位置1から)**
    *   現在位置: `1^+2`
    *   適用規則: `expression = term . { ('+' | '-') term }`
    *   アクション: 次の入力 `+` は `('+' | '-')` にマッチ。消費し、位置を2進める。次に `term` を解析するために `term("+2", 2)` (実際には `term("1+2", 2)`) を呼び出す。
    *   スタック: `[ expression = term { ('+' | '-') .term } ]`

7.  **`term("1+2", 2)` を呼び出し (入力は実質 "2")**
    *   (同様のプロセスで `NUMBER("2", 2)` が成功し、`(SUCCESS, 3)` が返る)
    *   `term` の `{...}` 部分はマッチせず0回繰り返しで成功。
    *   結果: `(SUCCESS, 3)`
    *   `expression` に戻る。

8.  **`expression` の解析を終了**
    *   現在位置: `1+2^` (入力終端)
    *   適用規則: `expression = term { ('+' | '-') term .}` (2回目のtermの解析が終わった)
    *   アクション: 入力終端なので `{...}` の繰り返しはこれ以上なし。`expression` 全体が成功。
    *   結果: `(SUCCESS, 3)`

このように、BNFの各規則が関数の呼び出しに対応し、入力文字列を消費しながら解析が進んでいく様子がイメージできたでしょうか。

2. 規則`term`を呼び出す

規則`term`は以下のようになっています。

```text
term = factor { ('*' | '/' ) factor }
```

`term`の本体では`factor`が最初に出現するので、規則`factor`を適用します。つまり、`factor("1+2")`となります。

スタックは次のようになります。

```text
Stack: [
  expression = term ↑ { ('+' | '-') term },
  term = factor ↑ { ('*' | '/' ) factor }
]
```

3. 規則`factor`を呼び出す

規則`factor`は以下のようになっています。

```text
factor = NUMBER | '(' expression ')'
```

`factor`の本体は`NUMBER`か`'(' expression ')'`のどちらかですが、`"1+2"`の先頭は`NUMBER`になります。したがって、`NUMBER`を適用します。これは`NUMBER("1+2")`となります。

この時点でのスタックは次のようになります。

```text
Stack: [
  expression = term ↑ { ('+' | '-') term },
  term = factor ↑ { ('*' | '/' ) factor },
  factor = NUMBER ↑
]
```

ここで、`factor = NUMBER ↑`の部分は、つまり「やることは何もない」を意味しているので消去して以下のようにしても同じ意味です。プログラミング言語処理に詳しい方であれば「末尾呼び出しの除去」に相当すると言えばピンと来るかもしれません。

```text
Stack: [
  expression = term ↑ { ('+' | '-') term },
  term = factor ↑ { ('*' | '/' ) factor }
]
```

4. 規則`NUMBER`を適用

規則`NUMBER`は以下のようになっています。

```text
NUMBER = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
```

今、文字列の0番目と規則を照合しようとしているわけですが、`"1+2"`の0番目の文字は`1`です。したがって、`NUMBER`の本体の内、`1`との照合に成功します。

この結果、`NUMBER`の解析は成功し、入力文字列の次の解析開始位置は`+`の直前（インデックスで言えば1）になります。これを`(SUCCESS, 1)`のように表すことにします（ここでは残りの文字列そのものではなく、次の開始位置のインデックスを返すイメージです）。

解析が成功したので、`NUMBER`の呼び出しから戻ります。この時点でのスタックは次のようになっています。

```text
Stack: [
  expression = term ↑ { ('+' | '-') term },
  term = factor ↑ { ('*' | '/' ) factor }
]
```

スタックの一番上の要素をpopしてそこから解析を続行します。

5. 規則`term`の解析を続行

`NUMBER`から戻ってきた先は以下です。

```text
term = factor ↑ { ('*' | '/' ) factor }
```

これを使って解析を続行します。現在の解析位置から始まる文字列は`"+2"`です。この先頭文字`+`は、`'*'`でも`'/'`でもないため、`('*' | '/')`との照合に失敗します。

`{}`で囲まれた部分は0回以上の繰り返しを表し、その中身のパターン（ここでは `('*' | '/') factor`）が入力とマッチしない場合、この繰り返し部分は何も消費せずに（0回の繰り返しとして）成功となります。

したがって、この部分の解析は成功し、解析位置は変わらず、結果は`(SUCCESS, 1)`（先ほどの`NUMBER`解析成功時の次の開始位置）となります。

規則全体の呼び出しが成功し、`term`の呼び出しから戻ります。つまり、スタック

```text
Stack: [
  expression = term ↑ { ('+' | '-') term },
]
```

から要素をpopして、`expression`の解析を続行します。

6. 規則`expression`の解析を続行

`term`の呼び出しから戻ってきた先は以下です。

```text
expression = term ↑ { ('+' | '-') term }
```

現在の解析位置（インデックス1）から始まる文字列は`"+2"`なので、その先頭文字`+`は`('+' | '-')`との照合に成功します。つまり、結果は`(SUCCESS, 2)`です。次に`term`の解析に移ります。

7. 規則`term`を再び呼び出す

```text
expression = term { ('+' | '-') ↑ term }
```

現在の解析位置（インデックス2）から`term`の解析を開始します。つまり、`term("2", 2)`のような呼び出しのイメージです（第1引数は入力全体、第2引数は現在の開始位置）。

そこからは先程と同様に、規則の再帰的な呼び出しを経て、最終的に`NUMBER("2", 2)`で`NUMBER`の解析が成功し、入力文字列の終端に達するので、結果は`(SUCCESS, 3)`（3は終端の次の位置）となります。

8. 規則`expression`の解析を終了

7.が終わった時点で規則の以下の位置にいます。

```text
expression = term { ('+' | '-') term ↑}
```

ここでもう一回「繰り返す」かが問題ですが、既に入力文字列の終端に達しています。したがって、

```text
expression = term { ('+' | '-') term } ↑
```

のように`expression`の解析全体が成功し、`(SUCCESS, 3)`となります。

これが最終結果になるので、規則`expression`と文字列`1+2`はマッチすることがわかります。

## BNFと解析結果

算術式の文法をBNFで表現し、実際に算術式を表す文字列と照合することができました。

しかし、これでは文字列が与えられたBNFにマッチするかどうかの判定しかできません。

皆さんおなじみのJSONがそうであるように、実用的には解析した結果を何らかのデータ構造に変換して格納しておく必要があります。

次の節では、BNFで表現された算術式を解析し、その結果を抽象構文木というデータ構造に変換する方法について説明します。

## 抽象構文木

抽象構文木とは何でしょうか？今、私達が欲しいのは

- 空白や括弧といった余分な情報が含まれず
- 演算子の優先順位を表現できる

ような構造です。**抽象構文木**（Abstract Syntax Tree）は、そのようなニーズを満たすデータ構造です。

抽象構文木は一般には任意個の子を持つ多分木として表現されます。

たとえば、`1 + 2 * 3`という算術式の抽象構文木は以下のようになります。

![](img/chapter2/ast1.svg){ width=50% }

抽象構文木の各ノードは、プログラムの構造を表現するためのデータ構造です。たとえば、`+`ノードは足し算を表し、`1`ノードは整数の`1`を表します。

抽象構文木（AST）では、各ノードはプログラムの構成要素を表し、親子関係によって演算子とオペランドの関係性を示します。抽象構文木には次のようなノードがあります。

### 内部ノード

演算子や制御構造など、他のノードを子として持つノードです。

先程の例でいうと、`+`ノードと`*`ノードが内部ノードです。

### 葉ノード

子を持たないノードです。例えば、`1`や`2`、`3`といった数値は葉ノードとなります。

一般的には、リテラルや変数など、それ以上分解できない最小単位のノードが葉ノードとなります。

### 根ノード

抽象構文木の最上位に位置するノードです。抽象構文木の根となるノードであり、プログラム全体を表します。数式の例でいえば、全体を表す`+`ノードが根ノードとなります。

内部ノードと根ノードは排他でないことに注意してください。たとえば、`+`ノードは内部ノードであり、同時に根ノードでもあります。

### 優先順位

改めて、先程の抽象構文木を見てみましょう。

![](img/chapter2/ast1.svg){ width=50% }

この木構造では、`+`がルートノードであり、その左の子が`1`、右の子が`*`です。`*`ノードの子として`2`と`3`が配置されています。これにより、演算の優先順位が明確に表現されるわけです。

この抽象構文木を見れば、`1 + (2 * 3)` という演算順序が表現されており、`(1 + 2) * 3` のような異なる解釈にはならないことが直感的に理解できるでしょう。

### 抽象構文木をJavaで表現する

抽象構文木は視覚的な表現としても便利ですが、その真価はプログラム上で表現・処理することにあります。ここではJavaで表現する方法を紹介します。

```java
// 式を表すインタフェース
sealed interface Exp permits Add, Sub, Mul, Div, Num {}
// 加算を表すレコード
record Add(Exp lhs, Exp rhs) implements Exp {}
// 減算を表すレコード
record Sub(Exp lhs, Exp rhs) implements Exp {}
// 乗算を表すレコード
record Mul(Exp lhs, Exp rhs) implements Exp {}
// 除算を表すレコード
record Div(Exp lhs, Exp rhs) implements Exp {}
// 数値を表すレコード
record Num(int value) implements Exp {}
```

インタフェース`Exp`は、抽象構文木のノードを表すインタフェースです。

`Add`、`Sub`、`Mul`、`Div`、`Num`は、それぞれ加算、減算、乗算、除算、数値を表すレコードです。これによって、抽象構文木をJavaで表現することができます。

試しに`1 + 2 * 3`の抽象構文木をJavaで表現してみましょう。

```java
// 1 + 2 * 3
Exp exp = new Add(
  new Num(1), new Mul(new Num(2), new Num(3))
);
```

各クラスのインスタンスを作成することで、抽象構文木を表現することができます。

### 抽象構文木を評価する

抽象構文木を作成するだけでは、プログラムの実行結果を得ることはできません。抽象構文木を評価するためには、再帰的な処理を行うことが必要です。抽象構文木を辿りながら、各ノードの演算を行うことで、プログラムの実行結果を得ることができます。

以下は、算術式の抽象構文木を評価するJavaのコード例です。

```java
int eval(Exp e) {
  return switch(e){
    case Num t -> t.value();
    case Add t -> eval(t.lhs()) + eval(t.rhs());
    case Sub t -> eval(t.lhs()) - eval(t.rhs());
    case Mul t -> eval(t.lhs()) * eval(t.rhs());
    case Div t -> {
      int divisor = eval(t.rhs()); // 先に右辺を評価
      if(divisor == 0) { // 評価結果でゼロチェック
        throw new ArithmeticException("division by zero");
      }
      yield eval(t.lhs()) / divisor; // 左辺を評価して除算
    }
  };
}
```

ノードの種類に応じてswitch式で処理を分岐しています。
- `Num`ノードの場合: 格納されている数値 `t.value()` をそのまま返します。これが再帰のベースケースとなります。
- `Add`ノードの場合: 左の子 `t.lhs()` と右の子 `t.rhs()` をそれぞれ再帰的に `eval` し、その結果を足し算します。
- `Sub`、`Mul`ノードの場合: `Add` と同様に、左右の子を再帰的に評価し、それぞれの演算を行います。
- `Div`ノードの場合: まず右の子（除数）を `eval` し、その結果が0であれば `ArithmeticException` をスローします。0でなければ、次に左の子（被除数）を `eval` し、除算の結果を返します。ゼロ除算チェックは、実際の計算を行う前に行うことが重要です。また、`eval(t.rhs())` を2回呼び出すのを避けるため、一度評価した結果を変数に格納しています。

この`eval`メソッドの動作を `1 + 2 * 3` の抽象構文木 `new Add(new Num(1), new Mul(new Num(2), new Num(3)))` で追ってみましょう。

1.  `eval(new Add(new Num(1), new Mul(new Num(2), new Num(3))))` が呼び出される。
2.  `Add`ケースにマッチ。
    1.  `eval(t.lhs())` つまり `eval(new Num(1))` が呼び出される。
        *   `Num`ケースにマッチ。`1` を返す。
    2.  `eval(t.rhs())` つまり `eval(new Mul(new Num(2), new Num(3)))` が呼び出される。
        *   `Mul`ケースにマッチ。
            1.  `eval(t.lhs())` つまり `eval(new Num(2))` が呼び出される。
                *   `Num`ケースにマッチ。`2` を返す。
            2.  `eval(t.rhs())` つまり `eval(new Num(3))` が呼び出される。
                *   `Num`ケースにマッチ。`3` を返す。
            3.  `2 * 3` の結果である `6` を返す。
    3.  `1 + 6` の結果である `7` を返す。

このように、抽象構文木を再帰的に辿ることで、式の評価が実現されます。`Div` の場合のゼロ除算エラー処理は、プログラムの実行時エラーを防ぐために不可欠です。他の演算（`Add`, `Sub`, `Mul`）では、Javaの整数演算がオーバーフローする可能性はありますが、`ArithmeticException` のような実行時例外を直接引き起こす「不正な演算」は（ゼロ除算ほど明確には）定義されていないため、ここでは特にエラー処理を加えていません（もちろん、より堅牢な電卓を作る場合はオーバーフロー検知なども考慮に入れるべきです）。

この`eval`メソッドを使うことで、次のように抽象構文木を評価することができます。

```java
// 1 + 2 * 3
Exp exp = new Add(
  new Num(1), new Mul(new Num(2), new Num(3))
);
eval(exp); // 7
```

抽象構文木をデータとして表現することで、プログラムの構造を簡単に解析することができるのです。

## まとめ

この章では、算術式の文法を例題としてBNFについて紹介し、BNFに基づいて算術式を解析する方法の概要について説明しました。また、抽象構文木についても紹介し、抽象構文木をJavaで表現する方法と、抽象構文木を評価する方法について説明しました。

しかし、今のままではBNFに基づく「構文解析器」は与えられた文字列が文法にマッチするかどうかを判定するだけで、抽象構文木を生成することができません。次章では、ここで学んだBNFの考え方を応用して、実際にJavaで動作するJSONの構文解析器を実装し、JSONの抽象構文木を生成する方法について詳しく説明します。

[^1]: 翻訳: ISO/IEC 14977:1996 Information technology — Syntactic metalanguage — Extended BNF https://hazm.at/mox/lang/meta-language/ebnf/iso-iec-14977-extended-bnf/index.html
