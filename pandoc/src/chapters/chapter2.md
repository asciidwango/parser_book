
# 第2章 構文解析の基本

この章からいよいよ構文解析についての説明を始めたいと思います。とはいっても本書を手に取った皆様は構文解析についてまだ馴染みがないかと思います。そこで、まずは簡単な算術式の構文解析を例にして、構文解析の基本について学ぶことにしましょう。

算術式という言い方は堅苦しいですが、要は数式のことです。たとえば、`1 + 2`や`(1 + 2) * 3`、`(3 * 3) * (2 * 3)`のようなものです。プログラマーの皆さんなら普段、日常的にプログラムの一部として算術式を書いているでしょう。算術式は非常にシンプルな「言語」なので、構文解析の題材にするのに最適なのです。

## 算術式の文法

ただ「算術式」といっただけだと人によってかなりイメージするものが異なります。本書では以下の条件を満たすものを算術式とします。

- 四則演算ができる
  - 足し算は`x+y`
  - 引き算は`x-y`
  - 掛け算は`x*y`
  - 割り算は`x/y`
- 優先順位は掛け算・割り算が高く、足し算・引き算が低い
  - `1+2*3`は`1+(2*3)`と解釈される
  - `7-6/2`は`7-(6/2)`と解釈される
- 掛け算・割り算の優先順位は同じで、足し算・引き算の優先順位も同じ
- 優先順位が同じ演算子は左から右に結びつく
  - `1+2-3`は`(1+2)-3`と解釈される
- 値は整数のみ
  - `1+2.0`のような式はエラーになる
- 式の優先順位を変えるために括弧を使うことができる
  - `1+2*3`は`1+(2*3)`の意味になるが、`(1+2)*3`と書くことで意味が変わる
- スペースは使えない
  - `1+2`はOKだが、`1 + 2`はエラーになる

最後の「スペースは使えない」という制限はあくまで単純化のためです。特に、字句解析（文字列を意味のある単位、トークンに分割する処理）を単純化し、構文解析の核となる考え方に集中するために設けています。実際の算術式ではスペースも使えて無視されるのが一般的ですが、その処理は後の章で触れることにします。

この定義に従う算術式には以下のようなものが含まれます。

```text
100  # 100
1+2*3  # 7
(1+2)*3  # 9
3*(1+2)  # 9
12/3  # 4
1+3*4/2  # 7
```

皆さんは何かしらのプログラミング言語を使ってプログラムを書いているはずですから、上のような算術式は馴染みが深いはずです。

しかし、上のような日本語を使った定義だけでは算術式の文法を表現するのには不十分です。たとえば「式の優先順位を変えるために括弧を使うことができる」といっても、なんとなくはわかるものの、定義としては曖昧です。もちろん、日本語で詳しく記述して曖昧さを少なくしていくこともできますが、いたずらに長くなるだけです。

曖昧さがない形で文法を表現するために、特別な記法を使うことが一般的です。これを**形式文法**と呼びます。「形式文法」という名前は堅苦しく聞こえるかもしれませんが、要は「プログラミング言語の文法を書くための、決まった書き方」のことです。

たとえば、皆さんがJavaのメソッドを書く時にも決まった形式があるように（例：`public void methodName() { ... }`）、プログラミング言語の文法そのものを記述する時にも決まった形式があるのです。

次節では、そのような形式文法の中でも最も広く使われているBNF（Backus-Naur Form、バッカス・ナウア記法）を使って、算術式の文法を表現してみましょう。BNFは、プログラミング言語の仕様書やドキュメントでよく見かける記法です。

## 算術式のBNF

プログラミング言語の文法自体を表現する文法（メタ文法といいます）の一つに、BNFがあります。BNFは、プログラミング言語の文法をはじめ、インターネット上でのメッセージ交換フォーマットなど、様々な文法を表現するのに使われています。本書の読者の方にはBNFに馴染みのない方も多いと思うので、算術式のBNFの前にBNFについて説明します。本書では、記述を簡潔にするため、ISO/IEC 14977で仕様が策定されたEBNF[^1]で用いられる繰り返し（`{}`）、オプション（`[]`）、グループ化（`()`）といった拡張記法を一部取り入れ、これを広義のBNFとして扱います。BNFには歴史的に多くの方言が存在するため、本書で用いる記法について事前に説明しておきます。

### BNFの概要

BNFはFortranの開発者でもある、John Backus（ジョン・バッカス）らが開発した記法です。BNFは「プログラミング言語」そのものの文法を記述するために開発されました。基本情報技術者試験でも出題されるので、そこで知った方もおられるかもしれません。

本書で用いる広義のBNF（EBNFの要素を取り入れたもの）の主要な記法は以下の通りです。

*   `=` : 左辺の非終端記号と右辺の定義を区切ります。
*   `|` : 選択を表します。例えば `A | B` は「AまたはB」を意味します。
*   `{}` : 0回以上の繰り返しを表します。例えば `A {B}` は「Aの後にBが0回以上続く」ことを意味します。
*   `[]` : 0回または1回の出現（オプション）を表します。例えば `[A] B` は「Aがあるかもしれないし、ないかもしれないが、その後にBが続く」ことを意味します。
*   `()` : グループ化を表します。例えば `(A | B) C` は「AまたはBの後にCが続く」ことを意味します。
*   `'...'` または `"`...`"` : 終端記号（リテラル文字列）を表します。
*   非終端記号（例: `expr`, `term`）: 他の規則で定義される記号を表します。

では早速、BNFの具体例を見て行きましょう。以下の例は2.1で出てきた算術式を元に、

- 扱える数値は一桁だけ

のように単純化したBNFです。

```bnf
expr = term { ('+' | '-') term };
term = factor { ('*' | '/') factor };
factor = NUMBER | '(' expr ')';
NUMBER = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
```

たくさんの記号が出てきて戸惑われたかもしれませんが、一つずつ丁寧に見ていきましょう。

### expr

BNFでは、以下のような**生成規則**の集まりによって、文法を表現します。

 ```
expr = term { ('+' | '-') term };
 ```

`=`の左側である`expr`が**左辺**（この規則で定義される非終端記号）で、右側が**右辺**（その定義）になります。

ここでは 

```
term { ('+' | '-' ) term }
```

が本体になります。

本体の中に出てくる、他の規則を参照する部分（ここでは`term`)を**非終端記号**と呼びます。これは「まだ展開の余地がある記号」という意味で、同じBNF内で定義されている他の非終端記号と一致する必要があります。Javaでいえば、メソッド呼び出しのようなものです。

一方、`'+'`や`'-'`のように`'`で囲まれた記号や文字を**終端記号**と呼びます。これは「これ以上展開できない、最終的な文字」という意味で、実際にプログラムに書かれる文字そのものを表します。Javaでいえば、`+`演算子や`;`セミコロンのようなものです。

BNFにおいて`{}`で囲まれたものは、その中の要素が0回以上繰り返して出現することを示しています。したがって、

```
term { ('+' | '-') term }
```

という記述は、まず`term`が出現し、その後に「`+`または`-`とそれに続く`term`」が0回以上繰り返して出現することを示しています。0回以上という言い方が重要です。というのは、`term`が1回だけ出現してその後は何も出現しない場合もあるからです。たとえば、`1`という式はこの規則にマッチしますが、`{}`で囲まれた部分は出現していません。
  
この生成規則を日本語で表現すると「`expr`という非終端記号は、右辺の定義 `term { ('+' | '-') term }` によって定義される」と読むことができます。

なお、本来の（ISO/IEC）BNFでは

```
expr = term, { ('+' | '-'), term };
```

のように要素間をカンマで区切りますが、本書では可読性を考慮してスペースで区切るようにしています。

### term

`term` は算術式の中で、掛け算や割り算を含んだ式を表す規則です。`factor`という規則を参照しています。

```text
term = factor { ('*' | '/') factor };
```

この規則によって`term`は、`factor`が`*`または`/`を挟んで0回以上繰り返して出現することを示しています。

### factor

`factor`は算術式の中で、数値や括弧で囲まれた式を表す規則です。

```text
factor = NUMBER | '(' expr ')';
```

この規則によって`factor`は、

- `NUMBER`
- `(`と`)`に挟まれた`expr`

のどちらかであることを示しています。

### NUMBER

`NUMBER`は数値を表す規則です。ここでは単純化のために1桁の整数のみを扱っています。

```text
NUMBER = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
```

`NUMBER`は`0`から`9`のどれか1文字であることを示しています。

## BNFを使った解析プロセス

算術式の文法を規則`expr`を含むBNFによって表現することができました。この記述には**曖昧さがなく**、スペースを許さないことや演算子の優先順位などの概念も含まれています。

この規則`expr`を使うと、式`1+2`はどのように解析できるのでしょうか？ここでは、その概要について簡単に説明します。

このBNFを使って解析を行う方法は一意ではなく、様々なやり方（手続き）があります。その個々の手続きがまさに構文解析アルゴリズムとなります。個々の構文解析アルゴリズムについては第5章で詳しく説明しますが、ここでは、BNFを使って**素直に**算術式を解析する方法の概要を説明します。ちなみに、構文解析に限った話ではありませんが、そのような**素直な**方法のことをナイーブ（naive）な方法と呼ぶことがあります。

まず最初にBNFの規則を関数とみなします。たとえば、規則`expr`は関数`expr`に対応し、規則`term`は関数`term`に対応します。これらの規則に対応する関数は、解析したい文字列を引数に取り、解析の結果を返します。

この関数の宣言をJavaライクな擬似コードで表すと、以下のようになります。

```java
ParseResult expr(String input);
```

次に関数の呼び出しを構文解析とみなします。引数として解析したい文字列を渡すと、構文解析結果が返ってくるものとします。

たとえば、`expr("1+2")`という関数呼び出しは、文字列`"1+2"`を解析することを示します。まだ`expr`の本体がありませんが、結果としては、解析が成功した旨の情報がかえってきて欲しいでしょう。一方、`expr("1+")`という関数呼び出しは、解析が失敗した旨の情報がかえってきて欲しいはずです。

関数の呼び出し結果は、

- 解析に成功した場合：成功したことを表す情報と、まだ解析していない残りの文字列。これを`(SUCCESS, remaining_string)`と表す
- 失敗した場合：失敗を表す定数`FAIL`を返す

のどちらかであるとします。

以上の前提を元に、実際に`expr("1+2")`がどのように解析されるか、主要なポイントを追ってみましょう。詳細な内部動作は省略し、重要な部分に焦点を当てて説明します。

### 解析の流れ

`expr("1+2")`の解析がどのように進むか、主要なポイントを見てみましょう：

**1. 最初の数字「1」の解析**
- `expr`は`term`を呼び出し、`term`は`factor`を、`factor`は`NUMBER`を呼び出します
- `NUMBER`は先頭の`"1"`がマッチするので、`1`を消費して`(SUCCESS, "+2")`を返します
- この結果が`factor`、`term`を経由して`expr`まで戻ってきます

**2. 演算子「+」の処理**
- `expr`の定義 `term { ('+' | '-') term }` に従い、`+`が`('+' | '-')`にマッチします
- `+`を消費して、残りは`"2"`になります

**3. 次の数字「2」の解析**
- 再び`term`→`factor`→`NUMBER`と呼び出されます
- `NUMBER`は`"2"`にマッチし、`2`を消費して`(SUCCESS, "")`を返します
- 入力が空になったので、解析は成功です

### 重要なポイント

この解析プロセスで注目すべき点は：

- **再帰的な構造**: `expr`→`term`→`factor`→`NUMBER`という呼び出しの連鎖
- **文字の消費**: マッチした文字を消費しながら、残りの文字列を次の解析に渡す
- **繰り返しの処理**: `{ }`で囲まれた部分は0回以上繰り返される
- **優先順位の実現**: 文法の階層構造により、自然に演算子の優先順位が守られる

このような再帰的な解析手法は「再帰下降構文解析」と呼ばれ、BNFの構造をそのままプログラムに反映できる直感的な方法です。

## なぜこのBNFで演算子の優先順位を表現できるのか

BNFを使った素直な解析プロセスを理解したところで、重要な疑問に答えましょう。「なぜこのように書くと、掛け算・割り算が足し算・引き算より優先されるのか？」ということです。

その答えは、**文法の階層構造**にあります。BNFを改めて見てみましょう：

```text
expr = term { ('+' | '-') term };
term = factor { ('*' | '/') factor };
factor = NUMBER | '(' expr ')';
```

この文法では、次のような階層関係があります：

1. `expr`（最上位）: 足し算・引き算を扱う
2. `term`（中間層）: 掛け算・割り算を扱う  
3. `factor`（最下位）: 数値や括弧で囲まれた式を扱う

### 優先順位が実現される仕組み

式 `1+2*3` を例に、なぜ `*` が `+` より先に処理されるかを見てみましょう。

1. `expr`から解析を開始
  - `expr`は`term`を呼び出す
  - この時点では`+`や`-`を探すが、まだ`term`の解析中

2. `term`の解析
  - `term`は`factor`（ここでは`1`）を解析
  - 次の文字が`+`なので、`*`や`/`ではない
  - したがって`term`の解析は`1`で終了し、`expr`に戻る

3. `expr`の続き
  - `+`を見つけて消費
  - 次の`term`（`2*3`の部分）を解析

4. 2番目の`term`の解析
  - `factor`（`2`）を解析
  - 次が`*`なので、`term`の繰り返し部分が適用される
  - `*`を消費して、次の`factor`（`3`）を解析
  - `term`全体として`2*3`がひとまとまりになる

この結果、抽象構文木は以下のようになります：

```{=latex}
\begin{center}
\begin{tikzpicture}[
  level distance=1.5cm,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=2cm},
  every node/.style={circle, draw, minimum size=8mm}
]
  \node {+}
    child {node {1}}
    child {node {*}
      child {node {2}}
      child {node {3}}
    };
\end{tikzpicture}
\end{center}
```

### もし文法の階層が逆だったら？

以下のような**誤った**文法を書いたとしましょう：

```text
// 誤った文法（優先順位が逆）
expr = factor { ('*' | '/') factor };
factor = term { ('+' | '-') term };
term = NUMBER | '(' expr ')';
```

この場合、`1+2*3`は`(1+2)*3`として解析されてしまいます。なぜなら、以下のような解析手順になるからです：

1. `expr`が最初に`*`や`/`を探す
2. `factor`で`1+2`全体が先に処理される
3. その後で`*3`が処理される

### 文法設計の原則

演算子の優先順位を正しく表現するための原則は以下のようになります：

1. 優先順位の低い演算子ほど上位の規則で扱う
  - `+`, `-`は最上位の`expr`で
  - `*`, `/`は中間の`term`で

2. 同じ優先順位の演算子は同じ規則内で扱う
  - `+`と`-`は同じ`expr`内
  - `*`と`/`は同じ`term`内

3. 左結合性は繰り返しで表現
  - `{...}`による繰り返しが左から右への結合を実現

このような階層構造により、パーサーは自然に演算子の優先順位を守りながら解析を進めることができるのです。

## 抽象構文木

これまで、算術式の文法をBNFで表現し、実際に算術式を表す文字列と照合することができました。しかし、これでは文字列が与えられたBNFにマッチするかどうかの判定しかできません。

皆さんおなじみのJSONがそうであるように、実用的には解析した結果を何らかのデータ構造に変換して格納しておく必要があります。そのためのデータ構造が**抽象構文木**（Abstract Syntax Tree）です。

抽象構文木とは何でしょうか？今、私達が欲しいのは

- 空白や括弧といった余分な情報が含まれず
- 演算子の優先順位を表現できる

ような構造です。**抽象構文木**（Abstract Syntax Tree）は、そのようなニーズを満たすデータ構造です。

抽象構文木は一般には任意個の子を持つ多分木として表現されます。

たとえば、`1 + 2 * 3`という算術式の抽象構文木は以下のようになります。

```{=latex}
\begin{center}
\begin{tikzpicture}[
  level distance=1.5cm,
  sibling distance=2cm,
  every node/.style={circle,draw,minimum size=0.8cm},
  root/.style={fill=gray!50},
  internal/.style={fill=brown!50},
  leaf/.style={fill=green!30}
]
  \node[root] {+}
    child { node[leaf] {1} }
    child { node[internal] {*}
      child { node[leaf] {2} }
      child { node[leaf] {3} }
    };
\end{tikzpicture}
\end{center}
```

抽象構文木の各ノードは、プログラムの構造を表現するためのデータ構造です。たとえば、`+`ノードは足し算を表し、`1`ノードは整数の`1`を表します。

抽象構文木（AST）では、各ノードはプログラムの構成要素を表し、親子関係によって演算子とその演算対象（オペランド）の関係性を示します。例えば、`1 + 2`という式では、`+`が演算子、`1`と`2`がオペランドです。抽象構文木には次のようなノードがあります。

### 内部ノード

演算子や制御構造など、他のノードを子として持つノードです。
先程の例でいうと、`+`ノードと`*`ノードが内部ノードです。

BNFの観点から言えば、内部ノードは主に生成規則の右辺に対応します。

### 葉ノード

子を持たないノードです。例えば、`1`や`2`、`3`といった数値は葉ノードとなります。
一般的には、リテラルや変数など、それ以上分解できない最小単位のノードが葉ノードとなります。

BNFの観点から言えば、葉ノードは終端記号（`'1'`、`'+'`など）に対応します。終端記号はそれ以上分解できない最終的な要素であり、それが抽象構文木の葉ノードになるわけです。

### 根ノード

抽象構文木の最上位に位置するノードです。抽象構文木の根となるノードであり、プログラム全体を表します。数式の例でいえば、全体を表す`+`ノードが根ノードとなります。
内部ノードと根ノードは排他でないことに注意してください。たとえば、`+`ノードは内部ノードであり、同時に根ノードでもあります。

### 優先順位

改めて、先程の抽象構文木を見てみましょう。

```{=latex}
\begin{center}
\begin{tikzpicture}[
  level distance=1.5cm,
  sibling distance=2cm,
  every node/.style={circle,draw,minimum size=0.8cm},
  root/.style={fill=gray!50},
  internal/.style={fill=brown!50},
  leaf/.style={fill=green!30}
]
  \node[root] {+}
    child { node[leaf] {1} }
    child { node[internal] {*}
      child { node[leaf] {2} }
      child { node[leaf] {3} }
    };
\end{tikzpicture}
\end{center}
```

この木構造では、`+`がルートノードであり、その左の子が`1`、右の子が`*`です。`*`ノードの子として`2`と`3`が配置されています。これにより、演算の優先順位が明確に表現されるわけです。

この抽象構文木を見れば、`1 + (2 * 3)` という演算順序が表現されており、`(1 + 2) * 3` のような異なる解釈にはならないことが直感的に理解できるでしょう。

### 抽象構文木をJavaで表現する

抽象構文木は視覚的な表現としても便利ですが、その真価はプログラム上で表現・処理することにあります。ここではJavaで表現する方法を紹介します。

```java
// 式を表すインタフェース
sealed interface Exp permits Add, Sub, Mul, Div, Num {}
// 加算を表すレコード
// lhs: left-hand side（左辺）、rhs: right-hand side（右辺）
record Add(Exp lhs, Exp rhs) implements Exp {}
// 減算を表すレコード
record Sub(Exp lhs, Exp rhs) implements Exp {}
// 乗算を表すレコード
record Mul(Exp lhs, Exp rhs) implements Exp {}
// 除算を表すレコード
record Div(Exp lhs, Exp rhs) implements Exp {}
// 数値を表すレコード
record Num(int value) implements Exp {}
```

インタフェース`Exp`は、抽象構文木のノードを表すインタフェースです。

`Add`、`Sub`、`Mul`、`Div`、`Num`は、それぞれ加算、減算、乗算、除算、数値を表すレコードです。これによって、抽象構文木をJavaで表現することができます。

試しに`1 + 2 * 3`の抽象構文木をJavaで表現してみましょう。

```java
// 1 + 2 * 3
Exp exp = new Add(
  new Num(1), new Mul(new Num(2), new Num(3))
);
```

各クラスのインスタンスを作成することで、抽象構文木を表現することができます。

### 抽象構文木を評価する

ここまでは構文解析の話をしてきましたが、構文解析が完了して抽象構文木が得られると、その先にはどのような可能性が広がるのでしょうか。実は、抽象構文木さえ作ってしまえば、それを活用して様々なことができるようになります。その一例として、ここでは抽象構文木を「評価」して計算結果を得る方法を紹介します。

抽象構文木を作成するだけでは、プログラムの実行結果を得ることはできません。抽象構文木を評価するためには、再帰的な処理を行うことが必要です。抽象構文木を辿りながら、各ノードの演算を行うことで、プログラムの実行結果を得ることができます。

以下は、算術式の抽象構文木を評価するJavaのコード例です。

```java
int eval(Exp e) {
  return switch(e){
    case Num t -> t.value();
    case Add t -> eval(t.lhs()) + eval(t.rhs());
    case Sub t -> eval(t.lhs()) - eval(t.rhs());
    case Mul t -> eval(t.lhs()) * eval(t.rhs());
    case Div t -> {
      int divisor = eval(t.rhs()); // 先に右辺を評価
      if(divisor == 0) { // 評価結果でゼロチェック
        throw new ArithmeticException("division by zero");
      }
      yield eval(t.lhs()) / divisor; // 左辺を評価して除算
    }
  };
}
```

ノードの種類に応じてswitch式で処理を分岐しています：

- `Num`ノードの場合: 格納されている数値 `t.value()` をそのまま返します。これが再帰のベースケースとなります。
- `Add`ノードの場合: 左の子 `t.lhs()` と右の子 `t.rhs()` をそれぞれ再帰的に `eval` し、その結果を足し算します。
- `Sub`、`Mul`ノードの場合: `Add` と同様に、左右の子を再帰的に評価し、それぞれの演算を行います。
- `Div`ノードの場合: まず右の子（除数）を `eval` し、その結果が0であれば `ArithmeticException` をスローします。0でなければ、次に左の子（被除数）を `eval` し、除算の結果を返します。ゼロ除算チェックは、実際の計算を行う前に行うことが重要です。また、`eval(t.rhs())` を2回呼び出すのを避けるため、一度評価した結果を変数に格納しています。

この`eval`メソッドの動作を `1 + 2 * 3` の抽象構文木 `new Add(new Num(1), new Mul(new Num(2), new Num(3)))` で追ってみましょう。

- `eval(new Add(new Num(1), new Mul(new Num(2), new Num(3))))` が呼び出される。
  - `Add`ケースにマッチ。
  - `eval(t.lhs())` つまり `eval(new Num(1))` が呼び出される。
    - `Num`ケースにマッチ。`1` を返す。
  - `eval(t.rhs())` つまり `eval(new Mul(new Num(2), new Num(3)))` が呼び出される。
    - `Mul`ケースにマッチ。
    - `eval(t.lhs())` つまり `eval(new Num(2))` が呼び出される。
      - `Num`ケースにマッチ。`2` を返す。
    - `eval(t.rhs())` つまり `eval(new Num(3))` が呼び出される。
      - `Num`ケースにマッチ。`3` を返す。
    - `2 * 3` の結果である `6` を返す。
  - `1 + 6` の結果である `7` を返す。

このように抽象構文木を再帰的に辿ることで、式の評価が実現されます。`Div` の場合のゼロ除算エラー処理は、プログラムの実行時エラーを防ぐために不可欠です。他の演算（`Add`, `Sub`, `Mul`）では、Javaの整数演算がオーバーフローする可能性はありますが、`ArithmeticException` のような実行時例外を直接引き起こす「不正な演算」は（ゼロ除算ほど明確には）定義されていないため、ここでは特にエラー処理を加えていません（もちろん、より堅牢な電卓を作る場合はオーバーフロー検知なども考慮に入れるべきです）。

`eval`メソッドを使うことで、次のように抽象構文木を評価することができます。

```java
// 1 + 2 * 3
Exp exp = new Add(
  new Num(1), new Mul(new Num(2), new Num(3))
);
eval(exp); // 7
```

抽象構文木をデータとして表現することで、プログラムの構造を簡単に解析することができるのです。

## まとめ

この章では、算術式の文法を例題としてBNFについて紹介し、BNFに基づいて算術式を解析する方法の概要について説明しました。また、抽象構文木についても紹介し、抽象構文木をJavaで表現する方法と、抽象構文木を評価する方法について説明しました。

しかし、今のままではBNFに基づく「構文解析器」は与えられた文字列が文法にマッチするかどうかを判定するだけで、抽象構文木を生成することができません。次章では、ここで学んだBNFの考え方を応用して、実際にJavaで動作するJSONの構文解析器を実装し、JSONの抽象構文木を生成する方法について詳しく説明します。

[^1]: 翻訳: ISO/IEC 14977:1996 Information technology — Syntactic metalanguage — Extended BNF https://hazm.at/mox/lang/meta-language/ebnf/iso-iec-14977-extended-bnf/index.html