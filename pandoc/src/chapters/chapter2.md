
# 第2章 構文解析の基本

この章からいよいよ構文解析についての説明を始めたいと思います。とはいっても本書を手に取った皆様は構文解析についてまだ馴染みがないかと思います。そこで、まずは簡単な算術式の構文解析を例にして、構文解析の基本について学ぶことにしましょう。

算術式という言い方は堅苦しいですが、要は数式のことです。たとえば、`1 + 2`や`(1 + 2) * 3`、`(3 * 3) * (2 * 3)`のようなものです。プログラマーの皆さんなら普段、日常的にプログラムの一部として算術式を書いているでしょう。算術式は非常にシンプルな「言語」なので、構文解析の題材にするのに最適なのです。

## 算術式の文法

ただ「算術式」といっただけだと人によってかなりイメージするものが異なります。本書では以下の条件を満たすものを算術式とします。

- 四則演算ができる
  - 足し算は`x+y`
  - 引き算は`x-y`
  - 掛け算は`x*y`
  - 割り算は`x/y`
- 優先順位は掛け算・割り算が高く、足し算・引き算が低い
  - `1+2*3`は`1+(2*3)`と解釈される
  - `7-6/2`は`7-(6/2)`と解釈される
- 掛け算・割り算の優先順位は同じで、足し算・引き算の優先順位も同じ
- 優先順位が同じ演算子は左から右に結びつく
  - `1+2-3`は`(1+2)-3`と解釈される
- 値は整数のみ
  - `1+2.0`のような式はエラーになる
- 式の優先順位を変えるために括弧を使うことができる
  - `1+2*3`は`1+(2*3)`の意味になるが、`(1+2)*3`と書くことで意味が変わる
- スペースは使えない
  - `1+2`はOKだが、`1 + 2`はエラーになる

最後の「スペースは使えない」という制限はあくまで単純化のためです。特に、字句解析（文字列を意味のある単位、トークンに分割する処理）を単純化し、構文解析の核となる考え方に集中するために設けています。実際の算術式ではスペースも使えて無視されるのが一般的ですが、その処理は後の章で触れることにします。

この定義に従う算術式には以下のようなものが含まれます。

```text
100  # 100
1+2*3  # 7
(1+2)*3  # 9
3*(1+2)  # 9
12/3  # 4
1+3*4/2  # 7
```

皆さんは何かしらのプログラミング言語を使ってプログラムを書いているはずですから、上のような算術式は馴染みが深いはずです。

しかし、上のような日本語を使った定義だけでは算術式の文法を表現するのには不十分です。たとえば「式の優先順位を変えるために括弧を使うことができる」といっても、なんとなくはわかるものの、定義としては曖昧です。もちろん、日本語で詳しく記述して曖昧さを少なくしていくこともできますが、いたずらに長くなるだけです。

曖昧さがない形で文法を表現するために、特別な記法を使うことが一般的です。これを**形式文法**と呼びます。「形式文法」という名前は堅苦しく聞こえるかもしれませんが、要は「プログラミング言語の文法を書くための、決まった書き方」のことです。

たとえば、皆さんがJavaのメソッドを書く時にも決まった形式があるように（例：`public void methodName() { ... }`）、プログラミング言語の文法そのものを記述する時にも決まった形式があるのです。

次節では、そのような形式文法の中でも最も広く使われているBNF（Backus-Naur Form、バッカス・ナウア記法）を使って、算術式の文法を表現してみましょう。BNFは、プログラミング言語の仕様書やドキュメントでよく見かける記法です。

## 算術式のBNF

プログラミング言語の文法自体を表現する文法（メタ文法といいます）の一つに、BNFがあります。BNFは、プログラミング言語の文法をはじめ、インターネット上でのメッセージ交換フォーマットなど、様々な文法を表現するのに使われています。本書の読者の方にはBNFに馴染みのない方も多いと思うので、算術式のBNFの前にBNFについて説明します。本書では、記述を簡潔にするため、ISO/IEC 14977で仕様が策定されたEBNF[^1]で用いられる繰り返し（`{}`）、オプション（`[]`）、グループ化（`()`）といった拡張記法を一部取り入れ、これを広義のBNFとして扱います。BNFには歴史的に多くの方言が存在するため、本書で用いる記法について事前に説明しておきます。

### BNFの概要

BNFはFortranの開発者でもある、John Backus（ジョン・バッカス）らが開発した記法です。BNFは「プログラミング言語」そのものの文法を記述するために開発されました。基本情報技術者試験でも出題されるので、そこで知った方もおられるかもしれません。

本書で用いる広義のBNF（EBNFの要素を取り入れたもの）の主要な記法は以下の通りです。

*   `=` : 左辺の規則名と右辺の定義を区切ります。
*   `|` : 選択を表します。例えば `A | B` は「AまたはB」を意味します。
*   `{}` : 0回以上の繰り返しを表します。例えば `A {B}` は「Aの後にBが0回以上続く」ことを意味します。
*   `[]` : 0回または1回の出現（オプション）を表します。例えば `[A] B` は「Aがあるかもしれないし、ないかもしれないが、その後にBが続く」ことを意味します。
*   `()` : グループ化を表します。例えば `(A | B) C` は「AまたはBの後にCが続く」ことを意味します。
*   `'...'` または `"`...`"` : 終端記号（リテラル文字列）を表します。
*   規則名（例: `expr`, `term`）: 非終端記号を表します。

では早速、BNFの具体例を見て行きましょう。以下の例は2.1で出てきた算術式を元に、

- 扱える数値は一桁だけ

のように単純化したBNFです。

```bnf
expr = term { ('+' | '-') term };
term = factor { ('*' | '/') factor };
factor = NUMBER | '(' expr ')';
NUMBER = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
```

たくさんの記号が出てきて戸惑われたかもしれませんが、一つずつ丁寧に見ていきましょう。

### expr

BNFでは、以下のような**生成規則**の集まりによって、文法を表現します。

 ```
expr = term { ('+' | '-') term };
 ```

`=`の左側である`expr`が**規則名**で、右側が**本体**になります。規則名を**左辺**、本体を**右辺**と呼ぶこともあります。

ここでは 

```
term { ('+' | '-' ) term }
```

が本体になります。

本体の中に出てくる、他の規則を参照する部分（ここでは`term`)を**非終端記号**と呼びます。これは「まだ展開の余地がある記号」という意味で、同じBNF内で定義されている規則名と一致する必要があります。Javaでいえば、メソッド呼び出しのようなものです。

一方、`'+'`や`'-'`のように`'`で囲まれた記号や文字を**終端記号**と呼びます。これは「これ以上展開できない、最終的な文字」という意味で、実際にプログラムに書かれる文字そのものを表します。Javaでいえば、`+`演算子や`;`セミコロンのようなものです。

BNFにおいて`{}`で囲まれたものは、その中の要素が0回以上繰り返して出現することを示しています。したがって、

```
term { ('+' | '-') term }
```

という記述は、まず`term`が出現し、その後に「`+`または`-`とそれに続く`term`」が0回以上繰り返して出現することを示しています。0回以上という言い方が重要です。というのは、`term`が1回だけ出現してその後は何も出現しない場合もあるからです。たとえば、`1`という式はこの規則にマッチしますが、`{}`で囲まれた部分は出現していません。
  
この規則を日本語で表現すると「`expr`という名前の規則は、右辺の定義 `term { ('+' | '-') term }` から構成される」と読むことができます。

なお、本来の（ISO/IEC）BNFでは

```
expr = term, { ('+' | '-'), term };
```

のように要素間をカンマで区切りますが、本書では可読性を考慮してスペースで区切るようにしています。

### term

`term` は算術式の中で、掛け算や割り算を含んだ式を表す規則です。`factor`という規則を参照しています。

```text
term = factor { ('*' | '/') factor };
```

この規則によって`term`は、`factor`が`*`または`/`を挟んで0回以上繰り返して出現することを示しています。

### factor

`factor`は算術式の中で、数値や括弧で囲まれた式を表す規則です。

```text
factor = NUMBER | '(' expr ')';
```

この規則によって`factor`は、

- `NUMBER`
- `(`と`)`に挟まれた`expr`

のどちらかであることを示しています。

### NUMBER

`NUMBER`は数値を表す規則です。ここでは単純化のために1桁の整数のみを扱っています。

```text
NUMBER = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
```

`NUMBER`は`0`から`9`のどれか1文字であることを示しています。

## BNFを使った解析プロセス

算術式の文法を規則`expr`を含むBNFによって表現することができました。この記述には**曖昧さがなく**、スペースを許さないことや演算子の優先順位などの概念も含まれています。

この規則`expr`を使うと、式`1+2`はどのように解析できるのでしょうか？ここでは、その概要について簡単に説明します。

このBNFを使って解析を行う方法は一意ではなく、様々なやり方（手続き）があります。その個々の手続きがまさに構文解析アルゴリズムとなります。個々の構文解析アルゴリズムについては第5章で詳しく説明しますが、ここでは、BNFを使って**素直に**算術式を解析する方法の概要を説明します。ちなみに、構文解析に限った話ではありませんが、そのような**素直な**方法のことをナイーブ（naive）な方法と呼ぶことがあります。

まず最初にBNFの規則を関数とみなします。たとえば、規則`expr`は関数`expr`に対応し、規則`term`は関数`term`に対応します。これらの規則に対応する関数は、解析したい文字列と文字列の添え字を引数に取り、解析の結果を返します。

この関数の宣言をJavaライクな擬似コードで表すと、以下のようになります。

```java
ParseResult expr(String input, int index);
```

次に関数の呼び出しを構文解析とみなします。引数として解析したい文字列と、解析を開始する位置を渡すと、構文解析結果が返ってくるものとします。

たとえば、`expr("1+2", 0)`という関数呼び出しは、文字列`"1+2"`の先頭から解析を開始することを示します。まだ`expr`の本体がありませんが、結果としては、解析が成功した旨の情報がかえってきて欲しいでしょう。一方、`expr("1+", 0)`という関数呼び出しは、解析が失敗した旨の情報がかえってきて欲しいはずです。

関数の呼び出し結果は、

- 解析に成功した場合：成功したことを表す情報と、どこまで読み進んだかを示す位置（例えば、次の解析を開始すべき入力文字列中のインデックス）。これを`(SUCCESS, new_index)`と表す
- 失敗した場合：失敗を表す定数`FAIL`を返す

のどちらかであるものとします。

以上の前提を元に実際に`expr("1+2")`を解析していきますが、その前に実行中の各ステップを表す記法について説明しておきます。たとえば、この構文解析における最初のステップを以下のように表現します。

-  `expr("1+2", 0)` を呼び出す

    * 事前状態：
      * 位置：`↑1+2`
      * スタック：`[]`
    * アクション: `expr = term { ('+' | '-') term }` を呼び出す
    * 事後状態：
      * 位置：`↑1+2`
      * スタック: `[ expr = ↑ term { ('+' | '-') term } ]`

「`expr("1+2", 0)`を呼び出し」はそのステップで何を行うかの概要です。

**事前状態**は、そのステップが実行される直前の構文解析器の状態で、現在どこを読み込んでいるかを表す**位置**と、規則＋規則の本体のどこを解析しているか（文字列中の位置と区別するために、仮に**状況**と呼ぶことにします）を積む**スタック**からなります。

**アクション**は事前状態からどのような処理を行うかを示します。ここでは、規則`expr`を呼び出し、その本体である`term { ('+' | '-') term }`を解析することを示しています。

**事後状態**は、アクションを実行した後の構文解析器の状態で、位置とスタックがどのように変化したかを示します。スタックの各要素は規則に対して、現在解析中の位置を表す`↑`を加えたものになります。ここでは、`expr = ↑ term { ('+' | '-') term }`をスタックに積んでいますが、これは規則`expr`の最初の状態にいることを示しています。

それではこの記法を使って`expr("1+2", 0)`を解析していきましょう。

1. `expr("1+2", 0)` を呼び出す
  - 事前状態：
    - 位置：`↑1+2`
    - スタック：`[]`
  - アクション: `expr = term { ('+' | '-') term }` を呼び出す
  - 事後状態：
    - 位置：`↑1+2`
    - スタック: `[ expr = ↑ term { ('+' | '-') term } ]`

ここでは単に規則と状況をスタックに積んでいるだけです。まだ解析は行われていません。

2.  `term("1+2", 0)` を呼び出す
 - 事前状態：
   - 位置：`↑1+2`
   - スタック: `[ expr = ↑ term { ('+' | '-') term } ]`
 - アクション: `term = factor { ('*' | '/') factor }` を呼び出す
 - 事後状態：
   - 位置：`↑1+2`
   - スタック: `[ term = ↑ factor { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`

`expr`の最初が`term`なので、`term`を解析する必要があります。最初と同様に規則と状況をスタックに積みます。

3.  `factor("1+2", 0)` を呼び出す
  - 事前状態：
    - 位置: `↑1+2`
    - スタック: `[ term = ↑ factor { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`
  - アクション: `factor = NUMBER | '(' expr ')'` を呼び出す
  - 事後状態：
    - 位置: `↑1+2`
    - スタック: `[ factor = ↑ NUMBER | '(' expr ')', term = ↑ factor { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`

`term`の最初が`factor`なので、`factor`を解析する必要があります。同様に、規則と状況をスタックに積みます。

4.  `NUMBER("1+2", 0)` を呼び出す
  - 事前状態：
    - 位置: `↑1+2`
    - スタック: `[ factor = ↑ NUMBER | '(' expr ')', term = ↑ factor { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`
  - アクション: `NUMBER = '0' | ... | '9'` を呼び出す
  - 事後状態：
    - 位置: `↑1+2`
    - スタック: `[ NUMBER = ↑ '0' | ... | '9', factor = ↑ NUMBER ..., term = ↑ factor { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`

`factor`の最初は`NUMBER`あるいは`'('expr ')'`ですが、カッコにマッチする可能性はないので`NUMBER`を解析する必要があります。ここでも同様に、規則と状況をスタックに積みます。

5. `NUMBER` 内でマッチング (位置0)
  - 事前状態：
    - 位置: `↑1+2`
    - スタック: `[ NUMBER = ↑ ('0' | ... | '9'), factor = ↑ NUMBER ..., term = ↑ factor { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`
  - アクション: 次の文字 `1` が `'0' | ... | '9'` にマッチ。1文字消費する。
  - 事後状態：
    - 位置: `1↑+2`
    - スタック: `[ NUMBER = ('0' | ... | '9') ↑, factor = ↑ NUMBER ..., term = ↑ factor { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`

現在の状況は`NUMBER = ↑ ('0' | ... | '9')`で、次の文字は`1`です。つまり、`('0' | ... | '9')`にマッチするので、1文字消費して位置を進めます。スタックの状況を更新します。

6. `NUMBER`から戻る
  - 事前状態：
    - 位置: `1↑+2`
    - スタック: `[ NUMBER = ('0' | ... | '9') ↑, factor = ↑ NUMBER ..., term = ↑ factor { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`
  - アクション: `(SUCCESS, 1)` (消費した文字 "1", 次の位置はインデックス1)。
  - 事後状態：
    - 位置: `1↑+2`
    - スタック: `[ factor = NUMBER ↑ | '(' expr ')', term = ↑ factor { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`

現在の状況は規則`NUMBER`の解析が成功した状態です。スタックから`NUMBER`を取り出し、`factor`に戻ります。同時に、`factor`の状況を進めて、`factor = NUMBER ↑ | '(' expr ')'`とします。これは関数呼び出しから戻ってきた場合に、その関数呼び出しの次に制御が移るのと同様です。

7. `factor` から戻る
  - 事前状態：
    - 位置: `1↑+2`
    - スタック: `[ factor = NUMBER ↑ | '(' expr ')', term = ↑ factor { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`
  - アクション: `(SUCCESS, 1)` 。`term`に戻る。
  - 事後状態：
    - 位置: `1↑+2`
    - スタック: `[ term = factor ↑ { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`

現在の状況は`factor`の解析が成功した状態です。スタックから`factor`を取り出し、`term`に戻ります。同時に、`term`の状況を進めて、`term = factor ↑ { ('*' | '/') factor }`とします。

8.  `term` 内でマッチング (位置1)
  - 事前状態：
    - 位置: `1↑+2`
    - スタック: `[ term = factor ↑ { ('*' | '/') factor }, expr = ↑ term { ('+' | '-') term } ]`
  - アクション： 次の文字 `+` は `*` でも `/` でもないため、`{...}` の繰り返しは0回として成功。文字を消費しない。
    - 事後状態：
      - 位置: `1↑+2`
      - スタック: `[ term = factor { ('*' | '/') factor } ↑, expr = ↑ term { ('+' | '-') term } ]`

現在の状況は`factor ↑ { ('*' | '/') factor }`ですが、次の文字は`+`であり、`*`や`/`ではないため、繰り返し部分は0回として成功します。スタックの状況を更新します。 

9. `term` から戻る
  - 事前状態：
    - 位置: `1↑+2`
    - スタック: `[ term = factor { ('*' | '/') factor } ↑, expr = ↑ term { ('+' | '-') term } ]`
  - アクション: `(SUCCESS, 1)`。`expr`に戻る。
    - 事後状態：
      - 位置: `1↑+2`
      - スタック: `[ expr = term ↑ { ('+' | '-') term } ]`

現在の状況は`term`の解析が成功した状態です。スタックから`term`を取り出し、`expr`に戻ります。同時に、`expr`の状況を進めて、`expr = term ↑ { ('+' | '-') term }`とします。

10. `expr` 内でマッチング (位置1)
  - 事前状態：
    - 位置: `1↑+2`
    - スタック: `[ expr = term ↑ { ('+' | '-') term } ]`
  - アクション: 次の入力 `+` は `('+' | '-')` にマッチ。消費し、位置を進める。
  - 事後状態:
    - 位置: `1+↑2`
    - スタック: `[ expr = term { ('+' | '-') ↑ term } ]`

現在の状況は`expr = term ↑ { ('+' | '-') term }`ですが、次の文字は`+`であり、`('+' | '-')`にマッチするため、1文字消費して位置を進めます。スタックの状況を更新します。

11.  `term("1+2", 2)` を呼び出す
  - 事前状態:
    - 位置: `1+↑2`
    - スタック: `[ expr = term { ('+' | '-') ↑ term } ]`
  - アクション：`term = factor { ('*' | '/') factor }` を呼び出す。
  - 事後状態:
    - 位置: `1+↑2`
    - スタック: `[ term = ↑ factor { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`

現在の状況は`expr = term { ('+' | '-') ↑ term }`なので、`term`を解析する必要があります。スタックに`term = ↑ factor { ('*' | '/') factor }`を積みます。

12.  `factor("1+2", 2)` を呼び出す
  - 事前状態:
    - 位置: `1+↑2`
    - スタック: `[ term = ↑ factor { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`
  - アクション: `factor = NUMBER | '(' expr ')'` を呼び出す。
  - 事後状態:
    - 位置: `1+↑2`
    - スタック: `[ factor = ↑ NUMBER | '(' expr ')', term = ↑ factor { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`

現在の状況は`term = ↑ factor { ('*' | '/') factor }`なので、`factor`を解析する必要があります。スタックに`factor = ↑ NUMBER | '(' expr ')'`を積みます。

13. `NUMBER("1+2", 2)` を呼び出す
  - 事前状態:
    - 位置: `1+↑2`
    - スタック: `[ factor = ↑ NUMBER | '(' expr ')', term = ↑ factor { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`
  - アクション: `NUMBER = '0' | ... | '9'` を呼び出す。
  - 事後状態:
    - 現在位置: `1+↑2`
    - スタック: `[ NUMBER = ↑ ('0' | ... | '9'), factor = ↑ NUMBER ..., term = ↑ factor { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`

現在の状況は`factor = ↑ NUMBER | '(' expr ')'`ですが、次の文字はカッコでないので、`NUMBER`を解析する必要があります。スタックに`NUMBER = ↑ ('0' | ... | '9')`を積みます。

14. `NUMBER` 内でマッチング (位置2)
  - 事前状態:
    - 位置: `1+↑2`
    - スタック: `[ NUMBER = ↑ ('0' | ... | '9'), factor = ↑ NUMBER ..., term = ↑ factor { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`
  - アクション: 次の文字 `2` が `NUMBER` の `'0' | ... | '9'` にマッチ。1文字消費する。
  - 事後状態:
    - 位置: `1+2↑`
    - スタック: `[ NUMBER = ('0' | ... | '9') ↑, factor = ↑ NUMBER ..., term = ↑ factor { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`

現在の状況は`NUMBER = ↑ ('0' | ... | '9')`で、次の文字は`2`であり、`('0' | ... | '9')`にマッチするため、1文字消費して位置を進めます。スタックの状況を更新します。

15. `NUMBER` から戻る
  - 事前状態:
    - 位置: `1+2↑`
    - スタック: `[ NUMBER = ('0' | ... | '9') ↑, factor = ↑ NUMBER ..., term = ↑ factor { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`
  - アクション: `(SUCCESS, 3)` (消費した文字 "2", 次の位置はインデックス3)。 factorに戻る。
  - 事後状態:
    - 位置: `1+2↑`
    - スタック: `[ factor = NUMBER ↑ | '(' expr ')', term = ↑ factor { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`

`NUMBER`の解析が成功した状態です。スタックから`NUMBER`を取り出し、`factor`に戻ります。同時に、`factor`の状況を進めて、`factor = NUMBER ↑ | '(' expr ')'`とします。

16. `factor` から戻る
  - 事前状態:
    - 位置: `1+2↑`
    - スタック: `[ factor = NUMBER ↑ | '(' expr ')', term = ↑ factor { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`
  - アクション: `(SUCCESS, 3)`。`term`に戻る。
  - 事後状態:
    - 位置: `1+2↑`
    - スタック: `[ term = factor ↑ { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`

`factor`の解析が成功した状態です。スタックから`factor`を取り出し、`term`に戻ります。同時に、`term`の状況を進めて、`term = factor ↑ { ('*' | '/') factor }`とします。

17. `term` 内でマッチング (位置3)
  - 事前状態:
    - 位置: `1+2↑`
    - スタック: `[ term = factor ↑ { ('*' | '/') factor }, expr = term { ('+' | '-') ↑ term } ]`
  - アクション: 次の入力は終端なので、`{...}` の繰り返しは0回として成功。
  - 事後状態:
    - 位置: `1+2↑`
    - スタック: `[ term = factor { ('*' | '/') factor } ↑, expr = term { ('+' | '-') ↑ term } ]`

現在の状況は`term = factor ↑ { ('*' | '/') factor }`ですが、次の文字は終端であり、`*`や`/`ではないため、繰り返し部分は0回として成功します。スタックの状況を更新します。

18. `term` から戻る
  - 事前状態:
    - 位置: `1+2↑`
    - スタック: `[ term = factor { ('*' | '/') factor } ↑, expr = term { ('+' | '-') ↑ term } ]`
  - アクション: `(SUCCESS, 3)`。`expr`に戻る。
  - 事後状態:
    - 位置: `1+2↑`
    - スタック: `[ expr = term { ('+' | '-') term ↑ } ]`

`term`の解析が成功した状態です。スタックから`term`を取り出し、`expr`に戻ります。同時に、`expr`の状況を進めて、`expr = term { ('+' | '-') term ↑ }`とします。

19. `expr` 内でループ (位置3)
  - 事前状態:
    - 位置: `1+2↑`
    - スタック: `[ expr = term { ('+' | '-') term ↑ } ]`
  - アクション: 繰り返しの終端に来たので、次の繰り返しに入る。
  - 事後状態:
    - 位置: `1+2↑`
    - スタック: `[ expr = term { ↑ ('+' | '-') term } ]`

現在の状況は`expr = term { ('+' | '-') term ↑ }`なので、1回目の繰り返しは成功し、次の繰り返しに入ります。スタックの状況を更新します。

20. `expr` 内でマッチング (位置3)
  - 事前状態:
    - 位置: `1+2↑`
    - スタック: `[ expr = term { ↑ ('+' | '-') term } ]`
  - アクション: 次の文字は終端なので、`('+' | '-')` とのマッチングは失敗だが、繰り返し全体としては成功。ループを抜ける。
  - 事後状態:
    - 位置: `1+2↑`
    - スタック: `[ expr = term { ('+' | '-') term } ↑ ]`

21. `expr` から戻る
  - 事前状態:
    - 位置: `1+2↑`
    - スタック: `[ expr = term { ('+' | '-') term } ↑ ]`
  - アクション: `(SUCCESS, 3)`。`expr`の解析は成功。
  - 事後状態:
    - 位置: `1+2↑`
    - スタック: `[]`

`expr`の解析が成功した状態です。スタックから`expr`を取り出し、スタックは空になります。 

スタックが空で、入力が終端に到達したので、**解析完了**となります。

BNFの各規則が関数の呼び出しに対応し、入力文字列を消費しながら解析が進んでいく様子がイメージできたでしょうか。

## なぜこのBNFで演算子の優先順位を表現できるのか

BNFを使った素直な解析プロセスを理解したところで、重要な疑問に答えましょう。「なぜこのように書くと、掛け算・割り算が足し算・引き算より優先されるのか？」ということです。

その答えは、**文法の階層構造**にあります。BNFを改めて見てみましょう：

```text
expr = term { ('+' | '-') term };
term = factor { ('*' | '/') factor };
factor = NUMBER | '(' expr ')';
```

この文法では、次のような階層関係があります：

1. `expr`（最上位）: 足し算・引き算を扱う
2. `term`（中間層）: 掛け算・割り算を扱う  
3. `factor`（最下位）: 数値や括弧で囲まれた式を扱う

### 優先順位が実現される仕組み

式 `1+2*3` を例に、なぜ `*` が `+` より先に処理されるかを見てみましょう。

1. `expr`から解析を開始
  - `expr`は`term`を呼び出す
  - この時点では`+`や`-`を探すが、まだ`term`の解析中

2. `term`の解析
  - `term`は`factor`（ここでは`1`）を解析
  - 次の文字が`+`なので、`*`や`/`ではない
  - したがって`term`の解析は`1`で終了し、`expr`に戻る

3. `expr`の続き
  - `+`を見つけて消費
  - 次の`term`（`2*3`の部分）を解析

4. 2番目の`term`の解析
  - `factor`（`2`）を解析
  - 次が`*`なので、`term`の繰り返し部分が適用される
  - `*`を消費して、次の`factor`（`3`）を解析
  - `term`全体として`2*3`がひとまとまりになる

この結果、抽象構文木は以下のようになります：

```{=latex}
\begin{center}
\begin{tikzpicture}[
  level distance=1.5cm,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=2cm},
  every node/.style={circle, draw, minimum size=8mm}
]
  \node {+}
    child {node {1}}
    child {node {*}
      child {node {2}}
      child {node {3}}
    };
\end{tikzpicture}
\end{center}
```

### もし文法の階層が逆だったら？

以下のような**誤った**文法を書いたとしましょう：

```text
// 誤った文法（優先順位が逆）
expr = factor { ('*' | '/') factor };
factor = term { ('+' | '-') term };
term = NUMBER | '(' expr ')';
```

この場合、`1+2*3`は`(1+2)*3`として解析されてしまいます。なぜなら、以下のような解析手順になるからです：

1. `expr`が最初に`*`や`/`を探す
2. `factor`で`1+2`全体が先に処理される
3. その後で`*3`が処理される

### 文法設計の原則

演算子の優先順位を正しく表現するための原則は以下のようになります：

1. 優先順位の低い演算子ほど上位の規則で扱う
  - `+`, `-`は最上位の`expr`で
  - `*`, `/`は中間の`term`で

2. 同じ優先順位の演算子は同じ規則内で扱う
  - `+`と`-`は同じ`expr`内
  - `*`と`/`は同じ`term`内

3. 左結合性は繰り返しで表現
  - `{...}`による繰り返しが左から右への結合を実現

このような階層構造により、パーサーは自然に演算子の優先順位を守りながら解析を進めることができるのです。

## BNFと解析結果

算術式の文法をBNFで表現し、実際に算術式を表す文字列と照合することができました。

しかし、これでは文字列が与えられたBNFにマッチするかどうかの判定しかできません。

皆さんおなじみのJSONがそうであるように、実用的には解析した結果を何らかのデータ構造に変換して格納しておく必要があります。

次の節では、BNFで表現された算術式を解析し、その結果を抽象構文木というデータ構造に変換する方法について説明します。

## 抽象構文木

抽象構文木とは何でしょうか？今、私達が欲しいのは

- 空白や括弧といった余分な情報が含まれず
- 演算子の優先順位を表現できる

ような構造です。**抽象構文木**（Abstract Syntax Tree）は、そのようなニーズを満たすデータ構造です。

抽象構文木は一般には任意個の子を持つ多分木として表現されます。

たとえば、`1 + 2 * 3`という算術式の抽象構文木は以下のようになります。

```{=latex}
\begin{center}
\begin{tikzpicture}[
  level distance=1.5cm,
  sibling distance=2cm,
  every node/.style={circle,draw,minimum size=0.8cm},
  root/.style={fill=gray!50},
  internal/.style={fill=brown!50},
  leaf/.style={fill=green!30}
]
  \node[root] {+}
    child { node[leaf] {1} }
    child { node[internal] {*}
      child { node[leaf] {2} }
      child { node[leaf] {3} }
    };
\end{tikzpicture}
\end{center}
```

抽象構文木の各ノードは、プログラムの構造を表現するためのデータ構造です。たとえば、`+`ノードは足し算を表し、`1`ノードは整数の`1`を表します。

抽象構文木（AST）では、各ノードはプログラムの構成要素を表し、親子関係によって演算子とオペランドの関係性を示します。抽象構文木には次のようなノードがあります。

### 内部ノード

演算子や制御構造など、他のノードを子として持つノードです。
先程の例でいうと、`+`ノードと`*`ノードが内部ノードです。

### 葉ノード

子を持たないノードです。例えば、`1`や`2`、`3`といった数値は葉ノードとなります。
一般的には、リテラルや変数など、それ以上分解できない最小単位のノードが葉ノードとなります。

### 根ノード

抽象構文木の最上位に位置するノードです。抽象構文木の根となるノードであり、プログラム全体を表します。数式の例でいえば、全体を表す`+`ノードが根ノードとなります。
内部ノードと根ノードは排他でないことに注意してください。たとえば、`+`ノードは内部ノードであり、同時に根ノードでもあります。

### 優先順位

改めて、先程の抽象構文木を見てみましょう。

```{=latex}
\begin{center}
\begin{tikzpicture}[
  level distance=1.5cm,
  sibling distance=2cm,
  every node/.style={circle,draw,minimum size=0.8cm},
  root/.style={fill=gray!50},
  internal/.style={fill=brown!50},
  leaf/.style={fill=green!30}
]
  \node[root] {+}
    child { node[leaf] {1} }
    child { node[internal] {*}
      child { node[leaf] {2} }
      child { node[leaf] {3} }
    };
\end{tikzpicture}
\end{center}
```

この木構造では、`+`がルートノードであり、その左の子が`1`、右の子が`*`です。`*`ノードの子として`2`と`3`が配置されています。これにより、演算の優先順位が明確に表現されるわけです。

この抽象構文木を見れば、`1 + (2 * 3)` という演算順序が表現されており、`(1 + 2) * 3` のような異なる解釈にはならないことが直感的に理解できるでしょう。

### 抽象構文木をJavaで表現する

抽象構文木は視覚的な表現としても便利ですが、その真価はプログラム上で表現・処理することにあります。ここではJavaで表現する方法を紹介します。

```java
// 式を表すインタフェース
sealed interface Exp permits Add, Sub, Mul, Div, Num {}
// 加算を表すレコード
record Add(Exp lhs, Exp rhs) implements Exp {}
// 減算を表すレコード
record Sub(Exp lhs, Exp rhs) implements Exp {}
// 乗算を表すレコード
record Mul(Exp lhs, Exp rhs) implements Exp {}
// 除算を表すレコード
record Div(Exp lhs, Exp rhs) implements Exp {}
// 数値を表すレコード
record Num(int value) implements Exp {}
```

インタフェース`Exp`は、抽象構文木のノードを表すインタフェースです。

`Add`、`Sub`、`Mul`、`Div`、`Num`は、それぞれ加算、減算、乗算、除算、数値を表すレコードです。これによって、抽象構文木をJavaで表現することができます。

試しに`1 + 2 * 3`の抽象構文木をJavaで表現してみましょう。

```java
// 1 + 2 * 3
Exp exp = new Add(
  new Num(1), new Mul(new Num(2), new Num(3))
);
```

各クラスのインスタンスを作成することで、抽象構文木を表現することができます。

### 抽象構文木を評価する

抽象構文木を作成するだけでは、プログラムの実行結果を得ることはできません。抽象構文木を評価するためには、再帰的な処理を行うことが必要です。抽象構文木を辿りながら、各ノードの演算を行うことで、プログラムの実行結果を得ることができます。

以下は、算術式の抽象構文木を評価するJavaのコード例です。

```java
int eval(Exp e) {
  return switch(e){
    case Num t -> t.value();
    case Add t -> eval(t.lhs()) + eval(t.rhs());
    case Sub t -> eval(t.lhs()) - eval(t.rhs());
    case Mul t -> eval(t.lhs()) * eval(t.rhs());
    case Div t -> {
      int divisor = eval(t.rhs()); // 先に右辺を評価
      if(divisor == 0) { // 評価結果でゼロチェック
        throw new ArithmeticException("division by zero");
      }
      yield eval(t.lhs()) / divisor; // 左辺を評価して除算
    }
  };
}
```

ノードの種類に応じてswitch式で処理を分岐しています：

- `Num`ノードの場合: 格納されている数値 `t.value()` をそのまま返します。これが再帰のベースケースとなります。
- `Add`ノードの場合: 左の子 `t.lhs()` と右の子 `t.rhs()` をそれぞれ再帰的に `eval` し、その結果を足し算します。
- `Sub`、`Mul`ノードの場合: `Add` と同様に、左右の子を再帰的に評価し、それぞれの演算を行います。
- `Div`ノードの場合: まず右の子（除数）を `eval` し、その結果が0であれば `ArithmeticException` をスローします。0でなければ、次に左の子（被除数）を `eval` し、除算の結果を返します。ゼロ除算チェックは、実際の計算を行う前に行うことが重要です。また、`eval(t.rhs())` を2回呼び出すのを避けるため、一度評価した結果を変数に格納しています。

この`eval`メソッドの動作を `1 + 2 * 3` の抽象構文木 `new Add(new Num(1), new Mul(new Num(2), new Num(3)))` で追ってみましょう。

- `eval(new Add(new Num(1), new Mul(new Num(2), new Num(3))))` が呼び出される。
  - `Add`ケースにマッチ。
  - `eval(t.lhs())` つまり `eval(new Num(1))` が呼び出される。
    - `Num`ケースにマッチ。`1` を返す。
  - `eval(t.rhs())` つまり `eval(new Mul(new Num(2), new Num(3)))` が呼び出される。
    - `Mul`ケースにマッチ。
    - `eval(t.lhs())` つまり `eval(new Num(2))` が呼び出される。
      - `Num`ケースにマッチ。`2` を返す。
    - `eval(t.rhs())` つまり `eval(new Num(3))` が呼び出される。
      - `Num`ケースにマッチ。`3` を返す。
    - `2 * 3` の結果である `6` を返す。
  - `1 + 6` の結果である `7` を返す。

このように抽象構文木を再帰的に辿ることで、式の評価が実現されます。`Div` の場合のゼロ除算エラー処理は、プログラムの実行時エラーを防ぐために不可欠です。他の演算（`Add`, `Sub`, `Mul`）では、Javaの整数演算がオーバーフローする可能性はありますが、`ArithmeticException` のような実行時例外を直接引き起こす「不正な演算」は（ゼロ除算ほど明確には）定義されていないため、ここでは特にエラー処理を加えていません（もちろん、より堅牢な電卓を作る場合はオーバーフロー検知なども考慮に入れるべきです）。

`eval`メソッドを使うことで、次のように抽象構文木を評価することができます。

```java
// 1 + 2 * 3
Exp exp = new Add(
  new Num(1), new Mul(new Num(2), new Num(3))
);
eval(exp); // 7
```

抽象構文木をデータとして表現することで、プログラムの構造を簡単に解析することができるのです。

## まとめ

この章では、算術式の文法を例題としてBNFについて紹介し、BNFに基づいて算術式を解析する方法の概要について説明しました。また、抽象構文木についても紹介し、抽象構文木をJavaで表現する方法と、抽象構文木を評価する方法について説明しました。

しかし、今のままではBNFに基づく「構文解析器」は与えられた文字列が文法にマッチするかどうかを判定するだけで、抽象構文木を生成することができません。次章では、ここで学んだBNFの考え方を応用して、実際にJavaで動作するJSONの構文解析器を実装し、JSONの抽象構文木を生成する方法について詳しく説明します。

[^1]: 翻訳: ISO/IEC 14977:1996 Information technology — Syntactic metalanguage — Extended BNF https://hazm.at/mox/lang/meta-language/ebnf/iso-iec-14977-extended-bnf/index.html