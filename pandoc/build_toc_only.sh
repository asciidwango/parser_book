#!/bin/bash

# 目次のみのPDF生成スクリプト

set -e

echo "📚 目次のみのPDFを生成します..."

# ディレクトリ設定
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SRC_DIR="$SCRIPT_DIR/src"
BUILD_DIR="$SCRIPT_DIR/build"

# 出力ディレクトリの準備
mkdir -p "$BUILD_DIR"

# 目次用の空ファイルを作成
TOC_FILE="$SRC_DIR/toc_only.md"
cat > "$TOC_FILE" << 'EOF'
# はじめに {-}

# 第1章 構文解析の世界へようこそ

## 構文解析の歴史的背景

## 構文解析とは何か

## 構文解析の身近な応用例

## 構文解析の奥深さ

## 本書で扱うプログラミング言語とツール

## 学習の道筋

## コラム：現代の構文解析の課題

# 第2章 構文解析の基本

## 算術式の文法

## 算術式のBNF

### BNFの概要

### expression

### term

### factor

### NUMBER

## BNFを使った解析プロセス

## なぜこのBNFで演算子の優先順位を表現できるのか

### 優先順位が実現される仕組み

### もし文法の階層が逆だったら？

### 文法設計の原則

## BNFと解析結果

## 抽象構文木

### 内部ノード

### 葉ノード

### 根ノード

### 優先順位

### 抽象構文木をJavaで表現する

### 抽象構文木を評価する

## まとめ

# 第3章 JSONの構文解析

## JSON（JavaScript Object Notation）の概要

### オブジェクト

### 配列

### 数値

### 文字列

### 真偽値

### null

### JSONの全体像

## JSONのBNF

### json

### object

### pair

### COMMA

### array

### value

### true

### false

### null

### number

### string

### JSONのBNFまとめ

## JSONの構文解析器

### 構文解析器の全体像

### nullの構文解析メソッド

### trueの構文解析メソッド

### falseの構文解析メソッド

### 数値の構文解析メソッド

### 文字列の構文解析メソッド

### 配列の構文解析メソッド

### オブジェクトの構文解析メソッド

### 構文解析における再帰

### 構文解析とPEG

## 古典的な構文解析器

## JSONの字句解析器

### ヘッダ部

### 本体部

### tokenizeNumber

### tokenizeStringLiteral

### accept

### moveNext

### current

## JSONの構文解析器

### parseTrue

### parseFalse

### parseNull

### parseString

### parseNumber

### parseObject

### parseArray

## まとめ

# 第4章 文脈自由文法の世界

## 身近な例から始める文脈自由文法

### 括弧の対応という根本問題

### BNFで括弧の構造を表現する

### BNFから文脈自由文法へ

### 用語の整理

## 実例で理解する「言語」の概念

### プログラマーにとっての「言語」とは

### 言語を「文字列の集合」として考える

### Dyck言語も集合として理解する

### 集合論の威力

## 正規表現の限界と文脈自由言語

### 身近な正規表現から考える

### 正規表現でできないこと

### 正規表現の仕組みと限界

### 言語の階層：正規表現 < 文脈自由文法 < ...

### 実用上の意味

### さらに上の階層

## 文法から文字列を作る：導出の仕組み

### 生成規則の意味

### 実際に文字列を生成してみる

### 複数の導出方法

### 最左導出と最右導出

### 構文木との関係

### なぜ2つの導出方法が重要か

## まとめ

### 学んだこと

### なぜこれが重要か

# 第5章 構文解析アルゴリズム古今東西

## 本章で学ぶこと

## 構文解析器生成系との関係

## 下向き構文解析と上向き構文解析 - 2つの世界観

### なぜ2つのアプローチが必要なのか？

## 下向き構文解析の概要

### 下向き構文解析の2つの方式

### Dyck言語で学ぶ予測型下向き構文解析

### スタックを使った解析の追跡

### 解析過程の詳細表

### 予測型下向き構文解析のアルゴリズム

## 下向き構文解析法のJavaによる実装

### 再帰下降構文解析の実装

### コードの解説

### 文法規則とコードの対応関係

### 「再帰下降」という名前の由来

### 下向き構文解析のバリエーション

## 上向き構文解析の概要

### シフト還元構文解析の基本アイデア

### 例で学ぶシフト還元構文解析

### シフト還元構文解析の詳細表

### シフト還元構文解析のアルゴリズム

### 下向きと上向きの違い

## 上向き構文解析のJavaによる実装

### 必要なデータ構造

### シフト還元構文解析器の実装

### 実装のポイント

## 下向き構文解析と上向き構文解析の比較

### 下向き構文解析の利点

### 下向き構文解析の欠点

## LL(1) - 代表的な下向き構文解析アルゴリズム

### LL(1)とは？

### LL(1)の直感的な理解

### 課題1：複数のトークンで始まる構文

### FIRST集合の導入

### FIRST集合とLL(1)の条件

### LL(1)の実装例

### 課題2：空文字列規則の扱い

### nullableとFOLLOW集合

### FIRST集合とFOLLOW集合の計算

#### FIRST集合の計算アルゴリズム

#### nullableの計算

#### FOLLOW集合の計算アルゴリズム

### LL(1)構文解析表の作成

### LL(1)の問題点と限界

### 問題点1：共通前置辞問題

### 問題点2：左再帰の問題

## LL(k) - LL(1)の拡張

## LR(0) - 最も単純な上向き構文解析

### LR系の発展

### LR(0)の基本アイデア

### LR(0)項目と項目集合（状態）

### 閉包（Closure）とGOTO関数

#### 閉包（Closure）

#### GOTO関数

### LR(0)状態機械の構築

### LR(0)構文解析表の作成

### LR(0)の限界：コンフリクト

### 具体例：LR(0)状態機械と解析表の構築

## SLR(1) - FOLLOW集合でコンフリクト解消を試みる

### FOLLOW集合の計算

### SLR(1)構文解析表の作成

### SLR(1)によるコンフリクト解消の例

### SLR(1)の限界

## LR(1) - より強力な先読み情報を持つ項目

### LR(1)項目

### LR(1)閉包（Closure）とGOTO関数

#### LR(1)閉包

#### LR(1) GOTO関数

### LR(1)構文解析表の作成

### LR(1)によるコンフリクト解消の例

### LR(1)の欠点：解析表のサイズ

## LALR(1) - 実用性と解析能力のバランス

### LALR(1)のアイデア：状態のマージ

### LALR(1)構文解析表の作成

### LALR(1)の利点と欠点

#### 利点

#### 欠点

### LALR(1)の位置づけ

## Parsing Expression Grammar(PEG) - 新しいアプローチ

### PEGの基本アイデア

### 第3章で実装したPEG

### PEGの利点

### 配列の解析例

### PEGの形式的定義

### 空文字列

### 終端記号

### 選択

### 連接

### 非終端記号

### 0回以上の繰り返し

### 肯定述語

### 否定述語

### PEGとCFGの違い

### PEGの実用例

## Packrat Parsing - PEGの線形時間化

### メモ化とは？

### フィボナッチ数で学ぶメモ化

### メモ化による改善

### PEGパーサのメモ化

### メモ化による最適化

### 効果の比較

### Packrat Parsingの特徴

### 実用的な工夫

## まとめ

### 学んだアルゴリズムの整理

### なぜこれらの知識が重要か

### 実践への橋渡し

# 第6章 構文解析器生成系の世界

## Dyck言語の文法とPEGによる構文解析器生成

## JSONの構文解析器を生成する

## 構文解析器生成系の分類

## JavaCC：Javaの構文解析生成系の定番

## Yacc (GNU Bison)：構文解析器生成系の老舗

## ANTLR：多言語対応の強力な下向き構文解析生成系

## SComb

## パーザコンビネータJCombを自作しよう！

### 部品を考えよう

### `string()`メソッド

### `alt()`メソッド

### `seq()`メソッド

#### `rep0()`, `rep1()`メソッド

### `map()`メソッド

### `lazy()`メソッド

### `regex()`メソッド

### 算術式のインタプリタを書いてみる

### まとめ

# 第7章 現実の構文解析

## 字句要素が構文要素を含む文法

## インデント文法

## ヒアドキュメント

## 改行終端可能文法

## Cのtypedef

## Scalaでの「文頭に演算子が来る場合の処理」

## プレースホルダー構文

## C++のテンプレート構文

## 正規表現リテラルの曖昧性

## マクロ展開

## 文字列内のエスケープシーケンス

## エラーリカバリ

## まとめ

# 第8章 おわりに

## さらに学ぶために：参考文献と資料

### 古典的名著・専門書

### 特定の技術に関する論文・資料

### オンラインリソース・コミュニティ

## 最後に

# 参考文献 {-}
EOF

# 目次のみのPDFを生成
echo "📋 目次PDFを生成中..."
pandoc \
    "$SRC_DIR/metadata.yaml" \
    "$TOC_FILE" \
    --from markdown \
    --to pdf \
    --pdf-engine=lualatex \
    --pdf-engine-opt=-shell-escape \
    --template="$SCRIPT_DIR/templates/minimal_japanese.latex" \
    --output="$BUILD_DIR/toc_only.pdf" \
    --top-level-division=section

echo "✅ 目次PDF生成完了: $BUILD_DIR/toc_only.pdf"

# 一時ファイルを削除
rm -f "$TOC_FILE"