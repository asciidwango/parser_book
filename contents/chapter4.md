
# 第4章 文脈自由文法の世界

第3章では、JSONの構文解析器を記述することを通して、構文解析のやり方を学びました。構文解析器についても、PEG型の構文解析器および字句解析器を使った2通りを作ってみることで、構文解析器といっても色々な書き方があるのがわかってもらえたのではないかと思います。

この第4章では、現代の構文解析を語る上で必須である、文脈自由文法という概念について学ぶことにします。「文脈自由文法」というと、一見、堅くて難しそうな印象を持つ方も多いかもしれません。

しかし、実は皆さんは既に文脈自由文法を使っているのです。Javaの`if`文やメソッド定義、JSONの入れ子構造など、プログラミングで日常的に扱っている「構造」はすべて文脈自由文法で表現されています。この章では、そんな身近な例から始めて、徐々に文脈自由文法の概念を理解していきましょう。

## 身近な例から始める文脈自由文法

まず、皆さんが普段書いているJavaコードを見てみましょう。以下はシンプルなif文です。

```java
if (x > 0) {
    System.out.println("正の数です");
}
```

このif文の構造を言葉で説明すると「`if`の後に条件式を括弧で囲み、その後に文のブロックが来る」となります。さらに、if文の中にif文を書くこともできます。

```java
if (x > 0) {
    if (x > 100) {
        System.out.println("100より大きい");
    }
}
```

この「入れ子にできる構造」こそが、文脈自由文法の本質なのです。

この入れ子構造は、プログラミング以外の場面でも頻繁に現れます。

- **HTMLの要素**：

```html
<div>
    <p>段落の中に<strong>強調</strong>があり、
       さらに<a href="...">リンク</a>も含まれる</p>
</div>
```

- **数式の括弧**：

```sh
((2 + 3) × (4 - 1)) ÷ 5
```

- **日本語の引用**：

```sh
彼は「『明日は晴れる』と言った」らしい。
```

- **JSONのオブジェクト**：

```json
{
  "user": {
    "profile": {
      "name": "太郎"
    }
  }
}
```

これらの例に共通するのは、ある構造の中に同じような構造を含むことができ、その深さに制限がないという点です。このような構造を正確に記述し、解析するために文脈自由文法が必要になるのです。この問題は、次節で述べる「括弧の対応」という根本的な問題に帰着します。

## 括弧の対応という根本問題

形式言語で最も基本的で重要な構造の一つが「括弧の対応」です。大抵のプログラミング言語（JSONやYAMLのようなものも含む）は開き括弧と閉じ括弧に対応するルールを持っています。たとえ括弧そのものでなくても、`begin/end`や`{}`などが任意の深さだけ入れ子にできる場合は同じことです。

かなり原始的なプログラミング言語についてすら、数式を入力できる機能があり、かつ数式の中で括弧を使うことができる以上、プログラミング言語の構文解析において括弧の対応は避けて通れない問題です。

さて、ここで括弧の対応とは何かを考えてみましょう。括弧の対応が取れているとは、`(`および`)`からなる文字列において、開き括弧と閉じ括弧が正しくペアになっていることを意味します。たとえば、以下は正しい括弧の対応です：

```sh
()          // 1組の括弧
(())        // 入れ子になった括弧
(()())      // 入れ子と並列の組み合わせ
()()()      // 並列に並んだ括弧
```

一方、以下は正しくない例です：

```sh
)(          // 順序が逆
(()         // 閉じ括弧が不足
())         // 開き括弧が不足
```

このような「`(`および`)`からなる文字列で、括弧の釣り合いが取れた文字列の並び」を表すものをDyck言語（「ディック言語」と読みます）と呼びます。「Dyck」は数学者の名前に由来しています。この、一見単純に見える問題が、構文解析において極めて重要な位置を占めているのです。

## BNFで括弧の構造を表現する

この括弧の対応をどのように文法として表現すればよいでしょうか？まずは既に皆さんに学んでもらったBNFを使って考えてみましょう。

括弧の構造には以下の2つのパターンがあります：

1. 空文字列（括弧なし）
2. `(` + 内側の括弧構造 + `)` + 続きの括弧構造

これをBNFで書くと以下のようになります：

```sh
P = "(" P ")" P | "";
```

`P`は「括弧のパターン」を表します。この定義は再帰的になっていることに注目してください。`P`の定義の中に`P`自身が現れています。これこそが、入れ子構造を表現する鍵なのです。

このBNFは上記の2つのパターンと直接対応しています：
- `""`：空文字列（パターン1）
- `"(" P ")" P`：開き括弧、内側の構造、閉じ括弧、続きの構造（パターン2）

## BNFから文脈自由文法へ

前節のBNFは既に文脈自由文法の一種です。ただし、文脈自由文法の議論をする際には、より標準的な記法を使います。段階的に変換してみましょう。

- ステップ1: 選択を分離

まず、`|`で区切られた選択肢を別々の規則に分けます：

```sh
P = "(" P ")" P;
P = "";
```

同じ`P`が2つの規則で定義されていますが、これは「Pは2つのパターンのどちらかになる」という意味です。

- ステップ2: 記号の変更

次に、記法を数学的な標準形に近づけます：

- `=` を `→`（生成規則を表す矢印）に変更
- `""` を `ε`（イプシロン：空文字列を表す記号）に変更
- 文字を囲む引用符を削除

```sh
P → ( P ) P
P → ε
```

これで文脈自由文法の標準的な記法になりました！

### 用語の整理

ここで重要な用語を整理しておきましょう：

- 生成規則：`P → ( P ) P` のような矢印で結ばれた規則
- 非終端記号：`P`のような、さらに展開される記号（変数のようなもの）
- 終端記号：`(`や`)`のような、これ以上展開されない記号（実際の文字）
- 開始記号：文法の起点となる非終端記号（この例では`P`）

つまり、文脈自由文法とは以下のようにして表現できます：

- 生成規則の集まり
  - 各生成規則は「非終端記号 → 記号の並び」の形
  - 記号の並びは終端記号と非終端記号の組み合わせ（空文字列εも可）

これだけのシンプルなルールで、プログラミング言語の複雑な構文を表現できるのです。


## 実例で理解する「言語」の概念

前の節で定義したDyck言語の文法をもう一度見てみましょう。

```sh
D → P
P → ( P ) P
P → ε
```

この文法は括弧の対応をあらわすもの、という風にぼかして来ました。実のところ、これまで出てきた文法はすべて「形式言語」を定義するものです。でも、ちょっと待ってください。「形式言語」って何でしょうか？

私たちが普段「プログラミング言語」と呼んでいるJavaやPythonと、この3行の規則で表される「括弧の言語」は、どう関係しているのでしょうか？実は、どちらも同じ「形式言語」という概念で理解できるのです。

### 「形式言語」とは

私たちが普段使う「言語」という言葉は、自然言語（日本語や英語など）を指すことが多いですが、理論の世界では「形式言語」という概念が重要です。形式言語とは、**文字列の集合**として定義される言語のことです。

ここで言う集合とは数学の集合のことです。形式言語の世界では文字列をひたすら集めていった、その集合が「言語」と呼ばれるのです。

単に「aabcaa」のような意味のない文字列の羅列に感じるかもしれませんが、重要なのは「どの文字列がその言語に属するか」という**規則**です。たとえば：

- **パスワードの言語**：「8文字以上で、英数字と記号を含む文字列の集合」
- **電話番号の言語**：「数字とハイフンからなる特定のパターンに従う文字列の集合」
- **プログラミング言語**：「その言語の文法に従う正しいプログラムの集合」

つまり、形式言語は単なる文字列の寄せ集めではなく、明確な規則に基づいて「その言語に属する/属さない」が判定できる文字列の集合なのです。

さて、この観点から「Java言語」や「JavaScript言語」という時、それは何を指しているのでしょうか？

### 言語を「文字列の集合」として考える

形式言語の立場からは、プログラミング言語を**その言語で書ける正しいプログラムすべての集合**として定義することができます。「正しいプログラム」といっても、構文解析ができるもの、型検査を通るもの、実行時にエラーが出ないものなど、いくつかの基準がありますが、ここでは「構文解析が通るプログラム」と考えます。

具体例で考えてみましょう。以下はすべて正しいJavaScriptプログラムです：

```javascript
console.log("Hello, World!");
```

```javascript
console.log(3);
```

```javascript
console.log(3 + 5);
```

これらを集めていくと、JavaScriptという言語（以後`JS`と表記）は次のような文字列の集合として表現できます：

```txt
JS = {
  "console.log(\"Hello, World!\");",
  "console.log(3);",
  "console.log(3 + 5);",
  "const x = 10;",
  "function add(a, b) { return a + b; }",
  ...（無限に続く）
}
```

JSで書ける正しいプログラムは無限にあるので、この集合は**無限集合**（正確には可算無限個の集合）になります。

### Dyck言語も集合として理解する

同様に、Dyck言語（括弧の対応が取れた文字列）も集合として表現できます：

```txt
Dyck = {
  "()",
  "(())",
  "((()))",
  "(()())",
  "()()",
  "()()()",
  ...（無限に続く）
}
```

Dyck言語も無限集合です。基本的に私達が扱いたい言語＝集合は、ほとんどが無限集合です。なぜなら、基本的にはその言語のテキストがいくら長くなってもいいようにしたいからです。言語であらかじめ「長さの制限」を設けることは、実用的ではありません。

### 集合として言語を扱うメリット

言語を集合として扱うと、数学の集合論で使う記号が使えるようになります。これには実用的なメリットがあります。

まず、基本的な記号の意味を説明します：

- `∈`：「含まれる」を意味します（要素と集合の関係）
- `∉`：「含まれない」を意味します（要素と集合の関係）
- `⊂`：「部分集合」を意味します（集合と集合の関係）
- `∩`：「共通部分」を意味します（両方の集合に含まれる要素）
- `∪`：「和集合」を意味します（どちらかの集合に含まれる要素）（第6節で使用）

重要な違いとして、`∈`は要素（文字列）と集合（言語）の関係を表し、`⊂`は集合と集合の関係を表します。たとえば、以下のようになります：

```txt
"()" ∈ Dyck         // 「文字列"()"」が「言語Dyck」に含まれる
{""} ⊂ Dyck        // 「空文字列だけからなる集合」は「言語Dyck」の部分集合
```

- 例1：ある文字列が言語に含まれるかの判定

```txt
"()" ∈ Dyck         // "()"はDyck言語に含まれる
")(" ∉ Dyck         // ")("はDyck言語に含まれない
```

- 例2：言語の後方互換性

Java 8がJava 5の後方互換であることを、集合の包含関係で表現できます：

```txt
Java5 ⊂ Java8      // Java 5で書けるプログラムはすべてJava 8でも書ける
```

- 例3：言語の共通部分

たとえば、「JSでもTSでも有効なプログラム」は以下のように表現できます：

```txt
JS ∩ TS = {
  "console.log(123);",
  "const x = 5;",
  "function f() { return 1; }",
  ...
}
```

このように、言語を集合として扱うことで、言語間の関係を明確に表現できるようになります。これは単なる理論ではなく、言語設計や互換性の議論において非常に役立ちます。

## 文脈自由文法の数学的定義

ここまでふわっとした説明をしてきましたが、文脈自由文法の定義はもう少し厳密に行うことができます。本書では厳密な数学的扱いよりも実用的な理解を重視するため、あくまで厳密にはこう定義されるという話であって、この定義を直接使うことはありません。興味のない方は読み飛ばしても構いません。

文脈自由文法（Context-Free Grammar, CFG）は、形式的には4つ組 $G = (V, \Sigma, P, S)$ として定義されます：

- $V$：非終端記号（Non-terminal symbols）の有限集合
- $\Sigma$：終端記号（Terminal symbols）の有限集合（$V \cap \Sigma = \emptyset$）
- $P$：生成規則（Production rules）の有限集合
  - 各規則は $A \rightarrow \alpha$ の形（$A \in V$、$\alpha \in (V \cup \Sigma)^*$）
- $S$：開始記号（Start symbol）（$S \in V$）

例えば、Dyck言語の文法は数学的には以下のように表せます：

- $V = \{P\}$
- $\Sigma = \{(, )\}$
- $P = \{P \rightarrow (P)P, P \rightarrow \varepsilon\}$
- $S = P$

ここで $\varepsilon$ は空文字列を表します。

文法 $G$ が生成する言語 $L(G)$ は、開始記号 $S$ から生成規則を繰り返し適用して導出できるすべての終端記号列の集合として定義されます：

$$L(G) = \{w \in \Sigma^* \mid S \Rightarrow^* w\}$$

ここで、$\Rightarrow^*$ は「0回以上の導出ステップ」を表します。

もう少し噛み砕いて説明すると：

1. 開始記号 $S$ から出発する
2. 生成規則を適用して、非終端記号を置き換えていく
3. すべてが終端記号になったら、それが言語 $L(G)$ の要素の一つ

例えば、Dyck言語の文法では以下のようにになります。

- $P \Rightarrow (P)P \Rightarrow ()P \Rightarrow ()$ という導出により、`()` が $L(G)$ に含まれる
- $P \Rightarrow (P)P \Rightarrow ((P)P)P \Rightarrow (()P)P \Rightarrow (())P \Rightarrow (())$ により、`(())` も $L(G)$ に含まれる
- このようにして、すべての「正しく対応した括弧列」が $L(G)$ の要素となる

この数学的定義を「きっちりと」理解することは、理論的には重要ですが、構文解析器の実装では、直感的な理解で問題ありません。BNFなどの記法は数学的定義と本質的に同じものを、より読みやすい形で表現しています。

## 正規表現の限界と文脈自由言語

ここまでで文脈自由文法の基本的な概念と言語を集合として扱う考え方を学びました。BNFと文脈自由文法の表現能力が実質的に等価であることはなんとなく理解できたかと思います。しかし、ここで一つ重大な疑問が浮かび上がります。それは、私たちにとって馴染み深い正規表現との関係です。正規表現も文脈自由文法と同じように言語＝文字列の集合を表現するためのツールですが、正規表現と文脈自由文法にはどのような違いがあるのでしょうか？

### 身近な正規表現から考える

皆さんは日常的に正規表現を使っているでしょう。ファイル検索、テキスト処理、入力値の検証など、様々な場面で活躍しています。

たとえば、Javaで電話番号の形式をチェックする時、以下のような正規表現を使うことがあります：

```java
String phonePat = "\\d{3}-\\d{4}-\\d{4}";  // 例：090-1234-5678
if (phone.matches(phonePat)) {
    // 有効な電話番号
}
```

あるいは、郵便番号の簡易チェックでは以下のような正規表現を使います：

```java
String postalCodePat = "\\d{3}-\\d{4}";  // 例：123-4567
if (postalCode.matches(postalCodePat)) {
    // 有効な郵便番号
}
```

正規表現は、特定のパターンにマッチする文字列を簡潔に表現できる強力なツールです。また、正規表現も無限集合を扱うことができます。上記の正規表現はあくまで有限個のパターンしか表せませんが、以下のパターンでは自然数　を無限に表現できます：

```java
String natPat = "0|[1-9][0-9]*";  // 0以上の自然数
if (number.matches(natPat)) {
    // 有効な自然数
}
```

このとき、`natPat`は以下のような無限集合を表します：

```txt
{'0', '1', '2', '3', ...}
```

注意して欲しいのは、これはあくまで文字列としての自然数の集合であり、数値としての自然数ではないということです。正規表現は文字列のパターンを表現するためのツールであり、数値そのものを扱うわけではありません。

### 正規表現でできないこと

しかし、正規表現には決定的な限界があります。それは**括弧の対応が取れているかチェックできない**ということです。

試しに、既にでてきたDyck言語をを正規表現で判定することを考えてみましょう：

```txt
OK:  (), (()), (()(()))
NG:  )(, ((), ())
```

どんなに工夫しても、任意の深さの括弧の対応を正規表現で表現することはできません。なぜでしょうか？次からは正規表現の基本的な仕組みとその限界について詳しく見ていきましょう。

### 正規表現の構成要素を詳しく見る

正規表現は、実は非常にシンプルな3つの基本演算から構成されています。現代の正規表現エンジンは多くの便利な記法を提供していますが、理論的にはすべて以下の1-3の基本演算に帰着できます（ただし、後方参照など「非正規表現」とでも呼ぶべき機能を除く）。

#### 1. 連接（Concatenation）

2つの正規表現を続けて書くことを**連接**と呼びます。

```txt
正規表現: ab
マッチする文字列: "ab"
マッチしない文字列: "a", "b", "ba", "abc"
```

連接は最も基本的な演算で、「次に」という順序関係を表現します。

#### 2. 選択（Alternation）

`|`記号を使って、複数の選択肢を表現します。

- 正規表現: `a|b`
- マッチする文字列: `"a"`, `"b"`
- マッチしない文字列: `"ab"`, `"c"`, `""`

より複雑な例：

- 正規表現: `(ab|cd)`
- マッチする文字列: `"ab"`, `"cd"`
- マッチしない文字列: `"ac"`, `"bd"`, `"abcd"`

#### 3. 繰り返し（Kleene Star）

`*`記号は、直前の要素を0回以上繰り返すことを意味します。この演算は数学者Stephen Cole Kleene（ステファン・クリーネ）にちなんで「Kleene Star」と呼ばれます。

- 正規表現: `a*`
- マッチする文字列: `""`, `"a"`, `"aa"`, `"aaa"`, ...
- マッチしない文字列: `"b"`, `"ab"`

#### 派生的な演算子

現代の正規表現では、便利のために多くの派生的な演算子が追加されています：

```txt
a+       1回以上の繰り返し（aa*と同等）
a?       0回または1回（a|εと同等）
a{n}     ちょうどn回の繰り返し
a{n,m}   n回以上m回以下の繰り返し
[a-z]    文字クラス（a|b|c|...|zと同等）
.        任意の1文字
```

これらはすべて基本の3演算で表現できます。たとえば代表的な例をあげると以下のようになります：

- `a+` は `aa*`
- `a?` は `a|ε`（εは空文字列）
- `[abc]` は `a|b|c`

### 正規表現の裏側にある仕組み

皆さんは正規表現を使っているとき、その裏側でどのような処理が行われているか考えたことはありますか？実は、正規表現の限界を理解するには、その背後にある「オートマトン」という仕組みを知ることが役立ちます。「オートマトン」という名前は難しそうですが、要は「文字列を一文字ずつ読みながら状態を変えていく機械」のことです。

#### オートマトンを自動販売機で考える

オートマトンは「有限個の状態を持つ機械」です。難しく聞こえるかもしれませんが、自動販売機を例にするとわかりやすくなります。ここで、全ての商品は100円とし、投入可能な上限金額は300円とします：

- 初期状態：お金が入っていない
  - 100円投入 → 100円状態へ遷移
  - 商品ボタンを押す → 初期状態のままで、お金が不足している旨を表示
- 100円状態
  - 100円投入 → 200円状態へ遷移
  - 商品ボタンを押す → 商品を出して初期状態へ遷移
- 200円状態
  - 100円投入 → 300円状態へ遷移
  - 商品ボタンを押す → 商品と、お釣りをだして初期状態へ遷移
- 300円状態
  - 100円投入 → 300円状態のまま、100円を返却
  - 商品ボタンを押す → 商品と、お釣りをだして初期状態へ遷移

図にすると以下のようになります：

```{=latex}
\begin{center}
\begin{tikzpicture}[
  ->,>=stealth',
  node distance=3cm,
  initial text=start,
  every state/.style={thick, fill=gray!10},
  accepting/.style={double distance=2pt}
]

% 状態の定義
\node[state,initial] (q0) {初期状態};
\node[state] (q1) [right of=q0] {100円};
\node[state] (q2) [right of=q1] {200円};
\node[state] (q3) [right of=q2] {300円};

% 遷移の定義
% 100円投入による遷移
\path (q0) edge[bend left] node[above] {100円} (q1);
\path (q1) edge[bend left] node[above] {100円} (q2);
\path (q2) edge[bend left] node[above] {100円} (q3);
\path (q3) edge[loop above] node {100円/返却} (q3);

% 商品ボタンによる遷移
\path (q1) edge[bend right] node[below] {ボタン/不足} (q0);
\path (q2) edge[bend right=40] node[below] {ボタン/商品} (q0);
\path (q3) edge[bend right=50] node[below] {ボタン/商品+釣} (q0);

\end{tikzpicture}
\end{center}
```

この図の見方を説明します：

- **ノード（状態）**：
  - 円で表現される各ノードが「状態」を表します
  - 「start」と書かれた矢印が指す「初期状態」から開始します
  - 各状態には現在の投入金額が記載されています
- **矢印（遷移）**：
  - 矢印は状態間の「遷移」を表します
  - 矢印上のラベルは「入力/出力」の形式です
    - 「100円」：100円硬貨を投入
    - 「ボタン/商品」：商品ボタンを押すと商品が出る
    - 「ボタン/不足」：商品ボタンを押すがお金が不足
    - 「ボタン/商品+釣」：商品ボタンを押すと商品とお釣りが出る
    - 「100円/返却」：100円を投入するが満杯なので返却される
- **動作の例**：
  1. 初期状態から100円を2回投入 → 200円状態へ
  2. 200円状態で商品ボタンを押す → 商品が出て初期状態へ戻る

この図は、自動販売機の「状態遷移」を完全に表現しています。どの状態からどの入力を受けたらどの状態に遷移するかが一目でわかります。

このように、オートマトンは「状態」と「入力」によって遷移を決定します。自動販売機では、状態はお金の投入状況で、入力はお金の投入や商品ボタンの押下です。

#### 簡単な例：`ab*`を認識するオートマトン

このオートマトン（有限状態機械）を使うと正規表現で表現される言語を認識することができます（正規表現で認識可能な言語は全てオートマトンで表現可能と言い換えててもいいです）。ここでは、正規表現の例として `ab*` を認識するオートマトンを考えてみましょう。

この正規表現は以下のような文字列にマッチします：

- `a`（bが0個）
- `ab`（bが1個）  
- `abb`（bが2個）
- `abbb`（bが3個）
- ...

この正規表現を認識するオートマトンは以下のようになります：

```{=latex}
\begin{center}
\begin{tikzpicture}[
  >=stealth',
  node distance=3cm,
  state/.style={circle, draw, minimum size=10mm},
  accept/.style={state, double}
]
  % 状態の定義
  \node[state] (s0) {0};
  \node[accept] (s1) [right of=s0] {1};
  
  % 遷移の定義
  \draw[->] (s0) -- node[above] {$a$} (s1);
  \draw[->] (s1) edge[loop above] node[above] {$b$} ();
  
  % 開始状態の矢印
  \draw[->] ([xshift=-1cm]s0.west) -- node[above] {開始} (s0);
\end{tikzpicture}
\end{center}
```

- 状態0（開始状態）：最初の状態
- 状態1（受理状態）：この状態で入力が終わればマッチ成功
- 矢印：文字を読んだときの状態遷移

このオートマトンは以下のように動作します：

- 入力"a"：状態0→状態1（**受理**）
- 入力"ab"：状態0→状態1→状態1（**受理**）
- 入力"abb"：状態0→状態1→状態1→状態1（**受理**）
- 入力"b"：状態0で'b'を読めない（**非受理**）

#### 2種類のオートマトン

オートマトンには大きく分けて2種類あります。難しい名前ですが、それぞれの特徴を簡単に説明します：

- **NFA（Non-deterministic Finite Automaton、非決定性有限オートマトン）**
  - 「非決定性」とは、同じ文字を読んだときに複数の選択肢がある
  - 文字を読まずに状態を移動できる（ε遷移）
  - 正規表現から比較的簡単に作れる

- **DFA（Deterministic Finite Automaton、決定性有限オートマトン）**  
  - 「決定性」とは、各状態で各文字に対して次の状態が一意に決まる
  - 文字を読まずに移動することはできない
  - 実装が簡単で、実行速度が速い

この2つのオートマトンは正規表現（正確には後で説明する正規言語）を認識するモデルであり、能力的には等価です。どちらも正規表現を認識できますが、実装の複雑さや速度に違いがあります。

ちなみに、これまで見てきたオートマトンは全て状態遷移が一意に決まるDFAです。DFAは状態遷移が一意に決まるため、実装が非常にシンプルで高速です。

一方で、NFAはそのままでは実装が複雑で遅くなりますが、正規表現からの変換が容易であるという利点があります。

### なぜ正規表現では括弧の対応が扱えないのか

ここまで、正規表現がオートマトンという仕組みで動作することを学びました。では、なぜオートマトン（正規表現）では括弧の対応がチェックできないのでしょうか？その理由を理解するために、簡単な例から考えてみましょう。

括弧の対応を確認するには、以下のような処理が必要です：

  - `(`を読んだら、「今までに読んだ開き括弧の数」を1増やす
  - `)`を読んだら、「対応する開き括弧があるか」確認して、1減らす
  - 最後に、カウントが0であることを確認する

ここで問題になるのは、括弧は何重にでもネスト（入れ子）できるということです。たとえば以下のようなケースを扱える必要があります：

  - `(())`：2重
  - `((()))`：3重  
  - `(((())))`：4重
  - ...無限に続く

#### オートマトンの限界：有限の状態しか持てない

オートマトンは「有限個の状態」しか持てません。仮に10個の状態を持つオートマトンを作ったとしても、11重にネストした括弧は扱えません。どんなに状態数を増やしても、それを超える深さのネストが存在します。

これを具体的に理解するために、簡単なオートマトンで考えてみましょう。仮に「最大3つまでの開き括弧を数える」オートマトンを作ると次のようになります：

```{=latex}
\begin{center}
\begin{tikzpicture}[
  >=stealth',
  node distance=2.5cm,
  state/.style={circle, draw, minimum size=10mm},
  accept/.style={state, double},
  every edge/.style={draw, ->, >=stealth'}
]
  % 状態の定義
  \node[accept] (s0) {0};
  \node[state] (s1) [right of=s0] {1};
  \node[state] (s2) [right of=s1] {2};
  \node[state] (s3) [right of=s2] {3};
  \node[state] (err) [below of=s1] {エラー};
  
  % 開き括弧による遷移
  \draw (s0) edge[bend left] node[above] {(} (s1);
  \draw (s1) edge[bend left] node[above] {(} (s2);
  \draw (s2) edge[bend left] node[above] {(} (s3);
  \draw (s3) edge[bend right=60] node[right] {(} (err);
  
  % 閉じ括弧による遷移
  \draw (s1) edge[bend left] node[below] {)} (s0);
  \draw (s2) edge[bend left] node[below] {)} (s1);
  \draw (s3) edge[bend left] node[below] {)} (s2);
  \draw (s0) edge node[left] {)} (err);
  
  % 開始状態の矢印
  \draw[->] ([xshift=-1cm]s0.west) -- (s0);
\end{tikzpicture}
\end{center}
```

このオートマトンは3つまでの開き括弧なら正しく数えられますが、4つ目の開き括弧が来るとエラー状態に遷移してしまいます。状態数を100個に増やしても、101個の開き括弧には対応できません。

### 実用上の意味

この違いは実用上極めて重要です。以下のような違いがあるからです：

- 正規表現で十分な例：
  - URLの検証
  - 電話番号のフォーマットチェック
  - 単純なトークンの切り出し
  - メールアドレスの簡単な検証

- 文脈自由文法が必要な例：
  - プログラミング言語の構文解析
  - JSONやYAML、XMLのパース
  - 数式の評価（括弧を含む）
  - メールアドレスの完全な検証

### メールアドレスと正規表現の注意点

ところで、メールアドレスの検証は一見簡単だと思われていますが、実は完全な仕様（RFC 5322）は非常に複雑で、厳密にはコメントの入れ子などを許可するため、正規表現では完全に表現できません。たとえば、以下のような入れ子構造をもったールアドレスも仕様上は有効です：

```txt
john.doe@(comment)example.com
john.doe@(comment1(comment2))example.com
```

実用上はaddr-spec（`local-part@domain`の形式）の簡略化されたパターンを正規表現で検証することが一般的ですが、完全な仕様準拠が必要な場合は、専用のパーサーを使用するべきです。

たとえメールアドレスの検証ですら、完全な仕様準拠を目指すなら文脈自由文法の理解が必要になるのです。

### なぜ「文脈自由」なのか？

ここまで文脈自由文法について学んできましたが、なぜ「文脈自由」という名前なのでしょうか？これは、対となる概念である「文脈依存文法」と比較すると理解しやすくなります。

**文脈自由の例**：

```
A → abc
```

この規則では、Aはどこに現れても常に`abc`に置き換えることができます。周りの文脈（前後の文字）に関係なく適用できるので「文脈自由」です。自由というと一見「好きにできる」という印象を受けますが、ここの「自由」は、たとえば、アルコールフリー＝アルコールが含まれない、というのと同じ意味での「自由」です。これについてはContext-free Grammarを「文脈自由文法」を訳したのが良良くなという意見もあります。

**文脈依存の例**：

```
xAy → xabcy
```

この規則では、Aが`x`と`y`に挟まれている時だけ`abc`に置き換えることができます。文脈（周りの文字）に依存しているので「文脈依存」です。

プログラミング言語の構文のほとんどは文脈自由文法で表現できます。たとえば、`if`文の中に`if`文を書けるのは、外側の文脈に関係なく同じ規則が適用できるからです。一方、「変数は使用前に宣言されていなければならない」のような規則は文脈依存であり、構文解析とは別の段階（意味解析）で扱われます。

以下で形式言語の階層をまとめてみます。

- 正規言語（RL: Regular Language）：
  - 正規表現で表現できる**言語の集合**
  - 例：電話番号、識別子、単純なパターン

- 文脈自由言語（CFL: Context-Free Language）：
  - 文脈自由文法で表現できる**言語の集合**
  - 例：プログラミング言語の構文、JSON、XML
  - 正規言語をすべて含む（RL ⊂ CFL）

- 文脈依存言語（CSL: Context-Sensitive Language、文脈依存言語）:
  - 文脈依存文法で表現できる**言語の集合**
  - 例：変数のスコープなど、より複雑な制約
  - 文脈自由言語をすべて含む（CFL ⊂ CSL）

- 帰納的可算言語（RE: Recursively Enumerable Language、帰納的可算言語）:
  - コンピュータで計算できるすべてのもの
  - JavaやPythonなどのプログラミング言語の計算能力はこのレベル
  - 文脈依存言語をすべて含む（CSL ⊂ RE）

階層を図にすると次のようになります。この図は言語の表現力の階層を表しており、内側の言語クラスは外側の言語クラスに完全に含まれます（包含関係）。

```{=latex}
\begin{center}
\begin{tikzpicture}
  % 最外側の楕円 (RE)
  \draw[fill=purple!10,draw=purple!60,thick] (0,0) ellipse (6cm and 4cm);
  \node at (4.5,0) {\textcolor{purple!60}{\large RE}};
  
  % 文脈依存言語 (CSL)
  \draw[fill=blue!10,draw=blue!60,thick] (0,0) ellipse (4.5cm and 3cm);
  \node at (3.2,-0.7) {\textcolor{blue!60}{\large CSL}};
  
  % 文脈自由言語 (CFL)
  \draw[fill=green!10,draw=green!60,thick] (0,0) ellipse (3.25cm and 2.125cm);
  \node at (2.2,-1.2) {\textcolor{green!60}{\large CFL}};
  
  % 正規言語 (RL)
  \draw[fill=orange!10,draw=orange!60,thick] (0,0) ellipse (2cm and 1.25cm);
  \node at (0,0) {\textcolor{orange!60}{\large RL}};
\end{tikzpicture}
\end{center}
```

プログラミング言語の**構文**は文脈自由文法で記述できますが、プログラミング言語自体の**計算能力**はチューリング完全（最上位）です。この違いを理解することが重要です。

## 文法から文字列を作る：導出の仕組み

文脈自由文法は「生成規則」の集まりでした。では、この「生成」とは何でしょうか？

Dyck言語の文法をもう一度見てみましょう：

```txt
D → P
P → ( P ) P
P → ε
```

これらの規則は「置き換えルール」として読むことができます：

- `D → P`：「Dを見たらPに置き換えてよい」
- `P → ( P ) P`：「Pを見たら( P ) Pに置き換えてよい」
- `P → ε`：「Pを見たら空文字列に置き換えてよい」

### 実際に文字列を生成してみる

`()`という文字列を生成する過程を追ってみましょう：

```txt
D               // 開始記号から始める
→ P             // D → P を適用
→ ( P ) P       // P → ( P ) P を適用
→ ( ε ) P       // 最初のPに P → ε を適用
→ ( ) P         // εは空文字列なので消える
→ ( ) ε         // 2番目のPに P → ε を適用  
→ ( )           // εは空文字列なので消える
```

このように、規則を順番に適用して文字列を作ることを**導出**と呼びます。生成すると言い換えても良いでしょう。

### 複数の導出方法

同じ文字列を導出する方法は複数あります。簡単な文法で考えてみましょう：

```txt
S → AB
A → a
B → b
```

この文法から`ab`を導出する時、どちらから先に展開するかで2通りの方法があります：

- 方法1（左から展開）：

```txt
S → AB → aB → ab
```

- 方法2（右から展開）：

```txt
S → AB → Ab → ab
```

### 最左導出と最右導出

このように、好きな順番で非終端記号を展開できるのですが、導出の過程を統一するために2つの標準的な方法が定義されています。

- **最左導出**：常に一番左の非終端記号を展開
- **最右導出**：常に一番右の非終端記号を展開

より複雑な例で見てみましょう。以下の文法は「1個以上のa」の後に「1個以上のb」が続く文字列を表します：

```txt
S → AB
A → aA | a
B → bB | b
```

`aabb`を導出する場合：

- **最左導出：**

```txt
S  
→ AB      (S → AB)
→ aAB     (A → aA)  
→ aaB     (A → a)
→ aabB    (B → bB)
→ aabb    (B → b)
```

- **最右導出：**

```txt
S
→ AB      (S → AB)
→ AbB     (B → bB)
→ Abb     (B → b)  
→ aAbb    (A → aA)
→ aabb    (A → a)
```

### 解析木との関係

どちらの導出方法でも、最終的に同じ**解析木**が得られます：

```{=latex}
\begin{center}
\begin{tikzpicture}[
  level distance=1.5cm,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=1.5cm},
  every node/.style={circle, draw, minimum size=8mm}
]
  \node {S}
    child {node {A}
      child {node[circle, draw=none] {a}}
      child {node {A}
        child {node[circle, draw=none] {a}}
      }
    }
    child {node {B}
      child {node[circle, draw=none] {b}}
      child {node {B}
        child {node[circle, draw=none] {b}}
      }
    };
\end{tikzpicture}
\end{center}
```

最左導出は木を左から右へ構築し、最右導出は右から左へ構築するイメージです。ここで得られた解析木は具体的な文字列の情報を含んでおり、抽象構文木と対比する形で具象構文木と呼ばれることもあります。

### なぜ2つの導出方法が重要か

これらの導出方法は、構文解析の2つのアプローチと関連があります：

- **下向き構文解析**（トップダウン）：文法の開始記号から始めて、入力に合うよう規則を適用していく
- **上向き構文解析**（ボトムアップ）：入力から始めて、段階的に規則を適用して開始記号まで到達する

第3章で作ったJSONパーサーは下向き構文解析の一種でした。ただし、導出と構文解析の対応関係は複雑で、最左導出と下向き構文解析が常に一対一で対応するわけではありません。次章では、これらの手法の実際の動作についてより詳しく学んでいきます。

## まとめ

この章では、文脈自由文法について学びました。最初は難しく感じたかもしれませんが、実は私たちが普段書いているプログラムと深く関わっている概念です。この章で学んだことを整理します。

1. 文脈自由文法の基礎

    - Javaのif文やJSONの構造など、プログラミングの「入れ子構造」は文脈自由文法で表現される
    - BNFから文脈自由文法への変換は記法の違いに過ぎない
    - 生成規則、非終端記号、終端記号という基本要素で構成される

2. 言語を集合として理解する

    - プログラミング言語は「正しいプログラムの集合」として定義できる
    - 集合論の記法を使って言語間の関係を厳密に議論できる
    - 後方互換性なども集合の包含関係として表現可能

3. 正規表現とオートマトン

    - 正規表現は正規言語を表現するための強力なツール
    - NFA（非決定性有限オートマトン）とDFA（決定性有限オートマトン）の違い
    - 正規表現は有限の状態しか持てないため、括弧の対応などの複雑な構造を扱えない

4. 言語の階層

    - 正規表現（正規言語）< 文脈自由文法（文脈自由言語）< ... 帰納的可算言語
    - プログラミング言語の構文解析には文脈自由文法が必要

5. 導出の仕組み

    - 生成規則を適用して文字列を生成する過程が導出
    - 最左導出と最右導出という2つの標準的な方法がある
    - これらは下向き/上向き構文解析に対応する

文脈自由文法の理解は、以下の場面で役立ちます：

- **構文解析器の実装**：第5章以降で学ぶ様々な構文解析アルゴリズムの基礎
- **言語設計**：新しいDSLやプログラミング言語を設計する際の指針
- **エラーメッセージの理解**：コンパイラのエラーメッセージがなぜそう言っているかの理解
- **ツールの選択**：正規表現で十分か、パーサーが必要かの判断

次章ではこの文脈自由文法を基に、実際の構文解析アルゴリズムについて詳しく見ていきます。