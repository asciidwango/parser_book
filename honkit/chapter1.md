# 1. 構文解析の世界へようこそ

皆さん、はじめまして！この本は「構文解析」というテーマについて扱った、一風変わった本です。これまで「構文解析」については、コンパイラや言語処理系を扱った書籍の一部で触れられる程度でした。「Parsing Techniques」とい英語の書籍があるものの、英語圏ですら広く知られているとは言い難いですし、内容も網羅的ではあるものの平易とは言えません。

私がはじめて「構文解析」の入口に立ったのは高校三年生のときでした。当時、私はプログラミング言語に興味を持ち始め、いつかは自分のプログラミング言語を書いてみたいと思っていました。しかし、高校の図書館にあった「プログラミング言語を作る」本を借りて読んでみたももの、とても難しく当時の私には理解できませんでしたし、コンパイラ開発者のバイブルともよばれる「ドラゴンブック」も同様でした。

何がきっかけかは覚えていないのですが、いきなり大きな言語を作ろうとしても難しいということでまずは括弧を含む算術式を計算できる「電卓」アプレットを作ることにしました。といっても非常に単純なもので

```sh
(1 + 2) * (3 + 4) 
```

のようにテキストフィールドに入力して「計算」ボタンを押すと`21`と表示される、ただそれだけの代物です。今振り返れば、このアプレットはごく初歩的な「構文解析」と「インタプリタ」を実装したものとも言えます。

ただし、当時の私は言語処理系を作る際に必須の知識がほとんどなく、抽象構文木も典型的な構文解析のアルゴリズムも知らず、足りない知恵を振り絞って括弧の対応や演算子の優先順位を自力で計算したのでした。それは本当に拙いものでしたが、それでもなんとか動くものを作ることができたのです。

それから二十年余り。筆者は現在、研究職ではないものの構文解析の中の一分野である、Parsing Expression Grammar（PEG）を専門として、時折関連する論文の査読を引き受けたりしています。

現在の私は研究に未練を残しつつちょっとアカデミアに関わりがある微妙な立場ですが、そんな中でも折に触れて思うことがありました。構文解析はなぜ、一般の技術書であまり取り上げられないのだろうか、ということです。

もちろん、言語処理系を扱う書籍の一部として構文解析が取り上げられることは決して珍しくありません。しかし、その扱いはあくまで「おまけ」であって、言語を作る上での通過点としてしか位置づけられていません。これについては、言語の本質は構文解析の「後」にあるのであり、構文は本質ではないというのが大きいでしょう。筆者もこの点に異論はありません。ただ、構文（正確には具象構文）はほんとうに「おまけ」なのでしょうか。ときどき疑問に思います。


もちろん、プログラミング言語屋さんの間では一般に、言語の「意味」は抽象構文木に対して定められるものであり、構文は「ガワ」に過ぎないという考えも間違ってはいないでしょう。しかし、現実に我々が読み書きするプログラムは木そのものではなく、文字列としてシリアライズされたテキストです。この立場からは構文はUIであると言えます。多くのアプリケーションにおいてUIが果たす役割は非常に大きく、UI自体が専門分野として存在しているくらいです。そのUIたる構文とUIを適切な内部構造に変換する構文解析は軽視されていいのだろうか。筆者が構文解析の本を書こうと思い立ったのはそんな「こだわり」からでした。

ともあれ、本書の読者の皆さんには、構文解析の世界を少しでも楽しんでいただければと思います。構文解析は非常に奥深いテーマであり、その奥深さを一冊の本で完全に網羅することはできません。しかし、本書を通じて構文解析の基礎を学び、その面白さを感じていただければと思います。

たとえば、そもそも構文解析とは何でしょうか。実はこの問いだけをとっても答えは一つではありません。

たとえば、入力文字列を引数にとって文法に沿っているかどうかを真偽値として返す手続きを構文解析とみなす立場があります。このような場合、構文解析は以下のようなメソッドとして表現できます。

```java
boolean parse(String input);
```

入力文字列を引数にとって、文法に沿っているならば抽象構文木を、そうでなければエラーを返す手続きを構文解析とみなす立場もあります。この場合、構文解析は以下のようなメソッドとして表現できます。

```java
sealed interface ParseResult permits ParseResult.Success, ParseResult.Failure {
  record Success(Tree ast) implements ParseResult {}
  record Failure(String errorMessage) implements ParseResult {}
}
ParseResult parse(String input);
```

その他にも色々な立場を取ることができるでしょう。ともあれ、非自然言語の「構文解析」というテーマはあまり大きく扱われることが少ないですが、奥が深いものです。

皆さんが普段もっとも身近に使っている言語の1つであろうJavaScript（ないしECMAScript）を例にとって、この問題の奥深さについて説明してみます。

以下のJavaScriptプログラムを構文解析してみることにします。

```js
x = 1 +
  2
```

直観的には、以下のような木（抽象構文木）が結果として返ってくるのが正しいように思われます（抽象構文木の説明は、いったんおいておきます）。

```
  =
 / \
x   +
   / \
  1    2
```

では、次のJavaScriptプログラムはどうでしょうか？

```
x = 1
+ 2
```

JavaScriptに詳しくない人にとって以外かもしれませんが、以下のような結果になります。

```
    ;
   /  \ 
  =    +
 / \   |
x   1  1
```

`+`の後で改行するか後で改行するかという一見**ささいな違い**によって、構文解析の結果が変わってしまうということが重要です。

2000年以降に登場して普及した言語は、このような特徴を持っていることが多いです。たとえば、Go、Swift、Kotlin、Scalaの文法はこのような特徴を持っています。

もっと古い言語でもRubyやPythonも同じ特徴を持っています。このような一見ちょっとした違いで構文解析結果が変わってしまう例は珍しくありません。

このような文法の「進化」の背景には、プログラマにとってより「書きやすく読みやすい」文法を提供するという意図があります。このような「改行に敏感な」文法は構文解析の複雑さを増大させることになりますが、ユーザーにとってはより簡単に感じられるため広く普及するに至ったのでしょう。

しかし「構文解析の複雑さを増大させる」というのは一体どういうことでしょうか。おそらくは直観的にはピンと来ないのではないでしょうか。この本では、このような問いに対して一定の答えを提示することを目指します。「目指す」というのはなんとも頼りない表現ですが、「構文解析の複雑さ」を定量的に評価するための枠組みがないため、どうしてもこのような表現になってしまいます。

また、ユーザーの皆さんは既存の「言語」に歯がゆさを感じたことはないでしょうか。たとえば、昨今はJSONやYAMLを用いてDSL (Domain Specific Language)を提供することが一般的になっていますが、これらのDSLはJSONやYAMLの文法の枠に収めるために無理をしており、どうしても「不自然」な文法になってしまいます。JSONやYAMLは世界中に普及していますから合理性はあるもの、場合によってはJSONやYAMLに縛られないDSLの文法を考案することが求められることもあるでしょう。そのためには構文解析の知識が必要です。

さらに、構文解析は単に実用的であるにとどまらず非常に「楽しい」テーマです。読者の皆さんには本書を通じて、是非「構文解析の面白さ」を感じていただければと思います。

本書は次のような構成になっています。

第2章ではJSONの構文解析機を作ることを通して、構文解析とはどういう処理かを体感してもらいます。定義を天下り式に提示するような本もありますが、構文解析については「まずは書いてみる」のが手っ取り早いというのが筆者の持論です。

第3章では文脈自由文法について解説します。文脈自由文法は構文解析の基礎です。括弧の対応を表現する言語を`Duck`言語と言いますが、`Duck`言語はまさに文脈自由言語を特徴づけるものです。この章を理解することで文脈自由文法の直観的な理解が得られます。現代の構文解析の大半は文脈自由文法を基盤としていますから、文脈自由言語の概念を理解することは非常に重要です。

第4章では実際に使われている色々な構文解析アルゴリズムについて解説します。皆さんの中にも`LL(1)`や`LALR(1)`といった言葉自体は耳にしたことがある方も多いのではないでしょうか。この章ではできるだけ平易な形でそれらの実際に使われている構文解析アルゴリズムについて解説します。PEGなどの比較的「新しい」構文解析アルゴリズムも取り扱います。

第5章では構文解析機生成系について解説します。`Yacc`のような多くの方が一度は聞いたことがあるものにとどまらず、`ALL(*)`アルゴリズムを基盤にした`ANTLR`やPEGを基盤にしたパーザコンビネータなど、最新の構文解析機生成系について説明します。さらに、簡単なパーザコンビネータを自作します。パーザコンビネータは元々は関数型プログラミング言語からでてきたテクニックですが昨今では色々な言語でパーザコンビネータライブラリがあります。パーザコンビネータそのものは構文解析機生成系とは若干違いますが、自作する体験を通じて「文法の定義から構文解析機を生成する」とはどういうことか理解してもらえるのではないかと思います。

第6章では従来の言語処理系についての本が取り扱わなかった「現実の構文解析」の話をします。書籍に書かれている構文解析の世界は通常、とても「綺麗」なものです。しかし、RubyでもPythonでもあるいはJavaScriptでも良いですが、現実の構文解析は必ずしもそこまで綺麗にはいかないものです。この章を通して現実の言語における構文解析はとても泥臭いものであること、その泥臭さを通して「書きやすく読みやすい」文法が実現されていることを実感してもらえるのではないかと思います。