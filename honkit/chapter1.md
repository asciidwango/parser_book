# 1. 構文解析の世界へようこそ

この本は、「構文解析」というテーマについて扱った、一風変わった本です。これまで、「構文解析」については、コンパイラや言語処理系を扱った書籍で、その一部で触れられる程度でした。英語の書籍としては、「Parsing Techniques」という書籍があるものの、広く知られているとは言い難いですし、内容も網羅的ではあるものの、決して平易とは言えません。

筆者は、構文解析の中の一分野である、Parsing Expression Grammar（PEG）を専門としています。PEGは、特に、構文解析に特化した、文法の表記法ですが、その探求を続けて行く中でずっと抱いていた疑問がありました。それは、「構文解析とはいったい何なのだろう」というものです。

この問いに対するもっともよくありそうな答えとしては、「入力文字列を引数にとって、文法に沿っているかどうかを真偽値として返す」という手続きを、構文解析としてみなす、という答えがもっともありふれたものでしょう。あるいは、「入力文字列を引数にとって、文法に沿っているならば、その抽象構文木を、そうでなければ、エラーを返す」という手続きを構文解析とみなすという立場もあるかもしれません。

ただ、どの立場に立つにせよ、「構文解析」というテーマというのは一見簡単なようでいてとても奥が深い問題です。

皆さんが普段もっとも身近に使っている言語の一つであろうJavaScript（ないしECMAScript）を例にとって、この問題の奥深さについて説明してみます。

試しに、以下のJavaScriptプログラムを構文解析してみることにします。

```js
x = 1 +
  2
```

直観的には、以下のような木（抽象構文木）が結果として返ってくるのが正しいように思われます（抽象構文木の説明については、いったんおいておきます）。

（TODO: そもそも、この本の著者はどの程度の前提知識を持っていると仮定していいのか。プログラムを木ととらえる見方から説明しなければいけないのだと、根本的に説明の仕方を変える必要がありそう）

```
  =
 / \
x   +
   / \
  1    2
```

では、次のJavaScriptプログラムはどうでしょうか？

```
x = 1
+ 2
```

これは（JavaScriptに詳しくない人にとって以外かもしれませんが）以下のような結果になります。

```
    ;
   /  \ 
  =    +
 / \   |
x   1  1
```

ここで、*`+`の後で改行するか、後で改行するか*という一見ささいな違いによって、構文解析の結果が変わってしまうということが重要です。

特に、2000年以降に登場して、普及した言語は、このような特徴を持っていることが多いです。たとえば、Go、Swift、Kotlin、Scalaなどの文法はこのような特徴を持っています。

このような、一見ちょっとした違いで構文解析結果が変わってしまう例は珍しくありません。
