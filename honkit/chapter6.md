# 6. 現実の構文解析

ここまでで、LL法やLR法、Packrat Parsingといった、これまでに知られているメジャーな構文解析アルゴリズムを一通り取り上げてきました。これらの構文解析アルゴリズムは概ね文脈自由言語あるいはそのサブセットを取り扱うことができ、一般的なプログラミング言語の構文解析を行うのに必要十分な能力を持っているように思えます。

しかし、構文解析を専門としている人や実用的な構文解析器を書いている人は直感的に理解していることなのですが、実のところ、既存の構文解析アルゴリズムだけではうまく取り扱えない類の構文があります。一言でいうと、それらの構文は文脈自由言語から逸脱しているために、文脈自由言語を取り扱う既存の手法だけではうまくいかないのです。

このような、既存の構文解析アルゴリズムだけでは扱えない要素は多数あります。たとえば、Cのtypedefはその典型ですし、RubyやPerlのヒアドキュメントと呼ばれる構文もそうです。他には、Scalaのプレースホルダ構文やC++のテンプレート、Pythonのインデント文法など、文脈自由言語を逸脱しているがゆえに人間が特別に配慮しなければいけない構文は多く見かけられます。

また、これまでの章では、主に構文解析を行う手法を取り扱っていましたが、現実問題としては抽象構文木をうまく作る方法やエラーメッセージを適切に出す方法も重要になってきます。

この章では、巷の書籍ではあまり扱われない、しかし現実の構文解析では対処しなくてはならない構文や問題について取り上げます。皆さんが何かしらの構文解析器を作るとき、やはり理想どおりにはいかないことが多いと思います。この章がそのような現実の構文解析で遭遇する読者の方々の助けになれば幸いです。

## 6.1 字句要素が構文要素を含む文法

最近の多くの言語は文字列補間(String Interpolation)と呼ばれる機能を持っています。

<!--
  Ruby、Scala、Kotlinといった様々な言語が持つ、文字列補間（String Interpolation）
  を例として解説する。
-->

## 6.2 インデント文法

<!--
Pythonのインデントによりプログラムの構造を表現する文法を例とする。
-->

## 6.3 ヒアドキュメント

<!--
Rubyのヒアドキュメントをパーズすることの難しさを說明する。
-->

## 6.4 改行終端可能文法

<!--
Ruby、Scala、Kotlin、Swift、Goなどの、改行によって文や式といった単位を終端
させることができる文法をパーズすることのめんどくささを說明する。
-->

## 6.5 Cのtypedef

<!--
Cのtypedefの解析が意外と難しいことを解説する。
-->

## 6.6 Scalaのプレースホルダ構文

<!--
Scalaのプレースホルダ構文が非文脈自由であり、かつ取り扱いが非常に複雑であることを説明する。
-->

他にも思いついたら追加するかも

## 6.6 まとめ