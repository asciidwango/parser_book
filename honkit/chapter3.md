# 第3章 文脈自由文法の世界

第3章では、JSONの構文解析器を記述することを通して、基本的な構文解析の方法を学びました。また、構文解析器についても、PEG型の構文解析器および字句解析器を使った二通りを作ってみることで、構文解析器といっても色々な書き方があるのがわかってもらえたのではないかと思います。

この第4章では、現代の構文解析を語る上で必須である、文脈自由文法という概念について学ぶことにします。「文脈自由文法」というと、一見、堅くて難しそうな印象を持つ方も多いかもしれません。しかし、一言で言ってしまえば、BNFをよりシンプルに、数学的に厳密にしただけのものであって、厳しい言葉から漂う程難解な概念ではありません。一方で、「文脈自由文法」という概念を習得することによるメリットは計り知れないものがあります。たとえば、それによって、正規表現で記述出来ないが文脈自由言語（BNFと表現力では等価）で記述出来る「言語」を知ることが出来ますし、文脈自由言語では記述不可能な「言語」について知ることも出来ます。

さて、文脈自由文法の世界に飛び込んで見ましょう。

## 3.1 BNFと文脈自由文法

さて、いきなり文脈自由文法の定義を大上段に示しても抽象的過ぎますので、まず、比較的皆様に馴染みがあるBNFを文脈自由文法を用いた記述に変換することで、文脈自由文法についての理解のとっかかりとしたいと思います。お題は、「カッコの釣り合いの取れた文字列」です。

たとえば、

```
()
(())
((()))
(((())))
```

はカッコの釣り合いの取れた文字列の例です。一方で、

```
)(
(()
(()())
```

はカッコの釣り合いの取れていない文字列の例です。このような言語をDyck（ディック）言語と呼び、文脈自由文法を特徴づける言語とされています。

このDyck言語の文法を擬似BNFで記述してみると以下のようになります。

```bnf
D = P
P = "(" P ")" | ""
```

Dが構文解析の際に最初に参照される記号で開始記号と呼ばれます。さて、このBNFを文脈自由文法による記述になおしていきましょう。そのためには、まず、一番外側にある"|"を消去する必要があります。同時に、"="は"→"に置き換えます。

さて、早速置き換えてみましょう。

```cfg
D → P
P → "(" P ")"
P → ""
```

あれ？同じ名前Pを持つ記号が二つ出てきてしまいましたね。実は、文脈自由文法（の標準的な表記法）では、同じ名前の規則は複数出てきても構いません。その場合の解釈は、とりあえずBNFで同名の規則を"|"でくくった場合と同じようなものと思ってもらって構いません。

次に、これはどちらでもいいといえばいいのですが、慣習上、文脈自由文法を表記する上では、空文字列はεと書くことになっているので、これも置き換えましょう。

```cfg
D → P
P → "(" P ")"
P → ε
```

さらに、文脈自由文法では、「文字列リテラル」というものはなく、そのまま列を表記しますから、"("も(のように表記します。すると、以下のようになります。

```cfg
D → P
P → ( P )
P → ε
```

このようにして変換して出来た文脈自由文法（の一つ）ですが、この中で、

```cfg
D → P
```

のような、→で区切られた右と左をあわせて、生成規則と呼びます。また、DやPを非終端記号と呼び、'('は終端記号と呼ばれます。このようにして見ていくと、文脈自由文法とは、

- 生成規則の0個以上の並び

からなっており、各生成規則は、

- 左辺は、一個の終端記号
- 右辺は、一個以上の終端記号または非終端記号の並び

からなっていることがわかります。改めて、Dyck言語の、BNFによる表現と、文脈自由文法による表現を見てみることにします。

まず、BNFによる表現です。

```bnf
D = P
P = "(" P ")" | ""
```

次に、これを文脈自由文法に変換したものです。

```cfg
D → P
P → ( P )
P → ε
```

多少、表記として冗長になりましたが、そこまで大きくは変わらないことがわかると思います。さて、では、何故、BNFという表記法でなく、文脈自由文法に変換するかといえば、ひとえにそれは、4章以降で示す種々の構文解析アルゴリズムの多くが、文脈自由文法をベースに構築されているからです。また、構文解析を語る上で書かせない、構文木という概念を説明するためにも、文脈自由文法という概念は重要になります。以降の節では、このDyck言語を表現した文脈自由文法を元に、構文解析の基礎をなす様々な概念について説明していきます。

## 3.2 文脈自由文法と言語

さて、前の節で、Dyck言語について説明しましたが、その定義は以下のようなものでした。

```cfg
D → P
P → ( P )
P → ε
```

ところで、これまでは、「言語」という用語を明確な定義なしに使っていました。「言語」という言葉を一般的な文脈で使ったときに多くの人が思い浮かべるのは、日本語や英語、フランス語、などのいわゆる自然言語でしょう。ただ、この書籍で扱う「言語」は、主にプログラミング言語のような**曖昧さ**を持たないものです。たとえば、JavaやRuby、Pythonといったプログラミング言語の文法には曖昧さがなく、同じテキストは常に同じプログラムを意味します。

さて、では、たとえば、Java言語といったときに、この「言語」が指すものは何なのでしょうか？文脈自由文法のような形式文法の世界では、「言語」を**文字列の集合**として取り扱います。といっても、これでは、若干抽象的ですね。たとえば、以下のHello, World!プログラムは、Java言語のプログラムですが、文字列として見ることも出来ます。

```java
public class HelloWorld { public static void main(String[] args) { System.out.println("Hello, World!"); }}
```

さらに、別のプログラムとして、3を表示するだけのプログラムを考えてみます。一番単純な形は以下のようになるでしょう。

```java
public class Print3 { public static void main(String[] args) { System.out.println(3); }}
```

このようにして、「Java言語のプログラムとして認められる文字列」を列挙していくと、次のようになります。

```
{
  "public class HelloWorld { public static void main(String[] args) { System.out.println("Hello, World!"); }}",
  "public class Print3 { public static void main(String[] args) { System.out.println(3); }}",
  "public class Print4 { public static void main(String[] args) { System.out.println(4); }}",
  ...
}
```

Java言語のプログラムとして認められる文字列は無数にありますから、このような言語（＝文字列の集合）は多くの場合、**無限集合**になります。

別の例として、同様に、Rubyを「言語」として見ると次のようになります。

```
{
    "puts 'Hello, World!'",
    "puts 1",
    "puts 2",
    ...
}
```

Java言語と同様に、Rubyプログラムとして認められる文字列は無数にあるので、やはり無限集合となります。

さて、例をDyck言語に引き戻して、Dyck言語は一体何なのかを考えてみます。Dyck言語とは、「括弧の釣り合いが取れた文字列」を表すものでした。ということは、括弧の釣り合いが取れた文字列を集合として考えればいいことになります。

```
{
    "()",
    "(())",
    "((()))",
    "(()())",
    ...
}
```

というわけで、言語を文字列の集合として見ることについて、なんとなくは掴めて来たのではないかと思います。では、言語をこう見る意味は一体何なのでしょうか？

まずは、こう見ることによって、言語というものを、集合論の立場で論じられることが一番大きいです。たとえば、上記のDyck言語を表す無限集合をDKと表記したとします。この時、Dyck言語の条件を満たす文字列"()"について、

```
"()" ∈ DK
```

と表記する事が可能になります。一方で、Dyck言語でない文字列")("は、

```
")(" ¬∈ DK
```

と表記することが可能になります。DKは単なる集合なので、皆さんが中学や高校で習ったように、和や積などについて考えることができます。たとえば、Ruby言語を表す無限集合をRBと考えたとき、二つの集合の和RB∪DKを考えることが出来ます。RB∪DKは以下のようになります。

```
RB ∪ DK = {
  "()",
  "puts 1",
  "(())",
  "puts 2",
  ...
}
```

また、二つの集合の積RB∩DKを考えることも出来ます。RB∩DKは以下のようになります。

```
RB ∩ DK = {}
```

明らかに、Ruby言語のプログラムでかつDyck言語であるような文字列は存在しませんから、RB∩DKは**空集合**になります。

このように、集合論の道具を自由に使えるので、たとえば、Java 5のプログラムを表す集合をJ5、Java 8のプログラムを表す集合をJ8とすると、

```
J5 ⊂ J8
```

と表記することが出来ます。Javaは概ね、バージョンが上がっても、後方互換性を維持していると言われますが、集合論上はこのように考えることも出来るわけです。

## 3.3 文脈自由言語と言語の階層

ここまでで見て来たように、**ある**文脈自由文法は、言語、つまり、文字列の集合を定義するのでした。ところで、**全ての**文脈自由文法、言い換えれば文脈自由文法自体の集合はどのようなものになるのでしょうか？

これを考えるためには、おそらく皆さんが普段駆使しておられる正規表現を思い浮かべてもらうのがわかりやすいと思います。正規表現については既にご存知の読者も多いかと思いますが、知らない方もいると思うので念のため解説します。正規表現は**文字列のパターン**を定義するための言語です。現代のプログラミング言語で使用されている正規表現は様々な拡張が入っているため複雑になっていますが、ここでは本来の正規表現にとって重要なパーツのみを扱います。

以下が正規表現を構成する要素です。`e1`や`e2`、`e`はそれ自体正規表現を表していることに注意が必要です。また、`a`は任意の文字1文字を表します。

```
a: 文字
ε: 空文字列
e1 e2: 連接
e1 | e2: 選択
e*: 繰り返し  
```

正規表現はこれだけのシンプルな規則によって構成されますが、実に多様なパターンを表現することができます。たとえば、以下は自然数を表現する正規表現です。

```
0|(1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*
```

実用的な言語に実装されている正規表現エンジンでは文字クラスと呼ばれる機能を使って`0|[1-9][0-9]*`のように書くことができますが実質的な意味は同じです。あるいは、7桁の郵便番号は同じように文字クラスを用いて次のような正規表現で表すことができます（文字クラスはシンタックスシュガーなのでなくても同等の記述は可能ですが、説明を簡潔するために以降では文字クラスを使って表現します）：

```
[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]
```

これも多くの言語に実装されている正規表現エンジンを使えば`[0-9]{3}-[0-9]{4}`のように書くことができますが、`e{n}`で`e`の`n`回の繰り返しを表現するのは、文字クラスと同様に単なるシンタックスシュガーです。

正規表現はWebアプリケーションのフロントエンドにおけるバリデーションをはじめとして色々な分野で使われており、正規表現によって非常に幅広い範囲の文字列集合、つまり言語を表現することができます。しかし、この強力な正規表現にも限界があります。


正規表現の集合（これを正規言語と呼び、本書ではRLと表記します）が表すことが出来ないことを証明されている典型的な言語の一つがDyck言語です。つまり、

```
DK ¬⊂ RL
```

となります。さらに話を進めると、文脈自由文法が表す言語の集合（これを文脈自由言語と呼び、本書ではCFLと表記します）とRXについては、次のような関係がなりたちます。

```
RL ⊂ CFL
```

これが意味していることは、文脈自由文法では正規表現で表現可能なあらゆる文字列を表現可能だが、逆は成り立たないということです。つまり、どう頑張っても正規表現だけでは表現不能な文字列が存在するということです。これは単に理論上の話ではなく実用上大きな問題として立ちはだかります。たとえば、プログラミング言語ではDyck言語のような「括弧の対応がとれていなければエラー」という文法が頻繁に登場しますが、これは正規表現では書けないわけです。

Dyck言語に特徴づけられる「括弧の対応を計算できる」ことに文脈自由文法の利点があるわけですが、では、文脈自由文法だけであらゆる種類の文字列の集合を定義可能なのでしょうか？これは、ぱっと見では自明ではありませんが、不可能であることが証明されています（形式言語理論の教科書を開けばほぼ必ず出てくる話です）。たとえば、aをn回、bをn回、cをn回だけ（n ≧＝ 0）並べた文字列を表す言語`a^nb^nc^n`は、文脈自由文法で定義不可能です。一方で、この言語は文脈依存言語（本書では、CSLと表記）で定義可能であり、かつ、CFLはCSLの真部分集合です。このようにして、言語の表現能力には階層があり、

```
RL ⊂ CFL ⊂ CSL ⊂ ...
```

と言うことが可能です。ここで、REやCFL、CSLは言語の集合であり、言語そのものと区別するために言語クラスと呼ばれます。言語クラスとしてはRL（正規言語）よりもCFL（文脈自由言語）の方が強力であり、CFLよりCSL（文脈依存言語）方が強力ということですね。

現時点でもっとも最強の言語クラスは、帰納的加算言語と呼ばれており、現存するほとんど全てのプログラミング言語の能力と一致します。ほとんど全てのプログラミング言語はチューリング完全であるという意味で能力的に等しいということを聞いたことがあるプログラマーの方も多いかもしれませんが、形式言語の文脈で言い換えれば、ほとんど全てのプログラミング言語で生成可能な言語（＝文字列集合）の全体は帰納的加算言語とちょうど一致するということになります。