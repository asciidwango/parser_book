# 第2章 構文解析の基本

この章からいよいよ構文解析についての説明を始めたいと思います。とはいっても本書を手に取った皆様は構文解析についてまだ馴染みがないかと思います。そこで、まずは第1章でみたような算術式の構文解析を例にして、構文解析の基本について学ぶことにしましょう。

## 2.1 算術式の文法

ただ「算術式」といっただけだと人によってかなりイメージするものが異なります。本書では以下の条件を満たすものを算術式とします。

- 四則演算が使える
  - 足し算は`x + y`
  - 引き算は`x - y`
  - 掛け算は`x * y`
  - 割り算は`x / y`
- 優先順位は掛け算・割り算が高く、足し算・引き算が低い
  - たとえば、`1 + 2 * 3`は`1 + (2 * 3)`と解釈される
- 同じ優先順位の演算子は左から右に結びつく
  - たとえば、`1 + 2 - 3`は`(1 + 2) - 3`と解釈される
- 値は整数のみ
  - たとえば、`1 + 2.0`のような式はエラーになる
- 式の優先順位を変えるために括弧を使うことができる
  - たとえば、`(1 + 2) * 3`は`3 * 3`と解釈される
- スペースは使えない
  - たとえば、`1+2`はOKだが、`1 + 2`はエラーになる

最後の「スペースは使えない」という制限は、字句解析（文字列を意味のある単位、トークンに分割する処理）を単純化し、この章では構文解析の核となる考え方に集中するために設けています。実際のプログラミング言語ではスペースやコメントは無視されるのが一般的ですが、その処理は後の章で触れることにします。

この定義に従う算術式には以下のようなものが含まれます。

```text
1+2*3
(1+2)*3
3*(1+2)
12/3
1+3*4/2
```

普段、皆さんは何かしらのプログラミング言語を使ってプログラムを書いているはずですから、上のような算術式は馴染みが深いはずです。

しかし、上のような日本語を使った定義だけでは算術式の文法を表現するのには不十分です。たとえば「式の優先順位を変えるために括弧を使うことができる」といっても、なんとなくはわかるものの、定義としては曖昧です。

もちろん、日本語で詳しく記述して曖昧さを少なくしていくこともできますが、いたずらに長くなるだけです。それよりも、文法を表現するための文法である**形式文法**を使って、算術式の文法を表現することが一般的です。形式文法というと何かしらとても難しいもののように感じられますが、実際には簡単なものです。次節では形式文法の一つであり、もっともメジャーな表記法であるBNF（Backus-Naur Form、バッカス・ナウア記法）を使って、算術式の文法を表現してみましょう。

## 2.2 算術式のBNF

プログラミング言語の文法自体を表現する文法（メタ文法といいます）の一つに、BNFがあります。BNFは、プログラミング言語の文法をはじめ、インターネット上でのメッセージ交換フォーマットなど、様々な文法を表現するのに使われています。本書の読者の方にはBNFに馴染みのない方も多いと思うので、算術式のBNFの前にBNFについて説明します。本書では、記述を簡潔にするため、ISO/IEC 14977で仕様が策定されたEBNF[^1]で用いられる繰り返し（`{}`）、オプション（`[]`、本書の例では未使用）、グループ化（`()`）といった拡張記法を一部取り入れ、これを広義のBNFとして扱います。BNFには歴史的に多くの方言が存在するため、本書で用いる記法について事前に説明しておきます。

### 2.2.1 BNFの概要

BNFはFortranの開発者でもある、John Backus（ジョン・バッカス）らが開発した記法です。BNFは「プログラミング言語」そのものの文法を記述するために開発されました。基本情報技術者試験でも出題されるので、そこで知った方もおられるかもしれません。

では早速、BNFの具体例を見て行きましょう。以下の例は2.1で出てきた算術式を元に、

- 扱える数値は一桁だけ

のように単純化したBNFです。

```bnf
expression = term { ('+' | '-') term };
term = factor { ('*' | '/') factor };
factor = NUMBER | '(' expression ')';
NUMBER = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
```

たくさんの記号が出てきましたが、順番に見ていきましょう。

### 2.2.2 expression

BNFでは、以下のような**生成規則**の集まりによって、文法を表現します。

 ```
expression = term { ('+' | '-') term };
 ```

`=`の左側である`expression`が**規則名**で、右側が**本体**になります。

ここでは 

```
term { ('+' | '-' ) term }
```

が本体になります。

本体の中に出てくる、他の規則を参照する部分（ここでは`term`)を**非終端記号**と呼び、これは同じBNF内で定義されている規則名と一致する必要があります。

また、`'+'`や`'-'`のように`'`で囲まれた記号や文字を**終端記号**と呼びます。これはそのままの文字（あるいは文字列）である必要があり、その文字自身を表します。

BNFにおいて`{}`で囲まれたものは、その中の要素が0回以上繰り返して出現することを示しています。したがって、`term { ('+' | '-') term }`という記述は、まず`term`が出現し、その後に「`+`または`-`の演算子とそれに続く`term`」というペアが0回以上繰り返して出現することを示しています。結果として、`term`が1つ以上、演算子を挟んで並ぶ形になります。
  
この規則を日本語で表現すると「`expression`という名前の規則は、右辺の定義 `term { ('+' | '-') term }` に従って構成される」と読むことができます。

なお、本来の（ISO/IEC）BNFでは

```
expression = term, { ('+' | '-'), term };
```

のように要素間をカンマで区切りますが、本書では可読性を考慮してスペースで区切るようにしています。

### 2.2.3 term

`term` は算術式の中で、掛け算や割り算を含んだ式を表す規則です。`factor`という規則を参照しています。

```bnf
term = factor { ('*' | '/') factor };
```

この規則によって`term`は、`factor`が`*`または`/`を挟んで1回以上繰り返して出現することを示しています。

### 2.2.4 factor

`factor`は算術式の中で、数値や括弧で囲まれた式を表す規則です。

```bnf
factor = NUMBER | '(' expression ')';
```

これによって`factor`は、

- `NUMBER`
- `(`と`)`に挟まれた`expression`

のどちらかであることを示しています。

### 2.2.5 NUMBER

`NUMBER`は数値を表す規則です。

```bnf
// 数値は1桁の整数に限定
NUMBER = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
```

これによって、`NUMBER`は`0`から`9`のどれか1文字であることを示しています。

## 2.3 BNFを使った解析プロセス

算術式の文法を規則`expression`を含むBNFで表現することができました。さて、規則`expression`を使うと、式`1+2`はどのように解析できるのでしょうか？ここでは、その概要について簡単に説明します。

BNFという宣言的な記法を使って算術式の文法を**曖昧でない形で**表現することができましたが、この文法を使って解析を行うためには、手続き的な記述が必要です。その手続き的な記述がまさに構文解析アルゴリズムであり、具体的なアルゴリズムについては第5章で詳しく説明しますが、ここでは、BNFを使って算術式を解析するプロセスの概要を説明します。

まず、BNFの規則を関数とみなします。

たとえば、規則`expression`は関数`expression`に対応し、規則`term`は関数`term`に対応します。これらの規則に対応する関数は、解析したい文字列と文字列の添字を引数に取り、解析の結果を返します。

この関数の宣言をJavaライクな擬似コードで表すと、以下のようになります。

```java
ParseResult expression(String input, int index);
```

次に関数の呼び出しを構文解析とみなします。引数として解析したい文字列と、解析を開始する位置を渡すと、構文解析結果が返ってくるものとします。

たとえば、`expression("1+2", 0)`という関数呼び出しは、文字列`"1+2"`の先頭から解析を開始することを示します。まだ`expression`の本体がありませんが、結果としては、解析が成功した旨の情報がかえってきて欲しいでしょう。一方、`expression("1+", 0)`という関数呼び出しは、解析が失敗した旨の情報がかえってきて欲しいはずです。

関数の呼び出し結果は、

- 解析に成功した場合：成功したことを表す情報と、どこまで読み進んだかを示す位置（例えば、次の解析を開始すべき入力文字列中のインデックス）。これを`(SUCCESS, new_index)`と表す
- 失敗した場合：失敗を表す定数`FAIL`を返す

のどちらかであるものとします。

1. 規則`expression`を呼び出す

まず、最上位の規則`expression`を呼び出します。これは`expression("1+2")`となります。

```bnf
expression = term { (`+` | `-`) term }
```

規則の本体では`term`が最初に出現するので、規則`term`を適用します。つまり、`term("1+2")`となります。

2. 規則`term`を呼び出す

規則`term`は以下のようになっています。

```bnf
term = factor { (`*` | `/` ) factor }
```

`term`の本体では`factor`が最初に出現するので、規則`factor`を適用します。つまり、`factor("1+2")`となります。

3. 規則`factor`を呼び出す

規則`factor`は以下のようになっています。

```bnf
factor = NUMBER | '(' expression ')'
```

`term`の本体は`NUMBER`か`'(' expression ')'`のどちらかですが、`"1+2"`の先頭は`NUMBER`になります。したがって、`NUMBER`を適用します。これは`NUMBER("1+2")`となります。

4. 規則`NUMBER`を適用

規則`NUMBER`は以下のようになっています。

```bnf
NUMBER = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
```

今、文字列の0番目と規則を照合しようとしているわけですが、`"1+2"`の0番目の文字は`1`です。したがって、`NUMBER`の本体の内、`1`との照合に成功します。

この結果、`NUMBER`の解析は成功し、入力文字列の次の解析開始位置は`+`の直前（インデックスで言えば1）になります。これを`(SUCCESS, 1)`のように表すことにします（ここでは残りの文字列そのものではなく、次の開始位置のインデックスを返すイメージです）。

また、解析が成功したので、`NUMBER`の呼び出しから戻ります。

5. 規則`term`の解析を続行

`NUMBER`から戻ってきた先は、規則`factor`の中で、`factor`の「次」です。↑で現在照合を進めている場所を表すとしたら、次のようになります。

```bnf
term = factor ↑ { (`*` | `/` ) factor }
```

次に、`term`の本体の中で残りの部分である

```text
{ ('*' | '/') factor }
```

を照合します。現在の解析位置から始まる文字列は`"+2"`です。この先頭文字`+`は、`'*'`でも`'/'`でもないため、`('*' | '/')`との照合に失敗します。
`{}`で囲まれた部分は0回以上の繰り返しを表し、その中身のパターン（ここでは `('*' | '/') factor`）が入力とマッチしない場合、この繰り返し部分は何も消費せずに（0回の繰り返しとして）成功となります。
したがって、この部分の解析は成功し、解析位置は変わらず`(SUCCESS, 1)`（先ほどの`NUMBER`解析成功時の次の開始位置）のままとなります。

最初の`factor`の呼び出しは既に成功しているので、規則全体の呼び出しが成功し、`term`の呼び出しから戻ります。

6. 規則`expression`の解析を続行

`term`の呼び出しから戻ってきた先は、規則`expression`の中で、↑で示されている位置です。

```bnf
expression = term ↑ { (`+` | `-`) term }
```

`expression`の本体の中で残りの式である

```text
{ (`+` | `-`) term }
```

を解析する必要があります。現在の解析位置（インデックス1）から始まる文字列は`"+2"`なので、その先頭文字`+`は`('+' | '-')`との照合に成功します。この`+`を消費し、解析位置は`2`の直前（インデックス2）に進みます。次に`term`の解析に移ります。

7. 規則`term`を再び呼び出す

現在の解析位置（インデックス2）から`term`の解析を開始します。つまり、`term("2", 2)`のような呼び出しのイメージです（第1引数は入力全体、第2引数は現在の開始位置）。

そこからは先程と同様に、規則の再帰的な呼び出しを経て、最終的に`NUMBER("2", 2)`で`NUMBER`の解析が成功し、入力文字列の終端に達するので、結果は`(SUCCESS, 3)`（入力文字列長が3の場合、終端の次の位置）となります。

8. 規則`expression`の解析を続行

`term`の呼び出しから戻ってきた先は、規則`expression`の中で、↑で示されている位置です。

```bnf
expression = term { (`+` | `-`) term ↑ }
```

`{}`で囲まれた部分は0回以上の繰り返しですから、次のようにして解析を続行します。

```bnf
expression = term { ↑ (`+` | `-`) term ↑ }
```

しかし、残りの文字列はもう何もない（解析位置が入力文字列の終端に達した）ので、この繰り返しの照合は行われず、`expression`全体の解析は成功し、`(SUCCESS, 3)`となります。

これが最終結果になるので、規則`expression`と文字列`1+2`は一致することがわかりました。

## 2.4 BNFと解析結果

算術式の文法をBNFで表現し、実際に算術式を表す文字列と照合することができました。

しかし、これでは文字列が与えられたBNFにマッチするかどうかの判定しかできません。

皆さんおなじみのJSONがそうであるように、実用的には解析した結果を何らかのデータ構造に変換して格納しておく必要があります。

次の節では、BNFで表現された算術式を解析し、その結果を抽象構文木というデータ構造に変換する方法について説明します。

## 2.5 抽象構文木

抽象構文木とは何でしょうか？今、私達が欲しいのは

- 空白や括弧といった余分な情報が含まれず
- 演算子の優先順位を表現できる

ような構造です。**抽象構文木**（Abstract Syntax Tree）は、そのようなニーズを満たすデータ構造です。

抽象構文木は一般には任意個の子を持つ多分木として表現されます。

たとえば、`1 + 2 * 3`という算術式の抽象構文木は以下のようになります。

<img src="./img/chapter2/ast1.svg" width="50%" height="50%">

抽象構文木の各ノードは、プログラムの構造を表現するためのデータ構造です。たとえば、`+`ノードは足し算を表し、`1`ノードは整数の`1`を表します。

抽象構文木（AST）では、各ノードはプログラムの構成要素を表し、親子関係によって演算子とオペランドの関係性を示します。抽象構文木には次のようなノードがあります。

### 2.5.1 内部ノード

演算子や制御構造など、他のノードを子として持つノードです。

先程の例でいうと、`+`ノードと`*`ノードが内部ノードです。

### 2.5.2 葉ノード

子を持たないノードです。例えば、`1`や`2`、`3`といった数値は葉ノードとなります。

一般的には、リテラルや変数など、それ以上分解できない最小単位のノードが葉ノードとなります。

### 2.5.3 根ノード

抽象構文木の最上位に位置するノードです。抽象構文木の根となるノードであり、プログラム全体を表します。数式の例でいえば、全体を表す`+`ノードが根ノードとなります。

内部ノードと根ノードは排他でないことに注意してください。たとえば、`+`ノードは内部ノードであり、同時に根ノードでもあります。

### 2.5.4 優先順位

改めて、先程の抽象構文木を見てみましょう。

<img src="./img/chapter2/ast1.svg" width="50%" height="50%">

この木構造では、`+`がルートノードであり、その左の子が`1`、右の子が`*`です。`*`ノードの子として`2`と`3`が配置されています。これにより、演算の優先順位が明確に表現されるわけです。

この抽象構文木を見れば、`1 + (2 * 3)` という演算順序が表現されており、`(1 + 2) * 3` のような異なる解釈にはならないことが直感的に理解できるでしょう。

### 2.5.5 抽象構文木をJavaで表現する

抽象構文木は視覚的な表現としても便利ですが、その真価はプログラム上で表現・処理することにあります。ここではJavaで表現する方法を紹介します。

```java
// 式を表すインタフェース
sealed interface Exp permits Add, Sub, Mul, Div, Num {}
// 加算を表すレコード
record Add(Exp lhs, Exp rhs) implements Exp {}
// 減算を表すレコード
record Sub(Exp lhs, Exp rhs) implements Exp {}
// 乗算を表すレコード
record Mul(Exp lhs, Exp rhs) implements Exp {}
// 除算を表すレコード
record Div(Exp lhs, Exp rhs) implements Exp {}
// 数値を表すレコード
record Num(int value) implements Exp {}
```

インタフェース`Exp`は、抽象構文木のノードを表すインタフェースです。

`Add`、`Sub`、`Mul`、`Div`、`Num`は、それぞれ加算、減算、乗算、除算、数値を表すレコードです。これによって、抽象構文木をJavaで表現することができます。

試しに`1 + 2 * 3`の抽象構文木をJavaで表現してみましょう。

```java
// 1 + 2 * 3
Exp exp = new Add(
  new Num(1), new Mul(new Num(2), new Num(3))
);
```

各クラスのインスタンスを作成することで、抽象構文木を表現することができます。

### 2.5.6 抽象構文木を評価する

抽象構文木を作成するだけでは、プログラムの実行結果を得ることはできません。抽象構文木を評価するためには、再帰的な処理を行うことが必要です。抽象構文木を辿りながら、各ノードの演算を行うことで、プログラムの実行結果を得ることができます。

以下は、算術式の抽象構文木を評価するJavaのコード例です。

```java
int eval(Exp e) {
  return switch(e){
    case Num t -> t.value();
    case Add t -> eval(t.lhs()) + eval(t.rhs());
    case Sub t -> eval(t.lhs()) - eval(t.rhs());
    case Mul t -> eval(t.lhs()) * eval(t.rhs());
    case Div t -> {
      if(eval(t.rhs()) == 0) {
        throw new ArithmeticException("division by zero");
      }
      yield eval(t.lhs()) / eval(t.rhs());
    }
  };
}
```

ノードの種類に応じてswitch式で処理を分岐しています。`Num`ノードの場合はその値を返し、`Add`ノードの場合は左右の子ノードを再帰的に評価して足し算を行います。同様に、`Sub`、`Mul`、`Div`ノードの場合も、それぞれの演算を行っています。

この`eval`メソッドを使うことで、次のように抽象構文木を評価することができます。

```java
// 1 + 2 * 3
Exp exp = new Add(
  new Num(1), new Mul(new Num(2), new Num(3))
);
eval(exp); // 7
```

抽象構文木をデータとして表現することで、プログラムの構造を簡単に解析することができるのです。

## 2.6 まとめ

この章では、算術式の文法を例題としてBNFについて紹介し、BNFに基づいて算術式を解析する方法の概要について説明しました。また、抽象構文木についても紹介し、抽象構文木をJavaで表現する方法と、抽象構文木を評価する方法について説明しました。

しかし、今のままではBNFに基づく「構文解析器」は与えられた文字列が文法にマッチするかどうかを判定するだけで、抽象構文木を生成することができません。次章では、ここで学んだBNFの考え方を応用して、実際にJavaで動作するJSONの構文解析器を実装し、JSONの抽象構文木を生成する方法について詳しく説明します。

[^1]: 翻訳: ISO/IEC 14977:1996 Information technology — Syntactic metalanguage — Extended BNF https://hazm.at/mox/lang/meta-language/ebnf/iso-iec-14977-extended-bnf/index.html
