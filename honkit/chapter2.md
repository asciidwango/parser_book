# 2. 構文解析の基本

この章からいよいよ構文解析についての説明を始めたいと思います。とはいっても本書を手に取った皆様は構文解析についてまだ馴染みがないかと思います。そこで、まずは第1章でみたような算術式の構文解析を例にして、構文解析の基本について学ぶことにしましょう。

## 2.1 算術式の文法

ただ「算術式」といっただけだと人によってかなりイメージするものが異なります。本書では以下の条件を満たすものを算術式とします。

- 四則演算が使える
  - 足し算は`x + y`
  - 引き算は`x + y`
  - 掛け算は`x * y`
  - 割り算は`x / y`
- 優先順位は掛け算・割り算が高く、足し算・引き算が低い
  - たとえば、`1 + 2 * 3`は`1 + (2 * 3)`と解釈される
- 同じ優先順位の演算子は左から右に結びつく
  - たとえば、`1 + 2 - 3`は`(1 + 2) - 3`と解釈される
- 値は整数のみ
  - たとえば、`1 + 2.0`のような式はエラーになる
- 式の優先順位を変えるために括弧を使うことができる
  - たとえば、`(1 + 2) * 3`は`3 * 3`と解釈される
- 式の要素間にあるスペースは無視される
  - たとえば、`1+2`は`1 + 2`と同じ

この定義に従う算術式には以下のようなものが含まれます。

```text
1 + 2 * 3
(1 + 2) * 3
3 * (1 + 2)
12 / 3
1 + 3 * 4 / 2
```

普段、皆さんは何かしらのプログラミング言語を使ってプログラムを書いているはずですから、上のような算術式は馴染みが深いはずです。

しかし、上のような日本語を使った定義だけでは算術式の文法を表現するのには不十分です。たとえば「式の要素間にあるスペースは無視される」という言葉だけでは、`10`と`1 0`を区別することができません。優先順位についても感覚的にはわかるものの、やはり定義としては曖昧です。式の優先順位を変えるために括弧を使えるという表現も、直感にはあっているものの現実の文法を表現するには不十分です。

もちろん、日本語でより詳しく記述して曖昧さを少なくしていくこともできますが、いたずらに長くなるだけです。それよりも、文法を表現するための文法である形式文法を使って、算術式の文法を表現することが一般的です。形式文法というと何かしらとても難しいもののように感じられますが、実際には簡単なものです。次節では形式文法の一つであり、もっともメジャーな表記法であるBNF（Backus-Naur Form、バッカス・ナウア記法）を使って、算術式の文法を表現してみましょう。

## 2.2 算術式のBNF

プログラミング言語の文法自体を表現する文法（メタ文法といいます）の一つに、BNFがあります。BNFは、プログラミング言語の文法をはじめ、インターネット上でのメッセージ交換フォーマットなど、様々な文法を表現するのに使われています。本書の読者の方にはBNFに馴染みのない方も多いと思うので、算術式のBNFの前にBNFについて説明します。本書ではISO/IEC 14977で仕様が策定されたEBNFの事を指してBNFと呼ぶことにします。BNFは歴史的に、かなり多くの方言があり、どの記法を使うか事前に説明しておかないと読みづらいためです。

### 2.2.1 BNFの概要

BNFははFortranの開発者でもある、John Backus（ジョン・バッカス）らが開発した記法であるBNFです。BNFは「プログラミング言語」そのものの文法を記述するために開発されました。基本情報技術者試験でも出題されるので、ひょっとしたらそこで知った方もおられるかもしれません。

では、早速具体例を見て行きましょう。

たとえば、Java言語のローカル変数を宣言するプログラムの断片を考えてみると、以下のようになるでしょう。

```java 
// int型の変数x1を宣言して初期値を与えない
int x1;
// int型の変数x2を宣言して1を代入
int x2 = 1;
// String型の変数y1を宣言して初期値を与えない
String y1;
// String型の変数y2を宣言して"Hello, World"を代入
String y2 = "Hello, World"; 
// Double型の変数z1を宣言して初期値を与えない
Double z1;
// Double型の変数z2を宣言して1.0を代入
Double z2 = 1.0;
```

ローカル変数の宣言をよく見て行くと、以下のような形をしていることがわかります。

```text
型 変数名 ('=' 初期値)? ';'
```

`(E)?`は`E`が省略可能であることを示しています。`'='`はその記号自体がでてくることを示しています。

変数宣言の最初にはまず、型名が来て、その次に変数名、続いて省略可能な初期値が来ることを示しています。ローカル変数宣言はセミコロンで終わることも示しています。このように、プログラミング言語の文法には一定のルールがあり、それを曖昧さが無い形で解釈できると便利です。

このようなニーズに答えるのが、BNFです。

先ほどの文法をBNFで表現すると以下のようになります。

```bnf
local_variable_declaration = type_name identifier ('=' expression)? ';'
```

このような、`=`で分かれた内の左側を規則名と呼び、右側を本体と呼びます。また、本体と非終端記号を合わせて規則と呼びます。本書では、BNFを多用していくので、慣れていくようにしてください。

### 2.2.2 算術式のBNF

BNFについて説明し終わったところで、早速、算術式のBNFを見ていくことにしましょう。2.1ででてきた算術式のBNFによる定義は以下で全てです。

```bnf
expression = term { (PLUS | MINUS) term };
term = factor { (MULTIPLY | DIVIDE) factor };
factor = NUMBER | LPAREN expression RPAREN;

PLUS = '+' SPACING;
MINUS = '-' SPACING;
MULTIPLY = '*' SPACING;
DIVIDE = '/' SPACING;
LPAREN = '(' SPACING;
RPAREN = ')' SPACING;
SPACING = (' ' | '\t' | '\n' | '\r')*;
```

たくさんの記号が出てきましたが、順番に見ていきましょう。

### 2.2.3 expression

まず、一番上から読んでいきます。BNFでは、

 ```
expression = term { (PLUS | MINUS) term };
 ```
 
のような、**規則**の集まりによって、文法を表現します。`=`の左側である`expression`が**規則名**で、右側（ここでは `term { (PLUS | MINUS) term }`）が**本体**になります。先程は説明していませんでしたが、本体の中に出てくる、他の規則を参照する部分（ここでは`term`や`PLUS`、`MINUS`)を非終端記号と呼びます。非終端記号は同じBNF内で定義されている規則名と一致する必要があります。

EBNFにおいて`{}`で囲まれたものは、その中の要素が0回以上繰り返して出現することを示しています。`term { (PLUS | MINUS) term }`は、`term`が`PLUS`または`MINUS`を挟んで1回以上繰り返して出現することを示しています。
  
この規則を日本語で表現すると「`expression`という名前の規則は、右辺`term { (PLUS | MINUS) term }`を参照している」と読むことができます。

### 2.2.4 term

`term` は算術式の中で、掛け算や割り算を表す規則です。`factor`という規則を参照しています。

```bnf
term = factor { (MULTIPLY | DIVIDE) factor };
```

この規則によって`term`は、`factor`が`MULTIPLY`または`DIVDE`を挟んで1回以上繰り返して出現することを示しています

### 2.2.5 factor

`factor`は算術式の中で、数値や括弧で囲まれた式を表す規則です。

```bnf
factor = NUMBER | LPAREN expression RPAREN;
```

これによって`factor`は、`NUMBER`または`LPAREN`で始まって、`RPAREN`で終わることを示しています。`NUMBER`は数値を表す規則です。`LPAREN`は開き括弧（`(`）を表し、`RPAREN`は閉じ括弧（`)`)を表します。

### 2.2.5 PLUS

`PLUS`は`+`記号を表す規則です。

```bnf
PLUS = '+' SPACING;
```

`+`のあとに`SPACING`が続くことを示しています。`SPACING`は空白文字の0回以上の繰り返しを表す規則です。`SPACING`については後述します。

### 2.2.6 MINUS

`MINUS`は`-`記号を表す規則です。

```bnf
MINUS = '-' SPACING;
```

`-`のあとに`SPACING`が続くことを示しています。

### 2.2.7 MULTIPLY

`MULTIPLY`は`*`記号を表す規則です。

```bnf
MULTIPLY = '*' SPACING;
```

`*`のあとに`SPACING`が続くことを示しています。

### 2.2.8 DIVIDE

`DIVIDE`は`/`記号を表す規則です。

```bnf
DIVIDE = '/' SPACING;
```

`/`のあとに`SPACING`が続くことを示しています。

### 2.2.9 LPAREN

`LPAREN`は開き括弧（`(`）を表す規則です。

```bnf
LPAREN = '(' SPACING;
```

`(`のあとに`SPACING`が続くことを示しています。

### 2.2.10 RPAREN

`RPAREN`は閉じ括弧（`)`)を表す規則です。

```bnf
RPAREN = ')' SPACING;
```

`)`のあとに`SPACING`が続くことを示しています。

### 2.2.11 SPACING

`SPACING`は空白文字を表す規則です。

```bnf
SPACING = (' ' | '\t' | '\n' | '\r')*;
```

空白文字（スペース、タブ、改行、復帰）が0回以上繰り返して出現することを示しています。

### 2.2.12 まとめ

このようにして、算術式の文法をBNFで表現することができました。重要なのはこのBNFの表現が、先ほどの日本語の説明よりも正確で、曖昧さがないことです。このため、BNFは、プログラミング言語の文法を表現するだけにとどまらず、曖昧さのない文法を表現するためのツールとして広く使われています。構文解析器を作る際にも、BNFを使って文法を表現することが一般的です。

## 2.3 抽象構文木

こうして算術式の文法を曖昧さのない形で表現することができました。この文法を使って、具体的な算術式を解析すると、その結果として**抽象構文木**（Abstract Syntax Tree、AST）というデータ構造が得られます。抽象構文木という考え方はプログラミング言語に留まらず、コンピュータ上の構造化されたデータを表現するのに非常に重要な概念です。この節では、抽象構文木について説明します。

### 2.3.1 抽象構文木とは

抽象構文木は、プログラムの構造を木構造で表現したものです。プログラムの構造を木構造で表現することで、プログラムの構造を効率的に解析することができます。抽象構文木は、プログラムの構造を表現するためのデータ構造であり、プログラムの構造を解析するためのデータ構造です。たとえば、`1 + 2 * 3`という算術式の抽象構文木は以下のようになります。

```text
      +
     / \
    1   *
       / \
      2   3
```

ここで、抽象構文木の各ノードは、プログラムの構造を表現するためのデータ構造です。たとえば、`+`ノードは足し算を表し、`1`ノードは整数の`1`を表します。このように、抽象構文木はプログラムの構造を表現するためのデータ構造であり、プログラムの構造を解析するためのデータ構造です。

TBD