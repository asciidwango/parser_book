# 4. 構文解析アルゴリズム古今東西

　これまで、第2章でJSONを例にしてPEGによる構文解析器と、単純な字句解析器を用いた構文解析器を実装しました。また、第3章でプログラミング言語の構文解析を説明するのに必要な文脈自由文法の概念を紹介しました。そして、ここまで来たようやく準備が整ったので、いよいよ本書の本丸である構文解析アルゴリズムの話が出来ます。

　と言われても、戸惑う読者の方が多いかもしれません。なにせ、これまで「構文解析アルゴリズム」について具体的な話はまったくなかったのでしたから。しかし、皆さんは既に、第2章で**二つ**の構文解析アルゴリズムを使ってJSONの構文解析器を書いているのです。

　多少用語として不正確なのを承知で言うなら、第2章で最初に実装したのは、バックトラックあり再帰下降構文解析器であり、後で実装したのは、LL(1)（っぽい）再帰下降構文解析器と言えます。この、「再帰下降」という言葉が見慣れないものなので、はてなと思われるかもしれませんが、その疑問は一端脇においておいて、第2章での実装が理解出来たなら、皆さんは既に直感的には構文解析アルゴリズムを理解していることになります。

　この章では、2021年8月現在までに発表された主要な（いくつかは筆者の独断と偏見が入っています）構文解析アルゴリズムについて解説していきます。実用的には、紹介する構文解析アルゴリズムのほとんどについて、その構文解析アルゴリズムを使った構文解析器を生成してくれる**構文解析器生成系**が存在するからです。たとえば、おそらく最もメジャーな構文解析器生成系は、`LALR(1)`アルゴリズムを用いたyacc（正確には、GNUによる再実装であるbisonが現在は主流）でしょう。yaccに似た構文解析器生成系はC向けのyaccの他に、Ruby向けのracc、Java向けのJay、OCaml向けのocamlyaccなど数多くのバリエーションがあります。

　他には、`LL(*)`アルゴリズムを用いたANTLRや`LL(k)`アルゴリズムを用いたJavaCCもよく使われています。構文解析器生成系では昔は圧倒的にyaccがメジャーでしたが（個人の感想です）、最近は`LL(k)`アルゴリズムやその拡張もよく見るようになってきました。また、2002年にBryan Fordが発表したPackrat Parsing（正確には、それを形式化したPEG）を用いた構文解析生成系も数多く登場しています。とりわけ、PEGは構文解析器生成系を作るのがとても簡単なこともあって、色々な言語向けの構文解析器生成系が多数公開されています。かくいう筆者も、大学院生時代にPEGおよびPackrat Parsingの研究をしており、その課程で実験用の構文解析器生成系を作ったものでした。

　あまり小難しいことばかり言うのは趣味ではないので、早速、構文解析アルゴリズムの世界を覗いて見ましょう！　

## 4.1 トップダウン構文解析とボトムアップ構文解析

　と言ったばかりなのに大変恐縮なのですが、具体的な構文解析アルゴリズムの解説に入る前に、構文解析アルゴリズムは大別して、

- 上から下へ（トップダウン）
- 下から上へ（ボトムアップ）

　の二つのアプローチがあることを理解しておきましょう。といっても、難しい話ではありません。

　まずはトップダウン構文解析法です。第3章で例に出てきたDyck言語の文法は以下のようなものでした。

```bnf
D = P
P = "(" P ")" | ""
```

　このBNFは、カッコが正しくネストした文字列を過不足無く表現しているわけですが、このBNFを元にして自力で構文解析器を作るにはどうすればいいか考えてみましょう。おそらく、まず皆さんが素朴に思いつくのは以下のような実装ではないかと思います。

```java
public class Dyck {
    public boolean D () {
        P();
    }
    public boolean P() {
        while(hasNext()) {
            String first = peekToken();
            if(first.equals("("))) {
                nextToken();
                P();
                String end = nextToken();
                return end.equals(")");
            } else {
                return true;
            }
        }
    }
}
```

　このプログラムあるいはクラス`Dyck`はまさに`Dyck`言語を構文解析して、成功したなら`true`、そうでなければ`false`を返すものです。BNFと比較すると、

- 規則の名前と一対一になる関数が存在する
- 非終端記号への参照は規則の名前に対応する関数の**再帰呼び出し**として実現されている

のが特徴です。呼び出す規則を上、呼び出される規則を下とした時、上から下に再帰呼び出しが続いていくため再帰下降構文解析と呼ばれます。このような、「上から下に」構文解析を行っていくのがトップダウン型構文解析法の特徴です。注意しなければいけないのは、上から下へ解析を行うアルゴリズムは多数あり、その一つに再帰下降構文解析があるということです。その他のトップダウン型構文解析法については後々紹介していきますのでご安心ください。

　一方、ボトムアップ構文解析法はその逆です。といっても、こちらの方法はトップダウン型より直感的に理解しづらいかもしれません。ボトムアップ構文解析法の直感的なイメージは、「右から左にブロックが順番に降って来て、BNFの右辺にマッチした記号列があれば、左辺の規則名にマッチしたとして、還元動作をおこなうこと」です。

　たとえば、`(())`という文字列を解析することを考えてみましょう。ボトムアップ解析では、まず、最初の「1文字」を右から左にシフトします。ちょうど以下のようなイメージです。

```bnf
「(」
```

　このブロックとルールPの右辺はマッチしないので、もう1文字をシフトしてみます。

```bnf
「（」「(」
```

　まだマッチしない……本当にそうでしょうか？しかし、よく見ると規則Pの右辺には空文字列`"`も含まれているのでした。ということは、空のブロック「」とマッチしたことにして、以下のように考えても問題ないことになります。

```bnf
「（」「（」P
```

　さらに、1文字シフトすると、

```bnf
「（」「（」P「）」
```

　となります。これは、Pの右辺にマッチするので、以下のように還元出来そうです。

```bnf
「（」P「）」
```

　さらに、同様にしてこれはPの右辺にマッチするので、最終的にPに還元されます：

```bnf
P
```

　そして、Dの右辺はPなので、

```bnf
D
```

となり、めでたく最終結果であるDの構文解析に成功しました。このように、

1. とりあえず、文字を右から左に引っ張って、積み重ねる（シフト）
2. 文法を参照して、右辺が積み重なった記号列にマッチしたら、左辺の記号に置き換える（還元）

を繰り返し行くアプローチをボトムアップ構文解析法を呼びます。トップダウン型の構文解析アルゴリズムが多数あるように、ボトムアップ型の構文解析アルゴリズムも多数あります。一番著名であると思われるyaccが採用しているLALR(1)もボトムアップ型の構文解析アルゴリズムです。

ちなみに、トップダウン型とボトムアップ型にはそれぞれ異なった利点と欠点があります。特に、トップダウン型は規則と関数を対応付けるのが容易なので手書きの構文解析器を書くのに向いて居ますし、関数の引数として情報を渡して、それに応じて処理を分岐させるといったことが得意です。一方で、トップダウン型は左再帰に弱いという欠点があります。たとえば、以下のBNFは、ボトムアップ型だと`a*`に相当する言語を普通に解析出来ますが、工夫なしにトップダウン型で実装すると無限再帰に陥ってスタックオーバーフローします。

```
A = A "a"
  | "";
```

もちろん、このような問題をトップダウン型で解決する方法も存在します。端的に言うと、「再帰をループに置き換える」といったもので、BNFを

```
A = "a" A
  | "";
```

このように書き換えればトップダウン型でも問題なく解析出来るようになります。しかし、ならボトムアップ型が一方的に有利なのかというと事態はそう単純ではないのが面白いところです。特に、前後の文脈に応じて構文解析方法を切り替えるのは比較的ボトムアップ型だとやりづらいところです（出来ない訳ではないです）。
