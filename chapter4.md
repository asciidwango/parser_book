# 4. 構文解析アルゴリズム古今東西

　これまで、第2章でJSONを例にしてPEGによる構文解析器と、単純な字句解析器を用いた構文解析器を実装しました。また、第3章でプログラミング言語の構文解析を説明するのに必要な文脈自由文法の概念を紹介しました。そして、ここまで来たようやく準備が整ったので、いよいよ本書の本丸である構文解析アルゴリズムの話が出来ます。

　と言われても、戸惑う読者の方が多いかもしれません。なにせ、これまで「構文解析アルゴリズム」について具体的な話はまったくなかったのでしたから。しかし、皆さんは既に、第2章で**二つ**の構文解析アルゴリズムを使ってJSONの構文解析器を書いているのです。

　多少用語として不正確なのを承知で言うなら、第2章で最初に実装したのは、バックトラックあり再帰下降構文解析器であり、後で実装したのは、LL(1)（っぽい）再帰下降構文解析器と言えます。この、「再帰下降」という言葉が見慣れないものなので、はてなと思われるかもしれませんが、その疑問は一端脇においておいて、第2章での実装が理解出来たなら、皆さんは既に直感的には構文解析アルゴリズムを理解していることになります。

　この章では、2021年8月現在までに発表された主要な（いくつかは筆者の独断と偏見が入っています）構文解析アルゴリズムについて解説していきます。実用的には、紹介する構文解析アルゴリズムのほとんどについて、その構文解析アルゴリズムを使った構文解析器を生成してくれる**構文解析器生成系**が存在するからです。たとえば、おそらく最もメジャーな構文解析器生成系は、`LALR(1)`アルゴリズムを用いたyacc（正確には、GNUによる再実装であるbisonが現在は主流）でしょう。yaccに似た構文解析器生成系はC向けのyaccの他に、Ruby向けのracc、Java向けのJay、OCaml向けのocamlyaccなど数多くのバリエーションがあります。

　他には、`LL(*)`アルゴリズムを用いたANTLRや`LL(k)`アルゴリズムを用いたJavaCCもよく使われています。構文解析器生成系では昔は圧倒的にyaccがメジャーでしたが（個人の感想です）、最近は`LL(k)`アルゴリズムやその拡張もよく見るようになってきました。また、2002年にBryan Fordが発表したPackrat Parsing（正確には、それを形式化したPEG）を用いた構文解析生成系も数多く登場しています。とりわけ、PEGは構文解析器生成系を作るのがとても簡単なこともあって、色々な言語向けの構文解析器生成系が多数公開されています。かくいう筆者も、大学院生時代にPEGおよびPackrat Parsingの研究をしており、その課程で実験用の構文解析器生成系を作ったものでした。

　あまり小難しいことばかり言うのは趣味ではないので、早速、構文解析アルゴリズムの世界を覗いて見ましょう！　

## 4.1 トップダウン構文解析とボトムアップ構文解析

　と言ったばかりなのに大変恐縮なのですが、具体的な構文解析アルゴリズムの解説に入る前に、構文解析アルゴリズムは大別して、

- 上から下へ（トップダウン）
- 下から上へ（ボトムアップ）

　の二つのアプローチがあることを理解しておきましょう。といっても、難しい話ではありません。

　まずはトップダウン構文解析法です。第3章で例に出てきたDyck言語の文法は以下のようなものでした。

```bnf
D = P
P = "(" P ")" | ""
```

　このBNFは、カッコが正しくネストした文字列を過不足無く表現しているわけですが、このBNFを元にして自力で構文解析器を作るにはどうすればいいか考えてみましょう。おそらく、まず皆さんが素朴に思いつくのは以下のような実装ではないかと思います。

```java
public class Dyck {
    public boolean D () {
        P();
    }
    public boolean P() {
        while(hasNext()) {
            String first = peekToken();
            if(first.equals("("))) {
                nextToken();
                P();
                String end = nextToken();
                return end.equals(")");
            } else {
                return true;
            }
        }
    }
}
```

　このプログラムあるいはクラス`Dyck`はまさに`Dyck`言語を構文解析して、成功したなら`true`、そうでなければ`false`を返すものです。BNFと比較すると、

- 規則の名前と一対一になる関数が存在する
- 非終端記号への参照は規則の名前に対応する関数の**再帰呼び出し**として実現されている

のが特徴です。呼び出す規則を上、呼び出される規則を下とした時、上から下に再帰呼び出しが続いていくため再帰下降構文解析と呼ばれます。このような、「上から下に」構文解析を行っていくのがトップダウン型構文解析法の特徴です。注意しなければいけないのは、上から下へ解析を行うアルゴリズムは多数あり、その一つに再帰下降構文解析があるということです。その他のトップダウン型構文解析法については後々紹介していきますのでご安心ください。

　一方、ボトムアップ構文解析法はその逆です。といっても、こちらの方法はトップダウン型より直感的に理解しづらいかもしれません。ボトムアップ構文解析法の直感的なイメージは、「右から左にブロックが順番に降って来て、BNFの右辺にマッチした記号列があれば、左辺の規則名にマッチしたとして、還元動作をおこなうこと」です。

　たとえば、`(())`という文字列を解析することを考えてみましょう。ボトムアップ解析では、まず、最初の「1文字」を右から左にシフトします。ちょうど以下のようなイメージです。

```bnf
「(」
```

　このブロックとルールPの右辺はマッチしないので、もう1文字をシフトしてみます。

```bnf
「（」「(」
```

　まだマッチしない……本当にそうでしょうか？しかし、よく見ると規則Pの右辺には空文字列`"`も含まれているのでした。ということは、空のブロック「」とマッチしたことにして、以下のように考えても問題ないことになります。

```bnf
「（」「（」P
```

　さらに、1文字シフトすると、

```bnf
「（」「（」P「）」
```

　となります。これは、Pの右辺にマッチするので、以下のように還元出来そうです。

```bnf
「（」P「）」
```

　さらに、同様にしてこれはPの右辺にマッチするので、最終的にPに還元されます：

```bnf
P
```

　そして、Dの右辺はPなので、

```bnf
D
```

となり、めでたく最終結果であるDの構文解析に成功しました。このように、

1. とりあえず、文字を右から左に引っ張って、積み重ねる（シフト）
2. 文法を参照して、右辺が積み重なった記号列にマッチしたら、左辺の記号に置き換える（還元）

を繰り返し行くアプローチをボトムアップ構文解析法を呼びます。トップダウン型の構文解析アルゴリズムが多数あるように、ボトムアップ型の構文解析アルゴリズムも多数あります。一番著名であると思われるyaccが採用しているLALR(1)もボトムアップ型の構文解析アルゴリズムです。

ちなみに、トップダウン型とボトムアップ型にはそれぞれ異なった利点と欠点があります。特に、トップダウン型は規則と関数を対応付けるのが容易なので手書きの構文解析器を書くのに向いて居ますし、関数の引数として情報を渡して、それに応じて処理を分岐させるといったことが得意です。一方で、トップダウン型は左再帰に弱いという欠点があります。たとえば、以下のBNFは、ボトムアップ型だと`a*`に相当する言語を普通に解析出来ますが、工夫なしにトップダウン型で実装すると無限再帰に陥ってスタックオーバーフローします。

```
A = A "a"
  | "";
```

もちろん、このような問題をトップダウン型で解決する方法も存在します。端的に言うと、「再帰をループに置き換える」といったもので、BNFを

```
A = "a" A
  | "";
```

このように書き換えればトップダウン型でも問題なく解析出来るようになります。しかし、ならボトムアップ型が一方的に有利なのかというと事態はそう単純ではないのが面白いところです。特に、前後の文脈に応じて構文解析方法を切り替えるのは比較的ボトムアップ型だとやりづらいところです（出来ない訳ではないです）。

## 4.2 LL(1) - 代表的なトップダウン構文解析アルゴリズム

構文解析アルゴリズムの中でおそらくもっとも古典的で、よく知られているのは`LL(1)`構文解析アルゴリズムです。なんか一見小難しく見えますよね。しかし、`LL(1)`のイメージというのは意外に簡単なものです。

たとえば、以下のようなJava言語のif文があったとします。

```java
if(age < 18) {
    System.out.println("18歳未満です");
} else {
    System.out.println("18歳以上です");
}
```

非常に簡単ですよね。しかし、我々は如何にしてこれを見て「if文がある」と認識するのでしょうか。もちろん「人それぞれ」なのですが、最初に`if`が現れたからif文だと考える人も多いのではないかと思います。

`LL(1)`構文解析アルゴリズムはまさにこのイメージを元にした手法です。プログラムをトークン列に区切った後に、「最初の1トークン」を見て、「あ、これはif文だ」とか「あ、これはwhile文だ」とか認識するようなものですね。

ただし、イメージとしては簡単なのですが、アルゴリズムとして実行可能なようにするためには考えなければいけない論点がいくつかあります。以下では、`LL(1)`を実装するに当たって考えなければいけない課題について論じてみます。

### 課題1 - ある構文の最初のトークンが複数種類ある場合

先程の例ではある構文、たとえばif文が始まるには`if`というキーワードが必須で、それ以外の方法でif文が始まることはありえませんでした。しかし、たとえば、算術式を考えてみると、問題はそう単純ではないことがわかります。少し考えただけでも、以下のような例が思い浮かびます。

- `(`で算術式が始まる場合
- `-`で算術式が始まる場合
- `+`で算術式が始まる場合
- 整数リテラル（`<integer_literal>`）で算術式が始まる場合
- 浮動小数点数リテラル（`<floating_point_literal>`）で算術式が始まる場合

つまり、次のトークンが算術式の始まりである事を確定するためには、トークンの集合という概念が必要になります。たとえば、算術式の始まりは

```
{"(", "-", "+", <integer_literal>, <floating_point_literal>, ...}
```

のようなトークンの集合であると考える事が出来ます。このような、ある構文が始まるかを決定するために必要なトークンの集合のことを**FIRST集合**と呼びます。

### 課題2 - 省略可能な要素の扱い

if文の例は、次の1トークンを見ればどんな構文かわかる例でした。しかし、if文にelseが出てこない場合に、if文からif-else文か正確に決定するにはどうすればいいのでしょうか？たとえば、以下の文は正当です。

```java
if(age < 18) {
    System.out.println("18歳未満です");
};
if(age >= 18) {
    System.out.println("18歳未満です");
}
```

他方で以下の文も正当です。

```java
if(age < 18) {
    System.out.println("18歳未満です");
}
if(age >= 18) {
    System.out.println("18歳未満です");
}
```

最初のif文の後に、

- 前者は`;`が出現する
- 後者は`if`が出現する

という違いがあるわけですが、どちらの場合にしても、それらが出現した時点で最初のif文が終わるのは明らかでしょう。以下の場合、`System`が出現した時点で最初のif文が終了したことはわかります。

```java
if(age < 18) {
    System.out.println("18歳未満です");
}
System.out.println("終了します");
```

まとめると、

- 直後に`else`が出現すればif-else文である
- それ以外で、かつ構文エラーにならないあらゆるトークンが出てきた場合、if文である

ということが出来そうです。しかし「あらゆるトークン」と言われても漠然としていて、アルゴリズムとしては不完全です。アルゴリズムとしては、以下のようになっていなければ困ります。

- 直後に`else`が出現すればif-else文である
- トークン `{";", <identifier>, "if", ...}`が出てきた場合、if文である

`LL(1)`をきちんと考えようとすると、「省略可能なトークンの次のトークンの集合」について考える必要があるわけです。このような「～の次のトークンの集合」も、ある構文がどう始まるかを決定するのに必要になります。これを**FOLLOW集合**と呼びます。

先の項で出てきた**FIRST集合**と**FOLLOW集合**は`LL(1)`にとって重要な概念です。次の項以降では、この**FIRST集合**と**FOLLOW集合**の概念についてより厳密に説明します。

### FIRST集合とFOLLOW集合の計算

`LL(1)`をアルゴリズムとしてきちんと定義しようとするなら、この二つの概念が必要であることはわかってもらえたと思います。しかし、この二つですが、一体プログラム上でどう計算すれば良いのでしょうか？この問いに答える事が`LL(1)`アルゴリズムをきちんと理解する事であり、逆にきちんと理解出来れば、自力で`LL(1)`アルゴリズムによるパーザを記述出来るようになるでしょう。

まずはFIRST集合について考えてみます。(WIP)

次にFOLLOW集合について考えてみます。(WIP)

## LL(1)の問題点と限界

`LL(1)`は古典的でありかつそれなりに実用的でもありますが、アルゴリズムがシンプルである故の問題点や限界も存在します。この後では`LL(1)`の抱える問題点について述べます。

### 問題点1 - 最初の1トークンで構文要素を決められない場合

先の節では明らかに最初の1トークンで「これはif文」とか「これはwhile文」とか決められる場合のみを対象にしてきました。しかし、現実にはそれだけではどうにもならない場合があります。

たとえば、Java 7で導入されたダイヤモンド演算子について考えてみます。以下のようにして、ジェネリクスの型パラメータ指定を省略出来る機能です。

```java
List<Person> people;
person = new ArrayList<>();
```

ここで、右辺の`new ArrayList<>`について注目してみましょう。`<`はJava言語ではそれだけで一つのトークンですが、`ArrayList`の直後にある`<`を見ただけではダイヤモンド演算子を使っているかはわかりません。なぜかと言えば、その後に`Person>`と続く可能性を否定出来ないからです。

この問題を回避するには、`<`が出現した時点では、「なんか型パラメータぽい」とくくっておいて、次に`>`が来たらダイヤモンド演算子、そうでなければ普通に型パラメータ指定があるのだと決定するのが有効です。

このように、1トークン先を見ただけでわからない場合に、「なんか型パラメータぽい」と決定を先延ばしにする事で`LL(1)`の問題点にある程度対処出来ます。

-->