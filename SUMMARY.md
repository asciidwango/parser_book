### [0. はじめに](./preface.md)

### 1. 構文解析の世界へようこそ

構文解析とは何か、についての簡単なイントロ。書籍を読む上での必要な条件、構成などについて説明する。なので、この部分は最後に書く感じで行く。

### [2. 身近な構文解析器](./chapter2.md)

構文解析や構文解析器というのが身近にあることを理解してもらう。特に、JSONを例にとって、構文解析がどのようにして行われるかを説明する。


記述言語はJavaを前提にする（JavaScriptにした場合、ECMAScriptのどのバージョン準拠かなどでややこしいのと、ブラウザのAPIを使わなければ表現しづらいものもあるため）。

#### 2.1. JSON（JavaScript Object Notation）

JSONのおおまかな仕様を説明する。ここで、BNFを同時に導入する。

参考: https://www.json.org/json-en.html
 
#### 2.2. 字句解析

字句解析の方法について、JSONの字句解析を例にして説明。「1文字」と「1トークン」の違いについて理解してもらう。たとえば、

```
"foo"
```

は `"foo"` で1トークンになることなど。

#### 2.3 再帰下降構文解析

手書き構文解析器を使った場合の手法である再帰下降構文解析について、JSONの構文解析器を通じて学んでもらう。

#### 2.4 抽象構文木の構築

2.3では、与えられた文字列がJSONかどうかは判定できても、構造を取得できないことに言及して、抽象構文木の概念を導入する。ここで、抽象構文木が小難しいものではなく、身近なものであることを実感してもらうことに主眼を置く。


#### 2.5 まとめ

JSONの構文解析には、

1. 字句解析
2. 構文解析
3. 抽象構文木の構築

という3つのフェーズが必要なことを改めて強調しておく（実際には、構文解析と抽象構文木の構築は同時に行われるので、説明の仕方を考えたい）。


### 4. 文脈自由文法の世界

3.までで、BNFについて何らかの形で取り扱うことを前提とした上で、文脈自由文法（Context Free Grammer）の概念を導入する。また、BNFで取り扱える言語は、文脈自由言語に属することも説明する（文法（Grammar）と言語（Language）を区別してもらう）。


### 3. 構文解析アルゴリズム古今東西

2で説明したものは、非常にたくさんある構文解析手法の一つであることをここで明かした上で、「構文解析アルゴリズム」という考え方を導入する。

その上で、現在までに知られている様々な構文解析アルゴリズムについて、簡単な特徴を列挙する。
それぞれ、詳しくは後続の章に書く。

- 演算子優先順位法
- LL法
  - LL(1)
  - LL(k)
  - LL(*)
  - ALL(*)
- LR
  - SLR
  - LALR
  - LR(0)
  - LR(1)
  - LR(k)
- Generalized Parsing
  - Generalized LL
  - Generalized LR
- PEG
  - Packrat Parsing

#### 4.1 演算子優先順位法

比較的シンプルな構文解析アルゴリズムである演算子優先順位文法について説明する。

#### 4.2 トップダウン構文解析アルゴリズム

トップダウン構文解析アルゴリズムとして代表的なLL(k)法と比較的近年になって確立された
LL(*)法(2010)、その発展形であるALL(*)について説明する。

#### 4.3  ボトムアップ構文解析アルゴリズム

ボトムアップ構文解析の代表であるLR法とその変種である、SLR法、LALAR法、LR法について説明する。

#### 4.4. Generalized Parsing

Generalized LL(GLL)とGeneralied LR(GLR)という、二つの、LL法とLR法を一般化した
アルゴリズムについて取り扱う。どちらの構文解析アルゴリズムも文脈自由文法全体を扱えるものである
ことを説明する。

### 5. 文脈自由文法を超えて

これまで説明してきた構文解析アルゴリズムが、全て文脈自由言語を解析するためのものであり、制限があることを踏まえて、文脈自由ではない言語を取り扱うためにはどのような方法があるかを説明する。

#### 5.1 Parsing Expression Grammar

#### 5.2 Packrat Parsing

#### 5.3 Parsing Expression GrammarとParser Combinator

### 6. 構文解析器生成系の世界

構文解析は、アルゴリズムが決まれば、通常は一意に構文解析器を生成できるという特徴がある。この特徴を生かして、BNFライクな記述から構文解析器を生成するプログラムが作れることを示す。

### 6.1 JSONの構文解析器を生成する

LL(1)構文解析器生成系で、JSONのパーザが作れることを示す。これを通じて、構文解析器生成系が実用的に使えることを理解してもらう。

### 6.2 構文解析器生成系の分類

代表的な構文解析器生成系について、分類を行う。

- yacc(bison)
- JavaCC、
- ANTLRV4
- Coco/R

などについて紹介する予定。

### 6.3 JavaCC

### 6.4 ANTLR

### 6.5 yacc

### 6.6 Coco/R

### 7. 現実の構文解析

既存の構文解析アルゴリズムではそのままではうまく取り扱えない諸問題について、何がやっかいなのか、既存の処理系はどう解決しているかについて述べる。

#### 7.1 字句要素が構文要素を含む文法

Ruby、Scala、Kotlinといった様々な言語が持つ、文字列補間（String Interpolation）
を例として解説する。

#### 7.2 インデント文法

Pythonのインデントによりプログラムの構造を表現する文法を例とする。

#### 7.3 ヒアドキュメント

Rubyのヒアドキュメントをパーズすることの難しさを說明する。

#### 7.4 改行終端可能文法

Ruby、Scala、Kotlin、Swift、Goなどの、改行によって文や式といった単位を終端
させることができる文法をパーズすることのめんどくささを說明する。

#### 7.x 他、思いついたら追加するかも

### 8. おわりに - 形式言語理論への招待 -

本書を締めくくる章であると同時に、構文解析の根底にある形式言語理論への導入
となることを意図している

### 付録

- 各構文解析器生成系によるFUN言語の構文解析器実装
- 7章のような拡張を各構文解析器生成系で扱う際のサンプルプログラム
- 参考文献
